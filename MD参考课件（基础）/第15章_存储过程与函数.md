# 1. MySQL 存储过程概述
### MySQL 存储过程概述

MySQL从5.0 版本开始支持存储过程和函数。存储过程（Stored Procedure）是一组**预先编译**的 SQL 语句封装，可以在 MySQL 服务器端执行，客户端只需调用存储过程，无需重复书写 SQL 语句。这样可以提高 SQL 代码的**重用性**、**安全性**和**执行效率**。

## **1. 存储过程 vs. 视图 vs. 函数**

| 特性  | 视图（View） | 存储过程（Stored Procedure） | 函数（Function） |
|-------|-------------|--------------------------|------------------|
| **作用** | 生成虚拟表，简化查询 | 执行一组 SQL 语句 | 计算并返回一个值 |
| **是否存储 SQL 逻辑** | 否，仅存储查询结果 | 是，存储完整的 SQL 逻辑 | 是，存储 SQL 逻辑 |
| **是否接受参数** | 否 | 是 | 是 |
| **是否返回值** | 是（但仅查询数据） | 否 | 是 |
| **是否可操作表** | 否（查询数据，不修改） | 是 | 是 |
| **调用方式** | `SELECT * FROM view_name;` | `CALL procedure_name();` | `SELECT function_name();` |

## **2. 存储过程的参数类型**
存储过程可以接受 3 种类型的参数：

1. `IN`：输入参数（调用时传入）
2. `OUT`：输出参数（调用后返回结果）
3. `INOUT`：既可以传入，又可以传出

## **3. 创建存储过程**
在 MySQL 中，创建存储过程需要 `DELIMITER` 语法，防止 SQL 解析错误。

### **（1）无参数无返回值**
适用于执行固定的 SQL 逻辑，无需外部输入或返回结果。

```sql
DELIMITER //
CREATE PROCEDURE GetAllUsers()
BEGIN
    SELECT * FROM users;
END //
DELIMITER ;
```

**调用存储过程：**
```sql
CALL GetAllUsers();
```

### **（2）带 `IN` 参数（有参数无返回）**
适用于带输入条件但无返回值的情况。

```sql
DELIMITER //
CREATE PROCEDURE GetUserById(IN user_id INT)
BEGIN
    SELECT * FROM users WHERE id = user_id;
END //
DELIMITER ;
```

**调用存储过程：**
```sql
CALL GetUserById(3);
```

### **（3）带 `OUT` 参数（无参数有返回）**
适用于执行 SQL 逻辑后返回某个值。

```sql
DELIMITER //
CREATE PROCEDURE GetUserCount(OUT user_count INT)
BEGIN
    SELECT COUNT(*) INTO user_count FROM users;
END //
DELIMITER ;
```

**调用存储过程并获取返回值：**
```sql
CALL GetUserCount(@count);
SELECT @count;  -- 输出用户总数
```

### **（4）带 `IN` 和 `OUT` 参数（有参数有返回）**
适用于计算逻辑后返回结果。

```sql
DELIMITER //
CREATE PROCEDURE GetUserOrders(IN user_id INT, OUT order_count INT)
BEGIN
    SELECT COUNT(*) INTO order_count FROM orders WHERE user_id = user_id;
END //
DELIMITER ;
```

**调用存储过程并获取返回值：**
```sql
CALL GetUserOrders(2, @orders);
SELECT @orders;  -- 输出用户订单数量
```

### **（5）带 `INOUT` 参数（有参数有返回）**
适用于参数既能输入又能修改的情况。

```sql
DELIMITER //
CREATE PROCEDURE DoubleNumber(INOUT num INT)
BEGIN
    SET num = num * 2;
END //
DELIMITER ;
```

**调用存储过程：**
```sql
SET @value = 5;
CALL DoubleNumber(@value);
SELECT @value;  -- 输出 10
```

## **4. 存储过程的优缺点**

### **✅ 优势**
1. **提高代码复用性**：避免重复编写 SQL 语句
2. **提升安全性**：隐藏 SQL 逻辑，防止 SQL 注入
3. **减少网络流量**：只需传输 `CALL` 命令，而不是整个 SQL 语句
4. **优化性能**：存储过程被服务器**预编译**，执行速度更快

### **❌ 缺点**
1. **调试较难**：存储过程不像普通 SQL 语句那样容易调试
2. **执行灵活性较低**：相比于动态 SQL，存储过程的灵活性有限
3. **维护成本高**：复杂存储过程可能会增加维护难度
4. **数据库负载增加**：存储过程在数据库端执行，可能增加服务器压力

## **5. 删除存储过程**
```sql
DROP PROCEDURE IF EXISTS GetAllUsers;
```

## **6. 总结**
- **存储过程可以封装一组 SQL 语句，提升代码复用性和安全性**
- **支持 `IN`、`OUT` 和 `INOUT` 参数**
- **调用方式简单，使用 `CALL procedure_name()`**
- **适用于执行复杂的 SQL 逻辑，但调试和维护相对复杂**

---

# 2. 创建存储过程

## 2.1 语法分析
存儲過程類似於 **Java 方法 (Method)**，可以封裝 **多條 SQL 語句**，並且可以接受輸入參數 (IN)，返回輸出參數 (OUT)，或同時作為輸入和輸出 (INOUT)。

**優點**
1. **代碼復用**：減少重複 SQL 語句，提高可維護性。
2. **提高性能**：在數據庫服務器內部執行，減少與應用程序的數據傳輸。
3. **提高安全性**：可設置權限，控制誰能調用存儲過程。

### **基本語法**
```sql
DELIMITER $$

CREATE PROCEDURE 存儲過程名(IN|OUT|INOUT 參數名  參數類型,...)
[CHARACTERISTICS ...]
BEGIN
    -- SQL 語句
END $$

DELIMITER ;
```
> `DELIMITER $$`：因為 MySQL 預設的 SQL 結束符號是 `;`，但存儲過程內部可能會使用 `;`，所以需要臨時改變 `DELIMITER` 避免衝突。

类似于Java中的方法：

```sql
修饰符 返回类型 方法名(参数类型 参数名,...){
	方法体;
}
```

### **參數類型**
- `IN`：当前参数为输入参数，也就是表示入参；

  存储过程只是读取这个参数的值。如果没有定义参数种类，`默认就是 IN`，表示输入参数。

- `OUT`：当前参数为输出参数，也就是表示出参；

  执行完成之后，调用这个存储过程的客户端或者应用程序就可以读取这个参数返回的值了。

- `INOUT`：当前参数既可以为输入参数，也可以为输出参数。

#### **範例 1：無參數存儲過程**
**創建存儲過程**
這是一個最簡單的存儲過程，不接受任何參數，只是輸出一條消息。
```sql
DELIMITER $$

CREATE PROCEDURE say_hello()
BEGIN
    SELECT 'Hello, MySQL 存儲過程!';
END $$

DELIMITER ;
```

**調用存儲過程**
```sql
CALL say_hello();
```
**輸出**
```
Hello, MySQL 存儲過程!
```

#### **範例 2：帶輸入參數 (IN)**
**創建存儲過程**
這個存儲過程接受一個名字作為輸入，並返回一條歡迎消息。
```sql
DELIMITER $$

CREATE PROCEDURE greet_user(IN user_name VARCHAR(50))
BEGIN
    SELECT CONCAT('Hello, ', user_name, '!');
END $$

DELIMITER ;
```

**調用存儲過程**
```sql
CALL greet_user('Alice');
```
**輸出**
```
Hello, Alice!
```

#### **範例 3：帶輸出參數 (OUT)**
**創建存儲過程**
這個存儲過程計算一個數的平方，並將結果存儲在 `OUT` 參數中。
```sql
DELIMITER $$

CREATE PROCEDURE square_number(IN num INT, OUT result INT)
BEGIN
    SET result = num * num;
END $$

DELIMITER ;
```

**調用存儲過程**
```sql
CALL square_number(5, @output_result);
SELECT @output_result;
```
**輸出**
```
25
```

#### **範例 4：帶輸入 & 輸出參數 (INOUT)**
**創建存儲過程**
這個存儲過程對傳入的數值進行 +1 運算。
```sql
DELIMITER $$

CREATE PROCEDURE increment_number(INOUT num INT)
BEGIN
    SET num = num + 1;
END $$

DELIMITER ;
```

**調用存儲過程**
```sql
SET @my_value = 10;
CALL increment_number(@my_value);
SELECT @my_value;
```
**輸出**
```
11
```

#### **範例 5：使用變量**
**創建存儲過程**
這個存儲過程計算兩個數的和，並將結果存儲在 `OUT` 參數中。
```sql
DELIMITER $$

CREATE PROCEDURE add_numbers(IN num1 INT, IN num2 INT, OUT sum_result INT)
BEGIN
    DECLARE temp_sum INT;
    SET temp_sum = num1 + num2;
    SET sum_result = temp_sum;
END $$

DELIMITER ;
```

**調用存儲過程**
```sql
CALL add_numbers(7, 3, @sum);
SELECT @sum;
```
**輸出**
```
10
```

#### **範例 6：存儲過程內部查詢數據**
假設有一個 `employees` 表：
```sql
CREATE TABLE employees (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(50),
    salary DECIMAL(10,2)
);

INSERT INTO employees (name, salary) VALUES 
('Alice', 50000),
('Bob', 55000),
('Charlie', 60000);
```

**創建存儲過程**
這個存儲過程根據 `id` 查詢員工的薪資。
```sql
DELIMITER $$

CREATE PROCEDURE get_salary(IN emp_id INT, OUT emp_salary DECIMAL(10,2))
BEGIN
    SELECT salary INTO emp_salary FROM employees WHERE id = emp_id;
END $$

DELIMITER ;
```

**調用存儲過程**
```sql
CALL get_salary(2, @salary);
SELECT @salary;
```
**輸出**
```
55000.00
```

#### **範例 7：帶條件判斷的存儲過程**
這個存儲過程根據員工的 `id` 判斷薪資是否超過 `55000`。
```sql
DELIMITER $$

CREATE PROCEDURE check_salary(IN emp_id INT, OUT salary_status VARCHAR(50))
BEGIN
    DECLARE emp_salary DECIMAL(10,2);
    
    SELECT salary INTO emp_salary FROM employees WHERE id = emp_id;
    
    IF emp_salary > 55000 THEN
        SET salary_status = '高薪';
    ELSE
        SET salary_status = '普通薪資';
    END IF;
END $$

DELIMITER ;
```

**調用存儲過程**
```sql
CALL check_salary(1, @status);
SELECT @status;
```
**輸出**
```
普通薪資
```
```sql
CALL check_salary(3, @status);
SELECT @status;
```
**輸出**
```
高薪
```

#### **結論**
1. **存儲過程** 允許我們封裝 SQL 語句，提高代碼復用性和性能。
2. **參數類型**
   - `IN` (輸入)：只能讀取參數值。
   - `OUT` (輸出)：可以改變參數值，並返回結果。
   - `INOUT` (輸入 & 輸出)：可以讀取並修改參數值。
3. **變量**
   - `DECLARE` 用來定義變量。
   - `SET` 賦值給變量。
   - `SELECT INTO` 用來從數據庫獲取值並存入變量。
4. **條件判斷**
   - `IF...ELSE` 可用於存儲過程內的邏輯處理。

---

### 存储过程的形参（参数）类型
在 MySQL 中，存储过程的形参（参数）类型可以是 **MySQL 数据库中支持的任何数据类型**，例如：

- **整数类型**（`INT`、`TINYINT`、`SMALLINT`、`MEDIUMINT`、`BIGINT`）
- **浮点类型**（`FLOAT`、`DOUBLE`、`DECIMAL`）
- **字符串类型**（`CHAR`、`VARCHAR`、`TEXT`）
- **日期时间类型**（`DATE`、`DATETIME`、`TIMESTAMP`、`TIME`、`YEAR`）
- **布尔类型**（实际上是 `TINYINT(1)`，因为 MySQL 没有真正的 `BOOLEAN` 类型）
- **其他类型**（`BLOB`、`JSON`、`ENUM`、`SET`）

這意味著，你可以在存储过程的参数中使用 **任何 MySQL 支持的数据类型**，以便适应不同的数据处理需求。

#### 示例 1：使用 `INT` 作为参数类型
以下存储过程接收一个整数 `user_id`，然后查询该用户的信息：
```sql
DELIMITER $$

CREATE PROCEDURE GetUserById(IN user_id INT)
BEGIN
    SELECT * FROM users WHERE id = user_id;
END $$

DELIMITER ;
```
调用：
```sql
CALL GetUserById(5);
```
> 这里 `user_id` 的数据类型是 `INT`，用于匹配 `users` 表中的 `id` 列。

#### 示例 2：使用 `VARCHAR` 作为参数类型
以下存储过程接收 `user_name` 作为输入参数，并查询用户名匹配的用户：
```sql
DELIMITER $$

CREATE PROCEDURE GetUserByName(IN user_name VARCHAR(50))
BEGIN
    SELECT * FROM users WHERE name = user_name;
END $$

DELIMITER ;
```
调用：
```sql
CALL GetUserByName('Alice');
```
> 这里 `user_name` 是 `VARCHAR(50)`，可以传入字符串值。

#### 示例 3：使用 `DATE` 作为参数类型
以下存储过程接收 `start_date` 和 `end_date`，查询在此时间范围内注册的用户：
```sql
DELIMITER $$

CREATE PROCEDURE GetUsersByDate(IN start_date DATE, IN end_date DATE)
BEGIN
    SELECT * FROM users WHERE created_at BETWEEN start_date AND end_date;
END $$

DELIMITER ;
```
调用：
```sql
CALL GetUsersByDate('2024-01-01', '2024-12-31');
```
> 这里 `start_date` 和 `end_date` 是 `DATE` 类型，用于日期筛选。

#### 示例 4：使用 `DECIMAL` 作为参数类型
以下存储过程计算价格 `price` 的折扣后金额：
```sql
DELIMITER $$

CREATE PROCEDURE ApplyDiscount(IN price DECIMAL(10,2), IN discount FLOAT, OUT final_price DECIMAL(10,2))
BEGIN
    SET final_price = price * (1 - discount);
END $$

DELIMITER ;
```
调用：
```sql
CALL ApplyDiscount(100.00, 0.1, @discounted_price);
SELECT @discounted_price;
```
> 这里 `price` 和 `final_price` 采用 `DECIMAL(10,2)`，确保精确计算。

#### 示例 5：使用 `JSON` 作为参数类型（适用于 MySQL 5.7+）
以下存储过程接收一个 `JSON` 类型参数，解析后获取 `name` 值：
```sql
DELIMITER $$

CREATE PROCEDURE ParseJson(IN json_data JSON)
BEGIN
    SELECT JSON_UNQUOTE(JSON_EXTRACT(json_data, '$.name')) AS user_name;
END $$

DELIMITER ;
```
调用：
```sql
CALL ParseJson('{"name": "Bob", "age": 30}');
```
> `json_data` 是 `JSON` 类型，允许传入 JSON 数据，并解析 `name` 字段。

---

### 存储过程体中可以有多条 SQL 语句，如果仅仅一条SQL 语句，则可以省略 BEGIN 和 END

#### **1. BEGIN...END**
在 MySQL 存储过程中，如果 **有多条 SQL 语句**，则必须用 `BEGIN ... END` 语句块包裹起来；但如果 **只有一条 SQL 语句**，则可以省略 `BEGIN ... END`。

##### **示例 1：只有一条 SQL 语句**
如果存储过程 **仅有一条 SQL 语句**，可以省略 `BEGIN...END`：
```sql
DELIMITER $$

CREATE PROCEDURE GetUserCount()
SELECT COUNT(*) FROM users; $$

DELIMITER ;
```
**调用存储过程**
```sql
CALL GetUserCount();
```
> 由于只有一条 `SELECT` 语句，因此省略 `BEGIN...END`。

##### **示例 2：多条 SQL 语句（必须使用 `BEGIN...END`）**
如果存储过程有**多条 SQL 语句**，必须使用 `BEGIN...END`：
```sql
DELIMITER $$

CREATE PROCEDURE GetUserStats()
BEGIN
    DECLARE total_users INT;
    DECLARE active_users INT;

    SELECT COUNT(*) INTO total_users FROM users;
    SELECT COUNT(*) INTO active_users FROM users WHERE status = 'active';

    SELECT total_users AS TotalUsers, active_users AS ActiveUsers;
END $$

DELIMITER ;
```
**调用存储过程**
```sql
CALL GetUserStats();
```
> 由于包含 **多条 SQL 语句**（声明变量、查询数据），必须用 `BEGIN...END` 包裹。

#### **2. DECLARE（声明变量）**
- `DECLARE` 用于 **声明局部变量**，必须在 `BEGIN...END` 内部，并且 **只能在第一条可执行语句之前声明**。
- 变量可以存储查询结果、计算值等。

**示例**
```sql
DELIMITER $$

CREATE PROCEDURE GetTotalSalary()
BEGIN
    DECLARE total_salary DECIMAL(10,2);

    -- 计算所有员工工资总和
    SELECT SUM(salary) INTO total_salary FROM employees;

    -- 输出结果
    SELECT total_salary AS TotalSalary;
END $$

DELIMITER ;
```
**调用存储过程**
```sql
CALL GetTotalSalary();
```
> `DECLARE total_salary DECIMAL(10,2);` **必须在 `BEGIN...END` 内部**，但 **必须在所有 SQL 语句之前**。

#### **3. SET（赋值语句）**
- `SET` 用于**给变量赋值**，可以赋固定值或动态计算值。

**示例**
```sql
DELIMITER $$

CREATE PROCEDURE CalculateDiscountedPrice(IN price DECIMAL(10,2), IN discount FLOAT, OUT final_price DECIMAL(10,2))
BEGIN
    SET final_price = price * (1 - discount);
END $$

DELIMITER ;
```
**调用存储过程**
```sql
CALL CalculateDiscountedPrice(100.00, 0.1, @discounted_price);
SELECT @discounted_price;
```
> `SET final_price = price * (1 - discount);` **计算折扣后的价格**。

#### **4. SELECT INTO（查询结果存入变量）**
- `SELECT ... INTO` 用于**将查询结果存入变量**，可以存入 `DECLARE` 变量或 `OUT` 参数。
- 适用于查询单个值（例如总数、最大值等）。

**示例**
```sql
DELIMITER $$

CREATE PROCEDURE GetMaxSalary(OUT max_salary DECIMAL(10,2))
BEGIN
    SELECT MAX(salary) INTO max_salary FROM employees;
END $$

DELIMITER ;
```
**调用存储过程**
```sql
CALL GetMaxSalary(@highest_salary);
SELECT @highest_salary;
```
> `SELECT MAX(salary) INTO max_salary FROM employees;` **将查询结果存入 `max_salary` 变量**。

#### **总结**
| 语法 | 用途 | 示例 |
|------|------|------|
| `BEGIN ... END` | 包含多条 SQL 语句 | `BEGIN DECLARE total INT; SELECT COUNT(*) INTO total FROM users; END` |
| `DECLARE` | 声明变量（只能在 `BEGIN` 内部） | `DECLARE total_users INT;` |
| `SET` | 赋值给变量 | `SET total_users = 100;` |
| `SELECT ... INTO` | 查询结果存入变量 | `SELECT COUNT(*) INTO total FROM users;` |

---

### DELIMITER 作用
在 MySQL 中，**默认的 SQL 语句结束符号是 `;`**，但在创建存储过程时，我们需要在 `BEGIN...END` 代码块内使用 `;` 结束多条 SQL 语句。**如果不更改默认的 `;` 结束符，MySQL 可能会错误地解析 `BEGIN...END` 块中的 `;`，导致存储过程创建失败。**

#### **1. `DELIMITER` 作用**
- `DELIMITER` 允许我们**修改 SQL 语句的结束标记**，以避免存储过程内部的 `;` 造成解析冲突。
- 通常在定义存储过程之前，我们使用 `DELIMITER $$` 或 `DELIMITER //` 改变默认的结束符号。
- **在存储过程定义完成后，我们使用 `DELIMITER ;` 恢复默认的 `;` 结束符**，以便后续 SQL 语句可以正常执行。

#### **2. `DELIMITER` 示例**
##### **示例 1：使用 `DELIMITER $$`**
```sql
DELIMITER $$  -- 设置新的结束符 $$，避免与 SQL 语句中的 ; 冲突

CREATE PROCEDURE GetAllUsers()
BEGIN
    SELECT * FROM users;  -- 这里的 ; 不会结束整个存储过程
END $$  -- 存储过程结束，使用 $$ 作为新的结束符

DELIMITER ;  -- 还原默认的分号 ;
```
**调用存储过程**
```sql
CALL GetAllUsers();
```
✅ **解析**
- `DELIMITER $$`：将 `$$` 作为新结束符，存储过程内的 `;` 仅用于结束 SQL 语句，而不会终止存储过程定义。
- `END $$`：表示存储过程的结束。
- `DELIMITER ;`：恢复默认的 `;` 结束符。

##### **示例 2：使用 `DELIMITER //`**
有时候，也可以使用 `//` 作为结束符：
```sql
DELIMITER //

CREATE PROCEDURE GetUserCount()
BEGIN
    DECLARE total_users INT;
    
    SELECT COUNT(*) INTO total_users FROM users;
    
    SELECT total_users AS TotalUsers;
END //  -- 存储过程结束

DELIMITER ;  -- 恢复默认的 ;
```
**调用存储过程**
```sql
CALL GetUserCount();
```
✅ **解析**
- 这里 `//` 被用作结束符，避免存储过程内部的 `;` 造成解析错误。

#### **3. `DELIMITER` 的注意事项**
1. **不能使用 `\` 作为 `DELIMITER`**
   - **`DELIMITER \` 是错误的**，因为 `\` 在 MySQL 中是**转义字符**。
   - **正确做法**：使用 `$$`、`//` 或 `@@` 等符号。

2. **存储过程定义完成后，应恢复默认的 `;`**
   - 这样可以在 MySQL 命令行中正常执行其他 SQL 语句，否则 `;` 可能无法正确解析。

#### **4. 总结**
| `DELIMITER` 语法 | 作用 |
|------------------|------|
| `DELIMITER $$` | 将 `$$` 作为新的结束符，避免 `;` 解析冲突 |
| `DELIMITER //` | 也可以使用 `//` 作为结束符 |
| `DELIMITER ;` | 恢复默认的 `;` 作为 SQL 语句结束符 |

---

### `characteristics` 參數的使用
在 MySQL 中，存储过程是一组预编译的 SQL 语句，可以多次执行。创建存储过程时，你可以使用多个选项来定义它的行为。我们来详细解析这些选项，并提供示例帮助你理解。

#### **存储过程基本语法**
```sql
LANGUAGE SQL
[NOT] DETERMINISTIC
[CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA]
SQL SECURITY { DEFINER | INVOKER }
COMMENT '存储过程描述'
```

#### **1. `LANGUAGE SQL`**
这个选项目前只能是 `SQL`，表示存储过程使用 SQL 语言编写（MySQL 仅支持 SQL 语法）。

**示例**
```sql
CREATE PROCEDURE get_server_time()
LANGUAGE SQL
BEGIN
    SELECT NOW() AS current_time;
END;
```
**解释**
- 这个存储过程 `get_server_time` 只是简单返回当前时间。
- 由于 MySQL 仅支持 `LANGUAGE SQL`，所以这里必须加上这个选项（但通常会被省略）。

#### **2. `[NOT] DETERMINISTIC`**
**解释**
- `DETERMINISTIC`：相同的输入参数总会返回相同的输出结果。例如，`SQRT(4)` 总是 `2`。
- `NOT DETERMINISTIC`（默认）：相同输入可能会返回不同的结果，例如 `NOW()` 每次调用返回的值都不同。

**示例 1：DETERMINISTIC**
```sql
CREATE PROCEDURE get_square(IN num INT, OUT result INT)
DETERMINISTIC
BEGIN
    SET result = num * num;
END;
```
**解释**
- `get_square` 存储过程接收一个 `num` 作为输入，并返回它的平方。
- 每次给定相同的 `num`，返回的 `result` 都相同，所以是 `DETERMINISTIC`。

**示例 2：NOT DETERMINISTIC**
```sql
CREATE PROCEDURE get_random_number(OUT rand_num INT)
NOT DETERMINISTIC
BEGIN
    SET rand_num = FLOOR(RAND() * 100);
END;
```
**解释**
- `get_random_number` 生成 0~99 之间的随机整数。
- `RAND()` 每次执行都会产生不同的结果，因此存储过程的输出不确定，需要标记为 `NOT DETERMINISTIC`。

#### **3. `{ CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA }`**
**解释**
- `CONTAINS SQL`（默认）：存储过程包含 SQL 语句，但不会读写数据库。
- `NO SQL`：存储过程不包含 SQL 语句。
- `READS SQL DATA`：存储过程会查询数据库但不会修改数据（只能 `SELECT`）。
- `MODIFIES SQL DATA`：存储过程会修改数据库数据（执行 `INSERT`、`UPDATE`、`DELETE`）。

**示例 1：CONTAINS SQL**
```sql
CREATE PROCEDURE show_message()
CONTAINS SQL
BEGIN
    DECLARE msg VARCHAR(100);
    SET msg = 'Hello, MySQL!';
    SELECT msg;
END;
```
**解释**
- `show_message` 只是定义了一个变量并返回它，不涉及数据库查询或修改，因此 `CONTAINS SQL`。

**示例 2：READS SQL DATA**
```sql
CREATE PROCEDURE get_employee(IN emp_id INT)
READS SQL DATA
BEGIN
    SELECT * FROM employees WHERE id = emp_id;
END;
```
**解释**
- `get_employee` 只是查询数据库 `employees` 表，但没有修改数据，因此标记为 `READS SQL DATA`。

**示例 3：MODIFIES SQL DATA**
```sql
CREATE PROCEDURE update_salary(IN emp_id INT, IN new_salary DECIMAL(10,2))
MODIFIES SQL DATA
BEGIN
    UPDATE employees SET salary = new_salary WHERE id = emp_id;
END;
```
**解释**
- 这个存储过程 `update_salary` 修改 `employees` 表的数据，因此使用 `MODIFIES SQL DATA`。

#### **4. `SQL SECURITY { DEFINER | INVOKER }`**
**解释**
- `DEFINER`（默认）：只有存储过程的创建者（定义者）可以执行。
- `INVOKER`：任何有权限调用存储过程的用户都可以执行。

**示例 1：使用 `DEFINER`**
```sql
CREATE PROCEDURE delete_employee(IN emp_id INT)
SQL SECURITY DEFINER
BEGIN
    DELETE FROM employees WHERE id = emp_id;
END;
```
**解释**
- 只有创建该存储过程的用户（`DEFINER`）才能执行 `delete_employee`。

**示例 2：使用 `INVOKER`**
```sql
CREATE PROCEDURE get_department_info(IN dept_id INT)
SQL SECURITY INVOKER
BEGIN
    SELECT * FROM departments WHERE id = dept_id;
END;
```
**解释**
- 任何有访问 `departments` 表权限的用户都可以执行 `get_department_info`，而不仅仅是创建者。

#### **5. `COMMENT 'string'`**
**解释**
- `COMMENT` 选项用于存储过程的说明，可帮助开发者理解存储过程的用途。

**示例**
```sql
CREATE PROCEDURE calculate_bonus(IN salary DECIMAL(10,2), OUT bonus DECIMAL(10,2))
COMMENT '计算奖金：奖金是工资的10%'
BEGIN
    SET bonus = salary * 0.1;
END;
```
**解释**
- `COMMENT '计算奖金：奖金是工资的10%'` 说明了存储过程的作用。

#### **完整示例**
```sql
DELIMITER //
CREATE PROCEDURE get_user_info(IN user_id INT)
LANGUAGE SQL
NOT DETERMINISTIC
READS SQL DATA
SQL SECURITY INVOKER
COMMENT '根据用户ID获取用户信息'
BEGIN
    SELECT * FROM users WHERE id = user_id;
END //
DELIMITER ;
```
**解释**
- `NOT DETERMINISTIC`：查询用户信息的结果可能随着数据库的变化而不同。
- `READS SQL DATA`：存储过程读取数据但不修改。
- `SQL SECURITY INVOKER`：任何有权限的用户都可以调用它。
- `COMMENT`：存储过程描述。

#### **总结**
| 选项 | 作用 |
|------|------|
| `LANGUAGE SQL` | 目前 MySQL 仅支持 SQL 语言 |
| `[NOT] DETERMINISTIC` | 是否保证相同输入返回相同结果 |
| `CONTAINS SQL` | 包含 SQL 但不操作数据库 |
| `NO SQL` | 不包含 SQL 语句 |
| `READS SQL DATA` | 仅读取数据库数据 |
| `MODIFIES SQL DATA` | 修改数据库数据 |
| `SQL SECURITY DEFINER` | 只有定义者可以执行 |
| `SQL SECURITY INVOKER` | 任何有权限的用户都可以执行 |
| `COMMENT 'string'` | 添加存储过程的注释 |

---

## 2.2 代码举例

举例1：创建存储过程 `select_all_data()`，查看 emps 表的所有数据

```sql
DELIMITER $

CREATE PROCEDURE select_all_data()
BEGIN
	SELECT * FROM emps;
	
END $

DELIMITER ;
```

举例2：创建存储过程 `avg_employee_salary()`，返回所有员工的平均工资

```sql
DELIMITER //

CREATE PROCEDURE avg_employee_salary ()
BEGIN
	SELECT AVG(salary) AS avg_salary FROM emps;
END //

DELIMITER ;
```

举例3：创建存储过程 `show_max_salary()`，用来查看“emps”表的最高薪资值。

```sql
DELIMITER //
CREATE PROCEDURE show_max_salary()
	LANGUAGE SQL
	NOT DETERMINISTIC
	CONTAINS SQL
	SQL SECURITY DEFINER
	COMMENT '查看最高薪资'
	BEGIN
		SELECT MAX(salary) FROM emps;
	END //

DELIMITER ;
```

举例4：创建存储过程 `show_min_salary()`，查看“emps”表的最低薪资值。并将最低薪资通过OUT参数“ms”输出

```sql
DELIMITER //

CREATE PROCEDURE show_min_salary(OUT ms DOUBLE)
	BEGIN
		SELECT MIN(salary) INTO ms FROM emps;
	END //

DELIMITER ;
```

举例5：创建存储过程 `show_someone_salary()`，查看“emps”表的某个员工的薪资，并用IN参数empname输入员工姓名。

```sql
DELIMITER //

CREATE PROCEDURE show_someone_salary(IN empname VARCHAR(20))
	BEGIN
		SELECT salary FROM emps WHERE ename = empname;
	END //

DELIMITER ;
```

举例6：创建存储过程 `show_someone_salary2()`，查看“emps”表的某个员工的薪资，并用IN参数empname输入员工姓名，用OUT参数empsalary输出员工薪资。

```sql
DELIMITER //

CREATE PROCEDURE show_someone_salary2(IN empname VARCHAR(20),OUT empsalary DOUBLE)
	BEGIN
		SELECT salary INTO empsalary FROM emps WHERE ename = empname;
	END //

DELIMITER ;
```

举例7：创建存储过程 `show_mgr_name()`，查询某个员工领导的姓名，并用INOUT参数“empname”输入员工姓名，输出领导的姓名。

```sql
DELIMITER //

CREATE PROCEDURE show_mgr_name(INOUT empname VARCHAR(20))
	BEGIN
		SELECT ename INTO empname FROM emps
		WHERE eid = (SELECT MID FROM emps WHERE ename=empname);
	END //

DELIMITER ;
```

# 3. 调用存储过程

## 3.1 调用格式

存储过程有多种调用方法。存储过程必须使用CALL语句调用，并且存储过程和数据库相关，如果要执行其他数据库中的存储过程，需要指定数据库名称，例如 `CALL dbname.procname`。

```sql
CALL 存储过程名(实参列表)
```

其中，存储过程的参数可以有三种模式：
- **IN（輸入參數）**：作為輸入傳遞給存儲過程，存儲過程內部可以使用但無法修改。
- **OUT（輸出參數）**：存儲過程內部修改後，返回給外部變數。
- **INOUT（輸入輸出參數）**：既可以作為輸入傳入，也可以作為輸出返回。

**格式：**

1、调用in模式的参数：

```sql
CALL sp1('值');
```

2、调用out模式的参数：

```sql
SET @name;
CALL sp1(@name);
SELECT @name;
```

3、调用inout模式的参数：

```sql
SET @name=值;
CALL sp1(@name);
SELECT @name;
```

## 3.2 代码举例
### **範例**
假設我們有一個數據庫 `testdb`，並在其中建立一個 `users` 表：

```sql
CREATE DATABASE testdb;
USE testdb;

CREATE TABLE users (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(50),
    age INT
);

INSERT INTO users (name, age) VALUES ('Alice', 25), ('Bob', 30), ('Charlie', 28);
```

#### **1. 調用 `IN` 模式的存儲過程**
**IN 模式**的參數是作為輸入傳遞給存儲過程的，存儲過程內部只能讀取，不能改變。

**建立存儲過程**
```sql
DELIMITER //

CREATE PROCEDURE GetUserByName(IN user_name VARCHAR(50))
BEGIN
    SELECT * FROM users WHERE name = user_name;
END //

DELIMITER ;
```

**調用存儲過程**
```sql
CALL GetUserByName('Alice');
```
這將返回 **name='Alice'** 的用戶資訊。

#### **2. 調用 `OUT` 模式的存儲過程**
**OUT 模式**的參數用於從存儲過程返回結果。

**建立存儲過程**
```sql
DELIMITER //

CREATE PROCEDURE GetUserAge(IN user_name VARCHAR(50), OUT user_age INT)
BEGIN
    SELECT age INTO user_age FROM users WHERE name = user_name;
END //

DELIMITER ;
```

**調用存儲過程**
```sql
SET @age = 0;
CALL GetUserAge('Bob', @age);
SELECT @age;
```
這將返回 **Bob 的年齡**，例如 `@age = 30`。

#### **3. 調用 `INOUT` 模式的存儲過程**
**INOUT 模式**的參數既可以作為輸入，也可以作為輸出。

**建立存儲過程**
```sql
DELIMITER //

CREATE PROCEDURE DoubleAge(INOUT user_age INT)
BEGIN
    SET user_age = user_age * 2;
END //

DELIMITER ;
```

**調用存儲過程**
```sql
SET @age = 25;
CALL DoubleAge(@age);
SELECT @age;
```
這將返回 **50**（`25 * 2`）。

### **總結**
| 模式 | 說明 | 調用方式 |
|------|------|----------|
| IN | 輸入參數，只能讀取，無法更改 | `CALL sp1('值')` |
| OUT | 存儲過程內部修改並返回結果 | `SET @var; CALL sp1(@var); SELECT @var;` |
| INOUT | 可讀可寫，存儲過程內部可以修改並返回 | `SET @var=值; CALL sp1(@var); SELECT @var;` |

這些方法適用於不同的應用場景，例如：
- **IN 模式**：查詢數據，如根據用戶名獲取用戶信息。
- **OUT 模式**：計算結果返回，如獲取某個用戶的年齡。
- **INOUT 模式**：改變變數值，如計算兩倍的年齡。

---

## 3.3 如何调试

在 MySQL 中，存储过程不像普通的编程语言（比如 VC++、Java 等）那样有专门的集成开发环境。因此，你可以通过 SELECT 语句，把程序执行的中间结果查询出来，来调试一个 SQL 语句的正确性。调试成功之后，把 SELECT 语句后移到下一个 SQL 语句之后，再调试下一个 SQL 语句。这样`逐步推进`，就可以完成对存储过程中所有操作的调试了。当然，你也可以把存储过程中的 SQL 语句复制出来，逐段单独调试。

# 4. 存储函数的使用

前面学习了很多函数，使用这些函数可以对数据进行的各种处理操作，极大地提高用户对数据库的管理效率。MySQL支持自定义函数，定义好之后，调用方式与调用MySQL预定义的系统函数一样。

## 4.1 语法分析
存储函数（Stored Function）是 MySQL 中的一种数据库对象，类似于编程语言中的函数，它可以接受参数，并返回一个计算结果。

### 语法解析
```sql
CREATE FUNCTION 函数名(参数名 参数类型,...) 
RETURNS 返回值类型
[characteristics ...]
BEGIN
	函数体   -- 函数体中必须有 RETURN 语句
END;
```

#### 关键点：
1. **参数列表**：
   - 存储函数的参数总是**默认为 `IN`**（输入参数），不需要显式声明 `IN`。
   - `OUT` 和 `INOUT` 只能用于存储过程（`PROCEDURE`），而不能用于存储函数（`FUNCTION`）。

2. **RETURNS 语句**：
   - `RETURNS type` **强制要求** 指定返回值的类型，例如 `INT`、`VARCHAR(100)`、`DECIMAL(10,2)`。
   - 函数体必须使用 `RETURN value` **返回计算结果**。

3. **characteristics（可选约束）**：
   - 这里通常包括 `DETERMINISTIC`（确定性） 或 `NO SQL`（不涉及 SQL 操作）等特性。
   - **取值与创建存储过程时相同，这里不再赘述。**

4. **函数体（`BEGIN...END` 块）**：
   - 如果函数体 **只有一条 SQL 语句**，可以省略 `BEGIN...END`。
   - 否则，多个 SQL 语句需要用 `BEGIN...END` 包围，并且每条语句需要使用 `;` 结尾。

### **示例 1：计算两个数的和**
我们创建一个名为 `sum_two_numbers` 的存储函数，该函数接收两个整数，并返回它们的和。

```sql
DELIMITER $$  -- 更改语句分隔符，避免与 RETURN 语句冲突

CREATE FUNCTION sum_two_numbers(a INT, b INT) 
RETURNS INT
DETERMINISTIC
BEGIN
    RETURN a + b;  -- 计算两个数的和并返回
END $$

DELIMITER ;  -- 恢复默认分隔符
```
#### **调用该函数**
```sql
SELECT sum_two_numbers(10, 20);  -- 结果：30
```

### **示例 2：返回员工的全名**
假设有一个 `employees` 表：
```sql
CREATE TABLE employees (
    id INT PRIMARY KEY AUTO_INCREMENT,
    first_name VARCHAR(50),
    last_name VARCHAR(50)
);
```
我们创建一个存储函数 `get_full_name`，用于返回员工的全名。

```sql
DELIMITER $$

CREATE FUNCTION get_full_name(emp_id INT) 
RETURNS VARCHAR(100)
DETERMINISTIC
BEGIN
    DECLARE full_name VARCHAR(100);
    -- 拼接姓和名
    SELECT CONCAT(first_name, ' ', last_name) INTO full_name 
    FROM employees WHERE id = emp_id;
    
    RETURN full_name;
END $$

DELIMITER ;
```
#### **调用该函数**
```sql
SELECT get_full_name(1);  -- 可能返回 "John Doe"
```

### **示例 3：计算商品折扣后的价格**
假设有一个 `products` 表：
```sql
CREATE TABLE products (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(100),
    price DECIMAL(10,2)
);
```
我们创建一个存储函数 `get_discounted_price`，计算打折后的价格。

```sql
DELIMITER $$

CREATE FUNCTION get_discounted_price(product_id INT, discount DECIMAL(5,2))
RETURNS DECIMAL(10,2)
DETERMINISTIC
BEGIN
    DECLARE original_price DECIMAL(10,2);
    DECLARE discounted_price DECIMAL(10,2);

    -- 获取原价
    SELECT price INTO original_price FROM products WHERE id = product_id;

    -- 计算折扣价
    SET discounted_price = original_price * (1 - discount / 100);

    RETURN discounted_price;
END $$

DELIMITER ;
```
#### **调用该函数**
```sql
SELECT get_discounted_price(1, 10);  -- 商品 ID 为 1，打 90 折
```

### **注意事项**
1. **创建函数需要 `CREATE ROUTINE` 权限**
   - 如果没有 `CREATE FUNCTION` 权限，需要数据库管理员 (`root`) 授权：
   ```sql
   GRANT CREATE ROUTINE ON database_name.* TO 'your_user'@'localhost';
   ```

2. **使用 `DETERMINISTIC`**
   - 如果函数不会修改数据库，可以使用 `DETERMINISTIC`（确定性）。
   - 否则，MySQL 需要 `CONTAINS SQL` 或 `READS SQL DATA` 来标明该函数是否涉及 SQL 读写。

3. **删除存储函数**
   - 如果要删除存储函数：
   ```sql
   DROP FUNCTION IF EXISTS sum_two_numbers;
   ```

### **总结**
- **存储函数** 在 MySQL 中用于封装逻辑，使 SQL 查询更简洁。
- 语法结构：
  - 需要 `CREATE FUNCTION` 语句。
  - `RETURNS` 指定返回值类型，函数体必须包含 `RETURN` 语句。
  - 允许使用 `BEGIN...END` 组织多个 SQL 语句。
- **应用场景**
  - 计算数值（如求和、折扣计算）。
  - 处理字符串（如获取全名）。
  - 查询和返回特定值（如查找某个 ID 对应的信息）。

---

## 4.2 调用存储函数

在MySQL中，存储函数的使用方法与MySQL内部函数的使用方法是一样的。换言之，用户自己定义的存储函数与MySQL内部函数是一个性质的。区别在于，存储函数是`用户自己定义`的，而内部函数是MySQL的`开发者定义`的。

```sql
SELECT 函数名(实参列表)
```

## 4.3 代码举例

**举例1：**

创建存储函数，名称为 `email_by_name()`，参数定义为空，该函数查询Abel的email，并返回，数据类型为字符串型。

```sql
DELIMITER //

CREATE FUNCTION email_by_name()
RETURNS VARCHAR(25)
DETERMINISTIC
CONTAINS SQL
BEGIN
	RETURN (SELECT email FROM employees WHERE last_name = 'Abel');
END //

DELIMITER ;
```

调用：

```sql
SELECT email_by_name();
```

**举例2：**

创建存储函数，名称为`email_by_id()`，参数传入emp_id，该函数查询emp_id的email，并返回，数据类型为字符串型。

```sql
DELIMITER //

CREATE FUNCTION email_by_id(emp_id INT)
RETURNS VARCHAR(25)
DETERMINISTIC
CONTAINS SQL
BEGIN
	RETURN (SELECT email FROM employees WHERE employee_id = emp_id);
END //

DELIMITER ;
```

调用：

```sql
SET @emp_id = 102;
SELECT email_by_id(102);
```

**举例3：**

创建存储函数`count_by_id()`，参数传入dept_id，该函数查询dept_id部门的员工人数，并返回，数据类型为整型。

```sql
DELIMITER //

CREATE FUNCTION count_by_id(dept_id INT)
RETURNS INT
	LANGUAGE SQL
	NOT DETERMINISTIC
	READS SQL DATA
	SQL SECURITY DEFINER
	COMMENT '查询部门平均工资'
BEGIN
	RETURN (SELECT COUNT(*) FROM employees WHERE department_id = dept_id);
	
END //

DELIMITER ;
```

调用：

```sql
SET @dept_id = 50;
SELECT count_by_id(@dept_id);
```

**注意：**

若在创建存储函数中报错“`you might want to use the less safe log_bin_trust_function_creators variable`”，有两种处理方法：

- 方式1：加上必要的函数特性“[NOT] DETERMINISTIC”和“{CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA}”


- 方式2：

	```sql
	SET GLOBAL log_bin_trust_function_creators = 1;
	```

## 4.4 对比存储函数和存储过程

|  **区别**  | **存储函数（Function）** | **存储过程（Procedure）** |
|------------|-------------------------|---------------------------|
| **是否必须返回值** | **必须返回** 一个值（`RETURN`） | **不一定返回值**，可使用 `OUT` 参数返回多个值 |
| **返回值类型** | `RETURNS type` 规定返回值类型，只能返回一个值 | `OUT` 参数可返回多个值，也可以 `SELECT` 查询数据 |
| **是否可以在 SQL 语句中使用** | **可以** 在 `SELECT`、`WHERE`、`ORDER BY` 等中使用 | **不能** 在 `SELECT` 语句中使用 |
| **参数类型** | 仅支持 `IN` 参数（输入参数） | 支持 `IN`、`OUT`、`INOUT` 参数 |
| **是否可以执行事务** | **不建议** 在函数内执行事务（`COMMIT`、`ROLLBACK`） | **可以** 进行事务控制 |
| **适用场景** | 适用于计算、数据转换、返回单个值（如求和、折扣计算） | 适用于执行复杂业务逻辑（如批量插入、更新、删除） |
| **调用方式** | 作为表达式在 `SELECT` 语句中调用 | 通过 `CALL` 语句执行 |

> **存储函数可以放在查询语句中使用，存储过程不行**。反之，存储过程的功能更加强大，包括能够执行对表的操作（比如创建表，删除表等）和事务操作，这些功能是存储函数不具备的。

# 5. 存储过程和函数的查看、修改、删除

## 5.1 查看

创建完之后，怎么知道我们创建的存储过程、存储函数是否成功了呢？

MySQL存储了存储过程和函数的状态信息，用户可以使用SHOW STATUS语句或SHOW CREATE语句来查看，也可直接从系统的information_schema数据库中查询。这里介绍3种方法。

### **方法 1：使用 `SHOW CREATE` 查看存儲過程/函數的詳細定義**
這個方法適用於 **查看存儲過程或函數的完整 SQL 創建語句**，類似於 `SHOW CREATE TABLE` 顯示表的結構。

#### **語法**
```sql
SHOW CREATE {PROCEDURE | FUNCTION} 存儲過程名或函數名;
```

#### **示例**
假設我們有一個存儲函數 `count_orders_by_user`，它用於計算某個用戶的訂單數量：
```sql
DELIMITER //
CREATE FUNCTION count_orders_by_user(user_id INT) RETURNS INT
DETERMINISTIC
BEGIN
    DECLARE order_count INT;
    SELECT COUNT(*) INTO order_count FROM orders WHERE user_id = user_id;
    RETURN order_count;
END //
DELIMITER ;
```
要查看這個函數的創建語句，我們可以執行：
```sql
SHOW CREATE FUNCTION count_orders_by_user \G
```

**輸出範例**
```
*************************** 1. row ***************************
           Function: count_orders_by_user
            sql_mode: 
    Create Function: CREATE FUNCTION `count_orders_by_user`(user_id INT) RETURNS INT
                      DETERMINISTIC
                      BEGIN
                          DECLARE order_count INT;
                          SELECT COUNT(*) INTO order_count FROM orders WHERE user_id = user_id;
                          RETURN order_count;
                      END
1 row in set (0.00 sec)
```
這樣我們就能確認該函數是否正確存在，並查看其完整定義。

---

### **方法 2：使用 `SHOW STATUS` 查看存儲過程/函數的狀態信息**
這種方法適用於 **快速獲取存儲過程或函數的基本信息，如名稱、類型、創建時間、修改時間等**。

#### **語法**
```sql
SHOW {PROCEDURE | FUNCTION} STATUS [LIKE '名稱匹配模式'];
```

#### **示例**
我們要查找名為 `count_orders_by_user` 的函數：
```sql
SHOW FUNCTION STATUS LIKE 'count_orders_by_user' \G
```

**輸出範例**
```
*************************** 1. row ***************************
                  Db: test_db
                Name: count_orders_by_user
                Type: FUNCTION
             Definer: root@localhost
            Modified: 2025-03-10 10:00:00
             Created: 2025-03-10 09:45:00
       Security_type: DEFINER
             Comment: 
character_set_client: utf8mb4
collation_connection: utf8mb4_general_ci
  Database Collation: utf8mb4_general_ci
1 row in set (0.00 sec)
```
這裡顯示：
- **Db**：該函數屬於 `test_db` 數據庫
- **Name**：函數名稱是 `count_orders_by_user`
- **Type**：它是 **FUNCTION**
- **Created / Modified**：創建和最後修改的時間
- **Definer**：創建該函數的用戶（如 `root@localhost`）

如果想要查詢所有函數，可以省略 `LIKE`：
```sql
SHOW FUNCTION STATUS;
```

如果想查詢存儲過程：
```sql
SHOW PROCEDURE STATUS LIKE '某個存儲過程名稱';
```

### **方法 3：從 `information_schema.Routines` 查詢詳細信息**
這種方法適用於 **從 MySQL 系統表查詢存儲過程和函數的詳細信息**，類似於 `SHOW STATUS`，但可以進行更靈活的查詢。

#### **語法**
```sql
SELECT * FROM information_schema.Routines
WHERE ROUTINE_NAME='存儲過程或函數的名稱'
[AND ROUTINE_TYPE = 'PROCEDURE' | 'FUNCTION'];
```

#### **示例**
我們要查詢 `count_orders_by_user` 這個函數的詳細信息：
```sql
SELECT * FROM information_schema.Routines
WHERE ROUTINE_NAME = 'count_orders_by_user'
AND ROUTINE_TYPE = 'FUNCTION' \G
```

**輸出範例**
```
*************************** 1. row ***************************
           SPECIFIC_NAME: count_orders_by_user
             ROUTINE_NAME: count_orders_by_user
             ROUTINE_TYPE: FUNCTION
                 DB_NAME: test_db
           CREATED: 2025-03-10 09:45:00
           LAST_ALTERED: 2025-03-10 10:00:00
       SECURITY_TYPE: DEFINER
       ROUTINE_SCHEMA: test_db
       ROUTINE_BODY: SQL
       ROUTINE_DEFINITION: BEGIN
                          DECLARE order_count INT;
                          SELECT COUNT(*) INTO order_count FROM orders WHERE user_id = user_id;
                          RETURN order_count;
                      END
       CHARACTER_SET_CLIENT: utf8mb4
1 row in set (0.00 sec)
```
這裡能夠查到：
- **ROUTINE_NAME**：存儲函數名稱
- **ROUTINE_TYPE**：存儲類型（FUNCTION）
- **DB_NAME**：所屬數據庫
- **CREATED / LAST_ALTERED**：創建和修改時間
- **ROUTINE_DEFINITION**：函數的完整 SQL 定義

如果想查詢所有存儲過程：
```sql
SELECT * FROM information_schema.Routines WHERE ROUTINE_TYPE = 'PROCEDURE';
```

如果想查詢所有存儲函數：
```sql
SELECT * FROM information_schema.Routines WHERE ROUTINE_TYPE = 'FUNCTION';
```

### **總結**
| 方法 | 作用 | 適用場景 | 查詢範例 |
|------|------|----------|-----------|
| `SHOW CREATE PROCEDURE/FUNCTION` | 顯示存儲過程或函數的完整創建語句 | 想查看完整 SQL 定義時 | `SHOW CREATE FUNCTION count_orders_by_user \G` |
| `SHOW PROCEDURE/FUNCTION STATUS` | 查詢存儲過程或函數的基本狀態，如名稱、類型、創建時間 | 快速獲取基本信息 | `SHOW FUNCTION STATUS LIKE 'count_orders_by_user' \G` |
| 查詢 `information_schema.Routines` | 查詢更詳細的信息，可搭配條件查詢 | 需要靈活查詢存儲過程/函數的詳細信息時 | `SELECT * FROM information_schema.Routines WHERE ROUTINE_NAME='count_orders_by_user' AND ROUTINE_TYPE = 'FUNCTION' \G` |

---

## 5.2 修改

修改存储过程或函数，不影响存储过程或函数功能，只是修改相关特性。使用ALTER语句实现。

```sql
ALTER {PROCEDURE | FUNCTION} 存储过程或函数的名 [characteristic ...]
```

其中，characteristic指定存储过程或函数的特性，其取值信息与创建存储过程、函数时的取值信息略有不同。

```sql
{ CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA }
| SQL SECURITY { DEFINER | INVOKER }
| COMMENT 'string'
```

- `CONTAINS SQL`，表示子程序包含SQL语句，但不包含读或写数据的语句。
- `NO SQL`，表示子程序中不包含SQL语句。
- `READS SQL DATA`，表示子程序中包含读数据的语句。
- `MODIFIES SQL DATA`，表示子程序中包含写数据的语句。
- `SQL SECURITY { DEFINER | INVOKER }`，指明谁有权限来执行。
  - `DEFINER`，表示只有定义者自己才能够执行。
  - `INVOKER`，表示调用者可以执行。
- `COMMENT 'string'`，表示注释信息。

> 修改存储过程使用ALTER PROCEDURE语句，修改存储函数使用ALTER FUNCTION语句。但是，这两个语句的结构是一样的，语句中的所有参数也是一样的。



**举例1：**

修改存储过程CountProc的定义。将读写权限改为MODIFIES SQL DATA，并指明调用者可以执行，代码如下：

```sql
ALTER　PROCEDURE　CountProc
MODIFIES SQL DATA
SQL SECURITY INVOKER ;
```

查询修改后的信息：

```sql
SELECT specific_name,sql_data_access,security_type
FROM information_schema.`ROUTINES`
WHERE routine_name = 'CountProc' AND routine_type = 'PROCEDURE';
```

结果显示，存储过程修改成功。从查询的结果可以看出，访问数据的权限（SQL_DATA_ ACCESS）已经变成MODIFIES SQL DATA，安全类型（SECURITY_TYPE）已经变成INVOKER。

**举例2：**

修改存储函数CountProc的定义。将读写权限改为READS SQL DATA，并加上注释信息“FIND NAME”，代码如下：

```sql
ALTER　FUNCTION　CountProc
READS SQL DATA
COMMENT 'FIND NAME' ;
```

存储函数修改成功。从查询的结果可以看出，访问数据的权限（SQL_DATA_ACCESS）已经变成READS SQL DATA，函数注释（ROUTINE_COMMENT）已经变成FIND NAME。

## 5.3 删除

删除存储过程和函数，可以使用DROP语句，其语法结构如下：

```sql
DROP {PROCEDURE | FUNCTION} [IF EXISTS] 存储过程或函数的名
```

IF EXISTS：如果程序或函数不存储，它可以防止发生错误，产生一个用SHOW WARNINGS查看的警告。

举例：

```sql
DROP PROCEDURE CountProc;
```

```sql
DROP FUNCTION CountProc;
```

# 6. 关于存储过程使用的争议

尽管存储过程有诸多优点，但是对于存储过程的使用，**一直都存在着很多争议**，比如有些公司对于大型项目要求使用存储过程，而有些公司在手册中明确禁止使用存储过程，为什么这些公司对存储过程的使用需求差别这么大呢？

## 6.1 📌 **存储过程的优点**

### 1️⃣ **存储过程可以一次编译多次使用，提高执行效率**
存储过程在创建时编译，之后调用时不需要再编译，因此比普通 SQL 语句执行更快。

**示例：**
```sql
DELIMITER //
CREATE PROCEDURE GetUserCount()
BEGIN
    SELECT COUNT(*) FROM users;
END //
DELIMITER ;
```
上面这个存储过程 `GetUserCount` 计算 `users` 表中的用户数。它在创建时编译，之后只需调用：
```sql
CALL GetUserCount();
```
这样就避免了每次都重新编译 `SELECT COUNT(*) FROM users;`。

### 2️⃣ **减少开发工作量，提高代码复用性**
存储过程可以封装业务逻辑，使得代码结构清晰，并且可以被多个应用调用。

**示例：**
```sql
DELIMITER //
CREATE PROCEDURE InsertUser(IN userName VARCHAR(50), IN userEmail VARCHAR(100))
BEGIN
    INSERT INTO users (name, email) VALUES (userName, userEmail);
END //
DELIMITER ;
```
调用时：
```sql
CALL InsertUser('Alice', 'alice@example.com');
```
这样，在多个地方需要插入用户时，直接调用 `InsertUser` 存储过程，而不需要每次写 `INSERT INTO` 语句。

### 3️⃣ **安全性强**
存储过程可以通过数据库的权限控制，让某些用户只能 **调用存储过程**，但无法 **直接访问数据库表**，这样可以提高数据的安全性。

#### **📌 为什么存储过程的安全性更强？**
通常，如果用户可以直接访问表，他们可以执行如下操作：
```sql
SELECT * FROM users;  -- 查询所有用户信息
INSERT INTO users (name, email) VALUES ('Alice', 'alice@example.com'); -- 插入数据
UPDATE users SET email = 'alice_new@example.com' WHERE name = 'Alice'; -- 修改数据
DELETE FROM users WHERE name = 'Alice'; -- 删除数据
```
但在某些情况下，你 **不希望用户直接访问表**，因为：
1. **数据泄露风险**：用户可能查询到 **所有用户的信息**，导致数据泄露。
2. **误操作风险**：用户可能 **不小心修改或删除数据**，导致数据丢失。
3. **权限控制困难**：即使使用 `GRANT SELECT`，用户仍然可以写复杂 SQL 查询，可能导致 **性能问题** 或 **间接获取敏感数据**。

存储过程提供了一种更 **安全** 的方式：
- 让用户 **只能执行存储过程**，但 **无法直接访问表**。
- 在存储过程中 **只允许执行特定操作**，防止用户随意查询、更新、删除数据。

#### **🔍 示例：如何使用存储过程增强安全性？**
##### **❌ 用户可以直接访问表（不安全）**
假设 `users` 表包含如下数据：
```sql
CREATE TABLE users (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(50),
    email VARCHAR(100)
);
```
如果你允许某个普通用户 `limited_user` 直接访问 `users` 表：
```sql
GRANT SELECT, INSERT, UPDATE, DELETE ON users TO 'limited_user'@'%';
```
那么 `limited_user` 可以随意执行：
```sql
SELECT * FROM users; -- 可能泄露所有用户信息
DELETE FROM users WHERE id = 1; -- 可能误删重要数据
```
这显然 **不安全** 🚨

##### **✅ 使用存储过程来控制权限**
**第一步**：创建存储过程 `InsertUser`
```sql
DELIMITER //
CREATE PROCEDURE InsertUser(IN userName VARCHAR(50), IN userEmail VARCHAR(100))
BEGIN
    INSERT INTO users (name, email) VALUES (userName, userEmail);
END //
DELIMITER ;
```
这个存储过程只允许 **添加用户**，但 **不允许删除或修改用户**。

**第二步**：只给 `limited_user` **执行存储过程的权限**，而不给 `users` 表的权限
```sql
GRANT EXECUTE ON PROCEDURE InsertUser TO 'limited_user'@'%';
```
此时 `limited_user`：
✅ **可以执行存储过程**：
```sql
CALL InsertUser('Alice', 'alice@example.com');
```
❌ **不能直接操作表**：
```sql
SELECT * FROM users;  -- ❌ 权限被拒绝
DELETE FROM users WHERE id = 1;  -- ❌ 权限被拒绝
```
这样，`limited_user` **只能插入数据**，但无法查询或删除数据，提升了安全性。

#### **🔑 为什么这种方式更安全？**
1. **用户无法随意查询数据** 👉 防止数据泄露
2. **用户无法误删或修改数据** 👉 避免误操作
3. **数据库管理员可以控制哪些操作允许用户执行** 👉 精细化权限管理

这样，即使数据库被黑客攻击，或者有内部用户误操作，他们 **无法直接接触数据**，只能够通过 **预定义的存储过程** 进行操作，极大地提高了数据库的安全性。🎯

### 4️⃣ **减少网络传输量**
客户端只需发送 `CALL` 语句，减少了 SQL 语句的长度，降低网络负载。

例如，多个查询：
```sql
SELECT COUNT(*) FROM users;
SELECT COUNT(*) FROM orders;
SELECT COUNT(*) FROM products;
```
可以封装成存储过程：
```sql
DELIMITER //
CREATE PROCEDURE GetCounts()
BEGIN
    SELECT (SELECT COUNT(*) FROM users) AS user_count,
           (SELECT COUNT(*) FROM orders) AS order_count,
           (SELECT COUNT(*) FROM products) AS product_count;
END //
DELIMITER ;
```
然后只需执行：
```sql
CALL GetCounts();
```
这样，客户端只发送 `CALL GetCounts();`，而不是 3 条 `SELECT` 语句，减少了网络流量。

### 5️⃣ **存储过程的封装性**
存储过程的 **封装性** 指的是：  
✅ 可以将多条 SQL 语句封装到 **一个存储过程** 里，像一个“函数”一样调用它。  
✅ 这样 **客户端只需执行一次存储过程**，而不需要 **多次连接数据库** 执行多个 SQL 语句。  

这在 **复杂查询** 或 **多步操作** 时尤其重要，因为：
1. **减少数据库连接的次数**（每次连接数据库都会消耗资源）。
2. **降低 SQL 语句在网络中的传输量**（客户端只发送 `CALL` 命令）。
3. **提升代码的可读性和复用性**（业务逻辑封装成存储过程，避免重复 SQL 代码）。

#### **🔍 示例 1：未封装 vs 封装**
假设我们有一个电商网站，需要：
1. 查询某个用户的 ID
2. 统计该用户的订单数量
3. 计算该用户的总消费金额  

##### **🚨 未封装（多次连接数据库，不优化）**
如果我们 **不使用存储过程**，前端应用必须 **执行 3 次 SQL 查询**：
```sql
SELECT id FROM users WHERE name = 'Alice';  -- 获取用户 ID
SELECT COUNT(*) FROM orders WHERE user_id = 1;  -- 统计订单数
SELECT SUM(amount) FROM orders WHERE user_id = 1;  -- 计算总消费
```
这样：
- 每个 SQL 语句都 **需要单独连接数据库**。
- **网络请求增加**（3 次 SQL 语句，每次都要发送请求）。
- 代码重复，每次查询都要在应用层处理。

##### **✅ 使用存储过程封装（只需连接一次数据库）**
我们可以用 **存储过程** 封装这些 SQL 逻辑：
```sql
DELIMITER //
CREATE PROCEDURE GetUserOrderStats(IN userName VARCHAR(50), OUT orderCount INT, OUT totalAmount DECIMAL(10,2))
BEGIN
    DECLARE userId INT;
    
    -- 获取用户 ID
    SELECT id INTO userId FROM users WHERE name = userName;
    
    -- 统计订单数
    SELECT COUNT(*) INTO orderCount FROM orders WHERE user_id = userId;
    
    -- 计算总消费
    SELECT SUM(amount) INTO totalAmount FROM orders WHERE user_id = userId;
END //
DELIMITER ;
```
**调用存储过程（前端或应用层只需要发送一次 SQL 请求）：**
```sql
CALL GetUserOrderStats('Alice', @orderCount, @totalAmount);
SELECT @orderCount AS OrderCount, @totalAmount AS TotalSpent;
```
✅ **只连接一次数据库**，执行所有 SQL 逻辑！  
✅ **减少网络流量**，客户端只发送 `CALL GetUserOrderStats()`，不会发送 3 次 `SELECT` 语句！  
✅ **业务逻辑封装**，代码更清晰，可复用！  

#### **🔍 示例 2：批量插入数据**
如果我们要批量插入 1000 条订单记录，不使用存储过程时：
```sql
INSERT INTO orders (user_id, amount) VALUES (1, 100);
INSERT INTO orders (user_id, amount) VALUES (1, 200);
...
-- 1000 次 INSERT，每次都要连接数据库
```
这样：
- 每次 `INSERT` 都需要 **新建数据库连接**，造成性能开销！
- 网络要 **传输 1000 条 SQL 语句**，占用带宽。

**✅ 使用存储过程优化**
```sql
DELIMITER //
CREATE PROCEDURE InsertBulkOrders(IN userId INT)
BEGIN
    DECLARE i INT DEFAULT 1;
    WHILE i <= 1000 DO
        INSERT INTO orders (user_id, amount) VALUES (userId, FLOOR(RAND() * 500)); 
        SET i = i + 1;
    END WHILE;
END //
DELIMITER ;
```
**只需要调用一次存储过程！**
```sql
CALL InsertBulkOrders(1);
```
✅ **只连接一次数据库！**  
✅ **批量执行 1000 条 INSERT，减少数据库开销！**  
✅ **客户端只需发送 `CALL InsertBulkOrders(1)`，不需要发送 1000 条 SQL！**

#### **🔍 为什么封装性很重要？**
- **减少数据库连接次数**（每次连接都需要时间，减少连接可以提高性能）。
- **降低网络传输开销**（减少 SQL 语句在客户端和服务器之间的通信）。
- **提高可维护性**（封装业务逻辑，使代码更加清晰，可复用）。

#### **🎯 总结**
**✅ 使用存储过程封装多个 SQL 语句，只需连接一次数据库！**  
**✅ 适用于复杂查询、批量操作，提高数据库性能！**  
**✅ 适用于高并发系统，减少数据库压力！**  

---

## 6.2 ⚠ **存储过程的缺点**

### 1️⃣ **可移植性差**
存储过程的语法因数据库不同而有所不同。例如，MySQL 和 Oracle 的存储过程写法不同：

**MySQL**
```sql
DELIMITER //
CREATE PROCEDURE GetUserCount()
BEGIN
    SELECT COUNT(*) FROM users;
END //
DELIMITER ;
```
**Oracle**
```sql
CREATE OR REPLACE PROCEDURE GetUserCount AS
BEGIN
    SELECT COUNT(*) INTO v_count FROM users;
END;
```
如果公司以后换数据库（如从 MySQL 迁移到 PostgreSQL），存储过程需要全部重写，增加了迁移成本。

### 2️⃣ **调试困难**
普通 SQL 可以直接在 MySQL 命令行或 Navicat 里执行，而存储过程不易调试，出错时不容易找出问题。

比如，下面的存储过程有错误：
```sql
DELIMITER //
CREATE PROCEDURE TestProcedure()
BEGIN
    DECLARE num INT;
    SET num = 'ABC';  -- 错误：字符串不能赋值给 INT
    SELECT num;
END //
DELIMITER ;
```
在 SQL 语句中直接执行 `SET @num = 'ABC';` 会立即报错，而存储过程内执行时错误可能不会立即反馈。

### 3️⃣ **版本管理困难**
存储过程的代码是存储在数据库里的，没有 Git 之类的版本管理工具跟踪更改，更新存储过程时很麻烦。

如果 `users` 表添加了 `phone_number` 字段，原本的 `InsertUser` 过程：
```sql
INSERT INTO users (name, email) VALUES (userName, userEmail);
```
必须手动修改为：
```sql
INSERT INTO users (name, email, phone_number) VALUES (userName, userEmail, userPhone);
```
否则调用 `CALL InsertUser('Alice', 'alice@example.com');` 就会报错。

对于使用代码版本管理的团队来说，存储过程的更新流程比普通 SQL 语句复杂。

### 4️⃣ **不适合高并发场景**
高并发系统通常会使用 **分库分表** 来提升性能，而存储过程在这种情况下会加重数据库负担，难以水平扩展。

例如，一个电商系统可能有 10 亿用户，会分库：
- `users_db_1`
- `users_db_2`
- `users_db_3`

但如果存储过程是：
```sql
CREATE PROCEDURE FindUser(IN userId INT)
BEGIN
    SELECT * FROM users WHERE id = userId;
END;
```
它无法自动适配 `users_db_1` 或 `users_db_2`，导致 **存储过程在分库环境下难以使用**。

而使用 **应用层代码**：
```js
const dbIndex = userId % 3;  // 选择合适的数据库
const query = `SELECT * FROM users_db_${dbIndex}.users WHERE id = ${userId}`;
```
这样可以动态选择数据库，而存储过程无法做到。

### 🎯 **为什么一些公司禁止存储过程？**
像 **阿里巴巴** 这样的公司禁止使用存储过程，主要是因为：
1. **存储过程难以调试和维护**，版本管理不便。
2. **数据库迁移困难**，如从 MySQL 迁移到 PostgreSQL，存储过程需要重写。
3. **高并发环境难以扩展**，存储过程不适用于分库分表架构。
4. **更倾向于在应用层处理业务逻辑**，而不是在数据库层。

而 **微软、IBM** 等公司仍然使用存储过程，通常是因为：
1. 他们的数据库架构 **长期稳定**，不需要跨数据库迁移。
2. 存储过程可以 **提高 SQL 执行效率**。
3. 他们的项目适用于 **数据库驱动的架构**，存储过程减少了业务逻辑代码的复杂性。

### **结论：存储过程要不要用？**
> 存储过程既方便，又有局限性。尽管不同的公司对存储过程的态度不一，但是对于我们开发人员来说，不论怎样，掌握存储过程都是必备的技能之一。

- **适合用的场景：**
  - 需要封装业务逻辑，提高 SQL 执行效率
  - 需要减少网络传输，降低数据库查询次数
  - 需要数据库级的权限管理，保证安全性

- **不适合的场景：**
  - 项目可能会更换数据库（如 MySQL → PostgreSQL）
  - 需要高并发支持，存储过程会加重数据库负担
  - 需要频繁变更业务逻辑，不方便维护

--- 