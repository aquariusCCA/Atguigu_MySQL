# 1. 变量

在 MySQL 数据库的存储过程和函数中，可以使用变量来存储查询或计算的中间结果数据，或者输出最终的结果数据。

在 MySQL 数据库中，变量分为`系统变量`以及`用户自定义变量`。

## 1.1 系统变量

### 1.1.1 系统变量分类

变量由系统定义，不是用户定义，属于`服务器`层面。启动MySQL服务，生成MySQL服务实例期间，MySQL将为MySQL服务器内存中的系统变量赋值，这些系统变量定义了当前MySQL服务实例的属性、特征。这些系统变量的值要么是`编译MySQL时参数`的默认值，要么是`配置文件`（例如my.ini等）中的参数值。大家可以通过网址 `https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html` 查看MySQL文档的系统变量。

> **📌 系统变量的分类**
> 1. **全局系统变量（Global）**  
>    - 影响所有会话（连接）  
>    - 但 **不能跨 MySQL 重启**（除非修改配置文件 `my.cnf` 或 `my.ini`）  
>    - 需要使用 `GLOBAL` 关键字进行操作  
> 
> 2. **会话系统变量（Session）**  
>    - **仅影响当前会话**（连接），其他会话不会受影响  
>    - 默认情况下，查询或修改变量时 **不加关键字表示会话变量**  
>    - 需要使用 `SESSION` 关键字进行操作  
> 
> 3. **静态系统变量（Static）**  
>    - **只能在 MySQL 服务器启动时设定**，不能在运行时修改  
>    - 例如 `innodb_page_size`（InnoDB 页大小）  


每一个MySQL客户机成功连接MySQL服务器后，都会产生与之对应的会话。会话期间，MySQL服务实例会在MySQL服务器内存中生成与该会话对应的会话系统变量，这些会话系统变量的初始值是全局系统变量值的复制。如下图：

![image-20211108114846634](images/image-20211108114846634.png)

- 全局系统变量针对于所有会话（连接）有效，但`不能跨重启`
- 会话系统变量仅针对于当前会话（连接）有效。会话期间，当前会话对某个会话系统变量值的修改，不会影响其他会话同一个会话系统变量的值。
- 会话1对某个全局系统变量值的修改会导致会话2中同一个全局系统变量值的修改。

在 MySQL 中有些系统变量只能是全局的，例如 `max_connections` 用于限制服务器的最大连接数；有些系统变量作用域既可以是全局又可以是会话，例如 `character_set_client` 用于设置客户端的字符集；有些系统变量的作用域只能是当前会话，例如 `pseudo_thread_id` 用于标记当前会话的 MySQL 连接 ID。

### 1.1.2 查看系统变量
MySQL 提供了 `SHOW VARIABLES` 和 `SELECT @@` 语句来查询系统变量，这些变量用于控制 MySQL 服务器的行为。系统变量可以是 **全局变量（GLOBAL）** 或 **会话变量（SESSION）**。

#### **1️⃣ 查看所有或部分系统变量**
MySQL 提供 `SHOW VARIABLES` 语句来查询所有系统变量。

##### **🔹 查询所有全局变量**
```sql
SHOW GLOBAL VARIABLES;
```
✅ **示例输出（部分）**：
```
+------------------------+---------------------------+
| Variable_name         | Value                      |
+------------------------+---------------------------+
| autocommit           | ON                         |
| max_connections      | 151                        |
| character_set_server | utf8mb4                    |
| sql_mode            | STRICT_TRANS_TABLES,NO_AUTO_CREATE_USER |
+------------------------+---------------------------+
```

##### **🔹 查询所有会话变量**
```sql
SHOW SESSION VARIABLES;
```
✅ **或者直接使用：**
```sql
SHOW VARIABLES;
```
> **注意**：不加 `GLOBAL` 或 `SESSION` 默认查询的是 **会话变量**。

#### **2️⃣ 查询特定系统变量**
如果想查询满足特定条件的变量，可以使用 `LIKE` 关键字进行筛选。

```sql
#查看满足条件的部分系统变量。
SHOW GLOBAL VARIABLES LIKE '%标识符%';

#查看满足条件的部分会话变量
SHOW SESSION VARIABLES LIKE '%标识符%';
```

##### **🔹 查询名称中包含 `admin_` 的全局变量**
```sql
SHOW GLOBAL VARIABLES LIKE 'admin_%';
```

##### **🔹 查询名称中包含 `timeout` 的会话变量**
```sql
SHOW SESSION VARIABLES LIKE '%timeout%';
```
✅ **示例输出**：
```
+------------------+--------+
| Variable_name   | Value  |
+------------------+--------+
| connect_timeout | 10     |
| wait_timeout    | 28800  |
+------------------+--------+
```

#### **3️⃣ 直接查看指定系统变量**
作为 MySQL 编码规范，MySQL 中的系统变量以 `两个“@”` 开头，其中 `@@global` 仅用于标记全局系统变量，`@@session` 仅用于标记会话系统变量。`@@` 首先标记会话系统变量，如果会话系统变量不存在，则标记全局系统变量。

```sql
#查看指定的系统变量的值
SELECT @@global.变量名;

#查看指定的会话变量的值
SELECT @@session.变量名;
#或者
SELECT @@变量名;
```

##### **🔹 查询指定的全局系统变量**
```sql
SELECT @@global.autocommit;
```
✅ **示例输出**：
```
+---------------------+
| @@global.autocommit |
+---------------------+
| 1                   |
+---------------------+
```

##### **🔹 查询指定的会话系统变量**
```sql
SELECT @@session.tx_isolation;
```
✅ **示例输出**：
```
+------------------------+
| @@session.tx_isolation |
+------------------------+
| REPEATABLE-READ        |
+------------------------+
```

##### **🔹 查询会话变量（简写方式）**
> **如果变量仅存在于会话级别，可以省略 `session` 关键字**
```sql
SELECT @@tx_isolation;
```

#### **4️⃣ 修改系统变量**
MySQL 允许在 **运行时** 或 **配置文件** 中修改系统变量的值。

##### **🔹 修改全局变量（影响所有会话）**
为某个系统变量赋值：
```sql
#方式1：
SET @@global.变量名=变量值;
#方式2：
SET GLOBAL 变量名=变量值;
```

舉例：
```sql
SET @@global.autocommit = 0;
-- 或者
SET GLOBAL autocommit = 0;
```
🔔 **注意**：
- **仅影响新的连接**，已经存在的会话不受影响。
- **重启 MySQL 后会恢复默认值**，如果想永久修改，需修改配置文件。

##### **🔹 修改会话变量（仅影响当前连接）**
为某个会话变量赋值：
```sql
#方式1：
SET @@session.变量名=变量值;
#方式2：
SET SESSION 变量名=变量值;
```

舉例：
```sql
SET @@session.tx_isolation = 'read-uncommitted';
-- 或者
SET SESSION tx_isolation = 'read-uncommitted';
```
✅ **验证修改是否生效**
```sql
SELECT @@session.tx_isolation;
```

#### **5️⃣ 修改配置文件（永久生效）**
如果要使系统变量在 **MySQL 重启后依然生效**，需要修改 `my.cnf`（Linux）或 `my.ini`（Windows）。

🔹 **示例：修改 `autocommit` 和 `max_connections`**
```ini
[mysqld]
autocommit=0
max_connections=1000
```
然后重启 MySQL：
```sh
systemctl restart mysql
```

#### **💡 总结**
| 语法 | 作用 | 说明 |
|------|------|------|
| `SHOW GLOBAL VARIABLES;` | 查询所有全局变量 | |
| `SHOW SESSION VARIABLES;` | 查询所有会话变量 | |
| `SHOW VARIABLES LIKE '%timeout%';` | 查询匹配的变量 | |
| `SELECT @@global.变量名;` | 查询全局变量值 | |
| `SELECT @@session.变量名;` | 查询会话变量值 | |
| `SET GLOBAL 变量名 = 值;` | 修改全局变量（影响新会话） | 重启后恢复默认 |
| `SET SESSION 变量名 = 值;` | 修改当前会话变量 | 仅当前会话生效 |
| 配置文件 `my.cnf` | 永久修改变量 | 需要重启 MySQL |

---

## 1.2 用户变量

### 1.2.1 用户变量分类

用户变量是用户自己定义的，作为 MySQL 编码规范，MySQL 中的用户变量以 `一个“@”` 开头。根据作用范围不同，又分为 `会话用户变量` 和 `局部变量`。

- 会话用户变量：作用域和会话变量一样，只对 `当前连接` 会话有效。

- 局部变量：只在 BEGIN 和 END 语句块中有效。局部变量只能在 `存储过程和函数` 中使用。

### 1.2.2 会话用户变量
**会话用户变量**是在 MySQL 会话（Session）内定义的变量，它们的作用域仅限于当前数据库连接，断开连接后变量就会丢失。这些变量可以在 SQL 语句中使用，例如赋值、计算、查询等。

#### **1. 定义用户变量**

用户变量的命名规则：
- 变量名前加 `@` 符号（如 `@变量名`）。
- 可以使用 `SET` 或 `SELECT` 语句进行赋值。
- 变量的值可以是数值、字符串或 SQL 语句计算的结果。

##### **(1) 使用 `SET` 赋值**
```sql
SET @变量名 = 值;
SET @变量名 := 值;  -- ":=" 赋值运算符与 "=" 作用相同
```
**示例：**
```sql
SET @name = 'Alice';
SET @age := 25;

SELECT @name, @age;
```
**执行结果：**
```
+-------+------+
| name  | age  |
+-------+------+
| Alice |   25 |
+-------+------+
```

##### **(2) 使用 `SELECT` 赋值**
```sql
SELECT @变量名 := 表达式 FROM 表名;
SELECT 表达式 INTO @变量名 FROM 表名;
```

**示例1：计算 `employees` 表中的员工数量，并存入变量 `@num`**
```sql
SELECT @num := COUNT(*) FROM employees;
SELECT @num;  -- 查看变量值
```

**示例2：计算 `employees` 表的平均工资，并存入 `@avgsalary`**
```sql
SELECT AVG(salary) INTO @avgsalary FROM employees;
SELECT @avgsalary;
```

#### **2. 查看用户变量的值**
**直接 `SELECT` 变量**
```sql
SELECT @变量名;
```

**示例：**
```sql
SET @message = 'Hello, MySQL!';
SELECT @message;
```
**输出：**
```
+---------------+
| message       |
+---------------+
| Hello, MySQL! |
+---------------+
```

#### **3. 会话用户变量的作用范围**
1. **变量仅在当前会话（Session）内有效。**  
   - 当用户断开数据库连接后，变量值会被清除。
   - 不同会话（例如不同的终端窗口）之间不会共享用户变量。

2. **未声明的用户变量默认值为 NULL**
   ```sql
   SELECT @undefined_var;
   ```
   **输出：**
   ```
   +---------------+
   | undefined_var |
   +---------------+
   | NULL          |
   +---------------+
   ```

#### **4. 结合 SQL 语句使用**
##### **(1) 用变量计算**
```sql
SET @x = 10, @y = 5;
SELECT @x + @y AS sum, @x - @y AS difference, @x * @y AS product;
```
**输出：**
```
+-----+------------+---------+
| sum | difference | product |
+-----+------------+---------+
|  15 |          5 |      50 |
+-----+------------+---------+
```

##### **(2) 在 `WHERE` 条件中使用用户变量**
假设 `employees` 表的结构如下：
```
+----+--------+--------+
| id | name   | salary |
+----+--------+--------+
|  1 | Alice  |  5000  |
|  2 | Bob    |  7000  |
|  3 | Charlie|  6000  |
+----+--------+--------+
```
如果想查找工资高于 `@avgsalary` 的员工：
```sql
SELECT AVG(salary) INTO @avgsalary FROM employees;
SELECT * FROM employees WHERE salary > @avgsalary;
```

#### **5. 小结**
✅ **用户变量的特点：**
- 作用范围：当前会话（Session）有效，断开连接后失效。
- 赋值方式：
  1. `SET @变量 = 值;`
  2. `SELECT @变量 := 值 FROM ...;`
  3. `SELECT 值 INTO @变量 FROM ...;`
- 可以用于数学计算、条件查询等。
- 未初始化的变量返回 `NULL`。

---

### 1.2.3 局部变量

定义：可以使用 `DECLARE` 语句定义一个局部变量

作用域：仅仅在定义它的 BEGIN ... END 中有效

位置：只能放在 BEGIN ... END 中，而且只能放在第一句

```sql
BEGIN
	#声明局部变量
	DECLARE 变量名1 变量数据类型 [DEFAULT 变量默认值];
	DECLARE 变量名2,变量名3,... 变量数据类型 [DEFAULT 变量默认值];

	#为局部变量赋值
	SET 变量名1 = 值;
	SELECT 值 INTO 变量名2 [FROM 子句];

	#查看局部变量的值
	SELECT 变量1,变量2,变量3;
END
```

#### **1.定义变量**

```sql
DECLARE 变量名 类型 [default 值];  # 如果没有DEFAULT子句，初始值为NULL
```

举例：

```sql
DECLARE　myparam　INT　DEFAULT 100;
```

#### **2.变量赋值**

方式1：一般用于赋简单的值

```sql
SET 变量名=值;
SET 变量名:=值;
```

方式2：一般用于赋表中的字段值

```sql
SELECT 字段名或表达式 INTO 变量名 FROM 表;
```

#### **3.使用变量**（查看、比较、运算等）

```sql
SELECT 局部变量名;
```

举例1：声明局部变量，并分别赋值为 `employees` 表中 `employee_id` 为 102 的 `last_name` 和 `salary`

```sql
DELIMITER //

CREATE PROCEDURE set_value()
BEGIN
	DECLARE emp_name VARCHAR(25);
	DECLARE sal DOUBLE(10,2);
	
	SELECT last_name,salary INTO emp_name,sal
	FROM employees 
	WHERE employee_id = 102;
	
	SELECT emp_name,sal;
END //

DELIMITER ;
```

举例2：声明两个变量，求和并打印 （分别使用会话用户变量、局部变量的方式实现）

```sql
#方式1：使用用户变量
SET @m=1;
SET @n=1;
SET @sum=@m+@n;

SELECT @sum;
```

```sql
#方式2：使用局部变量
DELIMITER //

CREATE PROCEDURE add_value()
BEGIN
	#局部变量
	DECLARE m INT DEFAULT 1;
	DECLARE n INT DEFAULT 3;
	DECLARE SUM INT;
	
	SET SUM = m+n;
	SELECT SUM;
END //

DELIMITER ;
```

举例3：创建存储过程 `different_salary` 查询某员工和他领导的薪资差距，并用 `IN` 参数 `emp_id` 接收员工id，用 `OUT` 参数 `dif_salary` 输出薪资差距结果。

```sql
#声明
DELIMITER //

CREATE PROCEDURE different_salary(IN emp_id INT,OUT dif_salary DOUBLE)
BEGIN
	#声明局部变量
	DECLARE emp_sal,mgr_sal DOUBLE DEFAULT 0.0;
	DECLARE mgr_id INT;
	
	SELECT salary INTO emp_sal FROM employees WHERE employee_id = emp_id;
	SELECT manager_id INTO mgr_id FROM employees WHERE employee_id = emp_id;
	SELECT salary INTO mgr_sal FROM employees WHERE employee_id = mgr_id;
	SET dif_salary = mgr_sal - emp_sal;

END //

DELIMITER ;

#调用
SET @emp_id = 102;
CALL different_salary(@emp_id,@diff_sal);


#查看
SELECT @diff_sal;
```

### 1.2.4 对比会话用户变量与局部变量
在 MySQL 中，**会话用户变量（User Variables）** 和 **局部变量（Local Variables）** 主要有以下区别：

| 比较项        | **会话用户变量（User Variables）** | **局部变量（Local Variables）** |
|--------------|----------------------------------|---------------------------------|
| **作用范围**  | 当前会话（Session）内有效，不受存储过程或块级作用域限制 | 仅在存储过程（Stored Procedure）或 BEGIN...END 块内部有效 |
| **命名方式**  | 以 `@` 开头（如 `@my_var`）        | 直接命名（如 `my_var`），不需要 `@` |
| **定义方式**  | **无需显式声明**，直接赋值即创建 | **必须显式声明**，用 `DECLARE` 语句 |
| **赋值方式**  | `SET @var = value;` 或 `SELECT ... INTO @var;` 或 `:=` | `SET var = value;` 或 `SELECT ... INTO var;` |
| **变量存储**  | 存储在会话（Session）级别，不随查询结束释放 | 仅在存储过程或块作用域内生效，块结束后自动释放 |
| **查询变量值** | `SELECT @var;`                  | 仅能在存储过程内 `SELECT var;` |
| **存储时间**    | 直到会话结束       | 代码块结束即销毁 |
| **查询方式**    | `SELECT @var;`    | `SELECT var;`（仅限存储过程内） |
| **跨查询共享**  | ✅ 可以            | ❌ 不可以 |
| **WHERE 可用**  | ✅ 可用于 `WHERE`   | ❌ 不能直接用于 `WHERE` |
| **适用场景**  | 可用于存储查询结果、临时计算、会话级别的数据共享 | 适用于存储过程、触发器和函数内部的临时数据处理 |

# 2. 定义条件与处理程序

`定义条件`是事先定义程序执行过程中可能遇到的问题，`处理程序`定义了在遇到问题时应当采取的处理方式，并且保证存储过程或函数在遇到警告或错误时能继续执行。这样可以增强存储程序处理问题的能力，避免程序异常停止运行。

说明：定义条件和处理程序在存储过程、存储函数中都是支持的。

## 2.1 定义条件

> **「定义条件」** 指的是给 **MySQL 预设的错误代码（SQLSTATE）** 或 **数字错误码** 起一个易读的名字，这有助于存储的程序代码更清晰。它将一个 `错误名称` 和 `指定的错误条件` 关联起来。这个名称可以随后被用在定义处理程序的 `DECLARE HANDLER` 语句中。

定义条件使用 `DECLARE` 语句，语法格式如下：

```sql
DECLARE 错误名称 CONDITION FOR 错误码（或错误条件）;
```

### 错误码的说明：

- `MySQL_error_code` 和 `sqlstate_value` 都可以表示 MySQL 的错误。
  - `MySQL_error_code` 是数值类型错误代码。
  - `sqlstate_value` 是长度为 5 的字符串类型错误代码。
- 例如，在 `ERROR 1418 (HY000)` 中，`1418` 是 `MySQL_error_code`，`'HY000'` 是 `sqlstate_value`。
- 例如，在 `ERROR 1142（42000）` 中，`1142` 是 `MySQL_error_code`，`'42000'` 是 `sqlstate_value`。

#### **错误码（MySQL_error_code）** 和 **错误条件（SQLSTATE）** 都是 **MySQL 预设的错误代码**，它们只是两种不同的表示方式：

1. **错误码（MySQL_error_code）**：  
   - 是**数值型**的 MySQL 预设错误代码，例如：
     - `1048`（字段不能为空）
     - `1142`（权限不足）
     - `1213`（死锁检测）
   - **示例**：
     ```sql
     ERROR 1048 (23000): Column 'name' cannot be null
     ```

2. **错误条件（SQLSTATE）**：  
   - 是**字符串型**的标准 SQL 错误代码，长度固定为 5 位字符，例如：
     - `'23000'`（违反约束）
     - `'42000'`（SQL 语法错误）
     - `'40001'`（事务死锁）
   - **示例**：
     ```sql
     ERROR 1142 (42000): DELETE command denied to user
     ```

> **总结**：  
> - **错误码（MySQL_error_code）** 是 **数值型**，MySQL 专有。  
> - **错误条件（SQLSTATE）** 是 **字符串型**，符合 SQL 标准。  
> - 它们都是 MySQL 预设的错误代码，可以用 `DECLARE ... CONDITION` 为其起一个易读的名字。  

### 示例：

#### **示例 1**：定义 “Field_Not_Be_NULL” 错误名与 MySQL 中违反非空约束的错误类型 “ERROR 1048 (23000)” 对应。

```sql
-- 使用 MySQL_error_code
DECLARE Field_Not_Be_NULL CONDITION FOR 1048;

-- 使用 sqlstate_value
DECLARE Field_Not_Be_NULL CONDITION FOR SQLSTATE '23000';
```

#### **示例 2**：定义 "ERROR 1148(42000)" 错误，名称为 `command_not_allowed`。

```sql
-- 使用 MySQL_error_code
DECLARE command_not_allowed CONDITION FOR 1148;

-- 使用 sqlstate_value
DECLARE command_not_allowed CONDITION FOR SQLSTATE '42000';
```

---

## 2.2 定义处理程序
可以为SQL执行过程中发生的某种类型的错误定义特殊的处理程序。定义处理程序时，使用DECLARE语句的语法如下：

```sql
DECLARE 处理方式 HANDLER FOR 错误类型 处理语句;
```

### 1. 主要组成部分

#### **（1）处理方式**
处理方式决定了 MySQL 遇到指定错误时的行为，主要有以下 3 种：
- **`CONTINUE`**：遇到错误后，继续执行后续语句（适用于可忽略的错误）。
- **`EXIT`**：遇到错误后，立即退出当前存储过程或触发器（适用于严重错误）。
- **`UNDO`**：遇到错误后，撤销先前的操作（MySQL **暂不支持**）。

#### **（2）错误类型（条件）**
MySQL 允许多种方式指定错误类型，包括 SQLSTATE 错误码、MySQL 错误码、已声明的条件名称等。

- **`SQLSTATE '字符串错误码'`**：匹配长度为 **5** 的 SQLSTATE 错误代码。
  - 例如：`SQLSTATE '42S02'`（Table not found）
- **`MySQL_error_code`**：匹配 MySQL 数值类型错误代码。
  - 例如：`1146`（Table not found）
- **`DECLARE ... CONDITION`** 预定义的错误名称：
  - 例如：`DECLARE no_such_table CONDITION FOR 1146;`
- **`SQLWARNING`**：匹配所有 **以 `01` 开头** 的 SQLSTATE 警告代码。
- **`NOT FOUND`**：匹配所有 **以 `02` 开头** 的 SQLSTATE 代码，常用于 `CURSOR` 相关操作（如 `SELECT INTO` 语句未找到数据）。
- **`SQLEXCEPTION`**：匹配所有 **未被 `SQLWARNING` 或 `NOT FOUND` 捕获** 的 SQLSTATE 代码，适用于一般 SQL 错误。

#### **（3）处理语句**
当指定的错误条件发生时，MySQL 将执行相应的处理语句。处理语句可以是：
- **简单语句**：
  ```sql
  SET @error_msg = 'Table Not Found';
  ```
- **复合语句（`BEGIN ... END`）**：
  ```sql
  BEGIN
    SET @error_msg = 'Table Not Found';
    INSERT INTO error_log (error_message, created_at) VALUES ('Table Not Found', NOW());
  END;
  ```

### 3. 定义处理程序的几种方式

#### **（1）捕获 SQLSTATE 错误代码**
```sql
DECLARE CONTINUE HANDLER FOR SQLSTATE '42S02' SET @info = 'NO_SUCH_TABLE';
```
- `42S02` 代表 **"Table not found"** 错误。

#### **（2）捕获 MySQL 错误代码**
```sql
DECLARE CONTINUE HANDLER FOR 1146 SET @info = 'NO_SUCH_TABLE';
```
- `1146` 是 MySQL 代码，表示 **表不存在** 错误。

#### **（3）使用 `DECLARE ... CONDITION` 预定义错误**
```sql
DECLARE no_such_table CONDITION FOR 1146;
DECLARE CONTINUE HANDLER FOR no_such_table SET @info = 'NO_SUCH_TABLE';
```
- 先使用 `DECLARE ... CONDITION` 给 `1146` 取一个名称 `no_such_table`。
- 处理程序中直接使用 `no_such_table` 代替 `1146`。

#### **（4）捕获 `SQLWARNING`（SQL 警告）**
```sql
DECLARE EXIT HANDLER FOR SQLWARNING SET @info = 'SQL Warning occurred';
```
- 适用于 **SQL 语句执行后可能的警告**（如 `INSERT IGNORE` 跳过重复行时）。

#### **（5）捕获 `NOT FOUND`（未找到数据）**
```sql
DECLARE EXIT HANDLER FOR NOT FOUND SET @info = 'No matching data found';
```
- 适用于 **`SELECT INTO` 查询未返回数据** 或 **游标（Cursor）遍历到末尾**。

#### **（6）捕获 `SQLEXCEPTION`（其他 SQL 异常）**
```sql
DECLARE EXIT HANDLER FOR SQLEXCEPTION SET @info = 'A SQL error occurred';
```
- 捕获 **所有未被 `SQLWARNING` 或 `NOT FOUND` 处理的 SQLSTATE 错误**。

### 4. 示例：使用 `DECLARE HANDLER` 处理错误

#### **示例 1：查询表时错误处理**
```sql
DELIMITER //

CREATE PROCEDURE test_error_handling()
BEGIN
    DECLARE CONTINUE HANDLER FOR 1146 SET @error_msg = 'Table does not exist';
    
    -- 触发错误（假设 `non_existing_table` 不存在）
    SELECT * FROM non_existing_table;
    
    -- 继续执行其他 SQL 语句
    SELECT 'This statement still runs';
END //

DELIMITER ;

CALL test_error_handling();
SELECT @error_msg; -- 输出：Table does not exist
```
**说明**：
- `1146` 是 "Table not found" 错误码。
- `CONTINUE` 处理方式使得错误发生后，存储过程 **不会终止**，而是 **继续执行后续 SQL** 语句。

#### **示例 2：游标查询错误处理**
```sql
DELIMITER //

CREATE PROCEDURE test_cursor()
BEGIN
    DECLARE done INT DEFAULT 0;
    DECLARE user_name VARCHAR(100);
    
    DECLARE cur CURSOR FOR SELECT name FROM users WHERE age > 30;
    
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 1;
    
    OPEN cur;
    
    read_loop: LOOP
        FETCH cur INTO user_name;
        
        IF done = 1 THEN
            LEAVE read_loop;
        END IF;
        
        -- 处理查询结果
        SELECT user_name;
    END LOOP;
    
    CLOSE cur;
END //

DELIMITER ;

CALL test_cursor();
```
**说明**：
- `NOT FOUND` 处理方式 **避免 `FETCH` 语句在游标到达末尾时报错**，而是 **退出循环**。

#### **示例 3：存储过程中的异常处理**
```sql
DELIMITER //

CREATE PROCEDURE divide_numbers(a INT, b INT)
BEGIN
    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SET @error_msg = 'Division by zero error';
    
    -- 如果 b = 0，则会触发错误
    SET @result = a / b;
    
    -- 继续执行其他操作
    SELECT 'End of procedure';
END //

DELIMITER ;

CALL divide_numbers(10, 0);
SELECT @error_msg; -- 输出: Division by zero error
```
**说明**：
- `SQLEXCEPTION` 处理所有 SQL 异常（如 **除数为零**）。
- **即使发生错误，存储过程仍然不会中断**。

---

## 2.3 案例解决

### **範例 1：處理除零錯誤（SQLSTATE '22012'）**
在數學運算中，如果 **除數為 0**，MySQL 會報錯：`ERROR 1365 (22012): Division by 0`。

我們可以用 **條件 + 處理程序** 來捕捉這種錯誤，並在錯誤發生時給出一個預設值。

##### **程式碼**
```sql
DELIMITER $$

CREATE PROCEDURE divide_numbers(IN numerator INT, IN denominator INT, OUT result DECIMAL(10,2))
BEGIN
    -- 定義條件名稱
    DECLARE division_by_zero CONDITION FOR SQLSTATE '22012';

    -- 如果遇到除以零的錯誤，就將 result 設為 NULL 而不報錯
    DECLARE CONTINUE HANDLER FOR division_by_zero SET result = NULL;

    -- 嘗試執行除法運算
    SET result = numerator / denominator;
END $$

DELIMITER ;
```

##### **測試**
```sql
CALL divide_numbers(10, 2, @res);
SELECT @res;  -- 正常計算，應該輸出 5.00

CALL divide_numbers(10, 0, @res);
SELECT @res;  -- 應該輸出 NULL，而不會報錯
```

📌 **說明**
- 如果 `denominator = 0`，MySQL 本來會報錯，但因為我們有 `CONTINUE HANDLER`，所以錯誤被處理，並將 `result` 設為 `NULL`。

### **範例 2：處理數據插入錯誤（主鍵重複）**
當我們插入資料時，如果 **主鍵重複**，MySQL 會報錯 `ERROR 1062 (23000): Duplicate entry`。

我們可以用 **EXIT HANDLER** 來記錄這個錯誤並終止程序。

##### **程式碼**
```sql
DELIMITER $$

CREATE PROCEDURE insert_user(IN user_id INT, IN user_name VARCHAR(50))
BEGIN
    -- 定義條件名稱
    DECLARE duplicate_key CONDITION FOR SQLSTATE '23000';

    -- 當遇到主鍵重複時，設置變數並退出存儲過程
    DECLARE EXIT HANDLER FOR duplicate_key 
    BEGIN
        SET @error_msg = CONCAT('User ID ', user_id, ' already exists.');
    END;

    -- 嘗試插入數據
    INSERT INTO users (id, name) VALUES (user_id, user_name);
END $$

DELIMITER ;
```

##### **測試**
```sql
CALL insert_user(1, 'Alice');  -- 假設 id=1 的使用者不存在，這將成功插入
CALL insert_user(1, 'Bob');    -- 假設 id=1 已存在，這將觸發錯誤
SELECT @error_msg;             -- 查看錯誤信息
```

📌 **說明**
- 當 `id=1` 已經存在時，`@error_msg` 變數會被設置為 **"User ID 1 already exists."**，但不會拋出錯誤，程式可以安全退出。

### **範例 3：處理表不存在錯誤**
如果你嘗試刪除一個不存在的表，MySQL 會報錯 `SQLSTATE '42S02'`（表不存在）。

這裡我們用 **CONTINUE HANDLER** 讓程序繼續執行，而不是因為錯誤中止。

#### **程式碼**
```sql
DELIMITER $$

CREATE PROCEDURE drop_table_if_exists(IN table_name VARCHAR(50))
BEGIN
    -- 定義條件
    DECLARE table_not_exist CONDITION FOR SQLSTATE '42S02';

    -- 如果表不存在，則記錄一條消息，然後繼續執行
    DECLARE CONTINUE HANDLER FOR table_not_exist 
    SET @error_msg = CONCAT('Table ', table_name, ' does not exist, but we continue');

    -- 嘗試刪除表
    SET @sql_query = CONCAT('DROP TABLE ', table_name);
    PREPARE stmt FROM @sql_query;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
END $$

DELIMITER ;
```

#### **測試**
```sql
CALL drop_table_if_exists('non_existent_table');
SELECT @error_msg;  -- 應該輸出：Table non_existent_table does not exist, but we continue
```

📌 **說明**
- 如果表 `non_existent_table` 不存在，MySQL 本來會拋出錯誤，但 `CONTINUE HANDLER` 會捕捉錯誤，讓程序繼續運行。

### **範例 4：處理通用 SQL 錯誤**
如果你想捕捉所有 SQL 錯誤（無論是表不存在、數據錯誤還是其他問題），可以使用 `SQLWARNING` 或 `SQLEXCEPTION`。

- `SQLWARNING`：捕獲 SQL 警告類錯誤（如數據截斷）。
- `SQLEXCEPTION`：捕獲 SQL 例外錯誤（如語法錯誤、表不存在、數據錯誤）。

#### **程式碼**
```sql
DELIMITER $$

CREATE PROCEDURE general_error_handler()
BEGIN
    -- 當遇到任何 SQL 錯誤時，記錄錯誤信息
    DECLARE EXIT HANDLER FOR SQLEXCEPTION 
    BEGIN
        SET @error_msg = 'An SQL error occurred.';
    END;

    -- 嘗試執行一個錯誤的 SQL 語句
    SELECT * FROM non_existent_table;

END $$

DELIMITER ;
```

#### **測試**
```sql
CALL general_error_handler();
SELECT @error_msg;  -- 應該輸出：An SQL error occurred.
```

📌 **說明**
- 無論什麼 SQL 錯誤發生，程序都會安全退出，而不是拋出錯誤。

---

# 3. 流程控制

## 3.1基本概念
解决复杂问题不可能通过一个 SQL 语句完成，我们需要执行多个 SQL 操作。流程控制语句的作用就是控制存储过程中 SQL 语句的执行顺序，是我们完成复杂操作必不可少的一部分。只要是执行的程序，流程就分为三大类：

- `顺序结构`：程序从上往下依次执行
- `分支结构`：程序按条件进行选择执行，从两条或多条路径中选择一条执行
- `循环结构`：程序满足一定条件下，重复执行一组语句

针对于MySQL 的流程控制语句主要有 3 类。

- `条件判断语句`：IF 语句和 CASE 语句
- `循环语句`：LOOP、WHILE 和 REPEAT 语句
- `跳转语句`：ITERATE 和 LEAVE 语句

| **類別**  | **語法** | **用途** | **是否可用於 `SELECT`** | **是否只能用於存儲程序** |
|-----------|---------|---------|------------------|------------------|
| **條件判斷** | `IF ... THEN ... ELSE ... END IF;` | 用於存儲程序的 `IF` 語句 | ❌ **不可以** | ✅ **是** |
| **條件判斷** | `CASE` | 用於條件判斷，可返回不同值 | ✅ **可以** | ❌ **不限定** |
| **循環** | `LOOP` | 無條件循環，需 `LEAVE` 退出 | ❌ **不可以** | ✅ **是** |
| **循環** | `WHILE` | `WHILE` 條件為 `TRUE` 則循環 | ❌ **不可以** | ✅ **是** |
| **循環** | `REPEAT ... UNTIL ... END REPEAT;` | 先執行再判斷是否結束循環 | ❌ **不可以** | ✅ **是** |
| **跳轉** | `LEAVE` | 結束 `LOOP`、`WHILE`、`REPEAT` | ❌ **不可以** | ✅ **是** |
| **跳轉** | `ITERATE` | 跳過本次循環，進入下一次循環 | ❌ **不可以** | ✅ **是** |

### 🔹 **額外補充**
1. **`CASE` 可用於 `SELECT` 語句**
   ```sql
   SELECT order_id, 
          CASE 
              WHEN total_amount > 1000 THEN '高價值訂單'
              ELSE '普通訂單'
          END AS 訂單類型
   FROM orders;
   ```
2. **`IF()` 函數可用於 `SELECT`**
   ```sql
   SELECT order_id, IF(total_amount > 1000, '高價值訂單', '普通訂單') AS 訂單類型
   FROM orders;
   ```
3. **`IF...THEN...ELSE...END IF;` 只能用於存儲程序**
   ```sql
   CREATE PROCEDURE check_salary()
   BEGIN
       DECLARE salary INT DEFAULT 5000;
       IF salary > 10000 THEN
           SELECT '高薪';
       ELSE
           SELECT '普通薪資';
       END IF;
   END;
   ```
4. **循環和跳轉語句 (`LOOP`、`WHILE`、`REPEAT`、`LEAVE`、`ITERATE`) 只能在存儲程序中使用**
   ```sql
   CREATE PROCEDURE loop_example()
   BEGIN
       DECLARE counter INT DEFAULT 1;
       my_loop: LOOP
           IF counter > 5 THEN 
               LEAVE my_loop;
           END IF;
           SET counter = counter + 1;
       END LOOP;
   END;
   ```
---

## 3.2 分支结构之 IF
### 📌 `IF` 语句的语法：
```sql
IF 表达式1 THEN 
    操作1;
ELSEIF 表达式2 THEN 
    操作2;
ELSE 
    操作N;
END IF;
```
- `IF 表达式1 THEN 操作1;` → 如果 `表达式1` 为 `TRUE`，则执行 `操作1`，并跳过后续判断。
- `ELSEIF 表达式2 THEN 操作2;` → 如果 `表达式1` 为 `FALSE`，但 `表达式2` 为 `TRUE`，执行 `操作2`。
- `ELSE 操作N;` → 如果所有 `IF` 和 `ELSEIF` 条件都不满足，则执行 `ELSE` 块中的 `操作N`。
- `END IF;` → 结束 `IF` 语句。

📌 **注意事项**
1. `IF` 语句**不能单独使用**，必须写在 `BEGIN ... END` 代码块中。
2. `ELSEIF` 和 `ELSE` 是可选的，可以省略。

### 🔹 🎯 示例 1：基本 `IF` 语句
📌 **需求**：创建一个存储过程，检查员工的工资是否高于 5000：
- 如果工资 > 5000，打印 `"高薪员工"`。
- 如果工资 ≤ 5000，打印 `"普通员工"`。

```sql
DELIMITER //
CREATE PROCEDURE CheckSalary(IN salary INT)
BEGIN
    IF salary > 5000 THEN
        SELECT '高薪员工' AS Result;
    ELSE
        SELECT '普通员工' AS Result;
    END IF;
END //
DELIMITER ;
```
🔹 **调用存储过程**
```sql
CALL CheckSalary(6000);
-- 输出: 高薪员工

CALL CheckSalary(4500);
-- 输出: 普通员工
```

### 🔹 🎯 示例 2：使用 `ELSEIF` 进行多条件判断
📌 **需求**：创建一个存储过程，判断学生的成绩等级：
- `score >= 90` → `"优秀"`
- `score >= 70 且 < 90` → `"良好"`
- `score >= 50 且 < 70` → `"及格"`
- `score < 50` → `"不及格"`

```sql
DELIMITER //
CREATE PROCEDURE CheckScore(IN score INT)
BEGIN
    IF score >= 90 THEN
        SELECT '优秀' AS Grade;
    ELSEIF score >= 70 THEN
        SELECT '良好' AS Grade;
    ELSEIF score >= 50 THEN
        SELECT '及格' AS Grade;
    ELSE
        SELECT '不及格' AS Grade;
    END IF;
END //
DELIMITER ;
```
🔹 **调用存储过程**
```sql
CALL CheckScore(95);
-- 输出: 优秀

CALL CheckScore(75);
-- 输出: 良好

CALL CheckScore(60);
-- 输出: 及格

CALL CheckScore(40);
-- 输出: 不及格
```

### 🔹 🎯 示例 3：在 `IF` 语句中更新表数据
📌 **需求**：假设有一张 `employees` 表，包含 `id` 和 `salary`：
- 如果 `salary > 7000`，增加 `500`。
- 如果 `salary 在 5000-7000 之间`，增加 `300`。
- 其他情况下，增加 `100`。

🔹 **创建 `employees` 表**
```sql
CREATE TABLE employees (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(50),
    salary INT
);

INSERT INTO employees (name, salary) VALUES 
('张三', 8000),
('李四', 6000),
('王五', 4500);
```

🔹 **创建存储过程**
```sql
DELIMITER //
CREATE PROCEDURE UpdateSalary(IN emp_id INT)
BEGIN
    DECLARE current_salary INT;
    
    -- 获取员工的工资
    SELECT salary INTO current_salary FROM employees WHERE id = emp_id;
    
    -- 根据不同条件更新工资
    IF current_salary > 7000 THEN
        UPDATE employees SET salary = salary + 500 WHERE id = emp_id;
    ELSEIF current_salary BETWEEN 5000 AND 7000 THEN
        UPDATE employees SET salary = salary + 300 WHERE id = emp_id;
    ELSE
        UPDATE employees SET salary = salary + 100 WHERE id = emp_id;
    END IF;
END //
DELIMITER ;
```

🔹 **执行存储过程**
```sql
CALL UpdateSalary(1);
CALL UpdateSalary(2);
CALL UpdateSalary(3);
```

🔹 **查看更新后的数据**
```sql
SELECT * FROM employees;
```
📌 **结果**
| id | name | salary |
|----|------|--------|
| 1  | 张三 | 8500   |
| 2  | 李四 | 6300   |
| 3  | 王五 | 4600   |

### 🔹 🎯 示例 4：结合 `IF` 语句和 `CASE` 语句
在某些情况下，我们可以使用 `CASE` 代替 `IF` 语句，例如：

```sql
SELECT 
    name,
    salary,
    CASE 
        WHEN salary > 7000 THEN '高薪'
        WHEN salary BETWEEN 5000 AND 7000 THEN '中等薪资'
        ELSE '低薪'
    END AS salary_level
FROM employees;
```
📌 **输出**
| name | salary | salary_level |
|------|--------|--------------|
| 张三 | 8500   | 高薪         |
| 李四 | 6300   | 中等薪资     |
| 王五 | 4600   | 低薪         |

### 🔹 `IF` 和 `IF()` 函数的区别
#### ✅ `IF` 语句（用于存储过程）
- 只能在 `BEGIN ... END` 代码块中使用。
- 适用于多行语句执行。

#### ✅ `IF()` 函数（用于 `SELECT` 语句）
- 可在 `SELECT` 语句中直接使用。
- 只能处理简单的 `TRUE/FALSE` 条件。

```sql
SELECT name, salary, 
    IF(salary > 5000, '高薪', '普通') AS salary_status 
FROM employees;
```

### 🔹 总结
1. **`IF` 语句** 只能在 `BEGIN ... END` 代码块内使用，适用于存储过程或存储函数。
2. **语法结构** 类似于 `if...else if...else`，支持 `ELSEIF` 和 `ELSE`。
3. **适用于条件判断**，如数据更新、业务逻辑处理等。
4. **可以结合 `CASE` 使用**，某些情况下 `CASE` 可能比 `IF` 更适合。

---

## 3.3 分支结构之 CASE
在 MySQL 中，`CASE` 语句用于在查询中执行条件判断，可以类比为编程语言中的 `switch` 或 `if-else` 结构。它有两种主要的使用方式：**表达式匹配模式**（类似 `switch`）和 **条件匹配模式**（类似 `if-else`）。

### 1. **表达式匹配模式（类似 switch）**
```sql
CASE 表达式
    WHEN 值1 THEN 结果1
    WHEN 值2 THEN 结果2
    ...
    ELSE 结果n
END
```
- `表达式` 是需要匹配的字段或计算结果。
- `WHEN` 后面是具体的值，如果匹配则执行 `THEN` 后的内容。
- `ELSE` 是可选的，如果没有匹配的 `WHEN`，则执行 `ELSE` 里面的结果。

#### 🔹 **示例 1：根据 `grade` 评分等级**
```sql
SELECT 
    student_name,
    grade,
    CASE grade
        WHEN 'A' THEN '优秀'
        WHEN 'B' THEN '良好'
        WHEN 'C' THEN '及格'
        WHEN 'D' THEN '不及格'
        ELSE '未知'
    END AS 等级描述
FROM students;
```
##### **解释**
- `CASE grade` 语句会检查 `grade` 的值：
  - 如果是 `'A'`，则返回 `'优秀'`
  - 如果是 `'B'`，则返回 `'良好'`
  - 如果是 `'C'`，则返回 `'及格'`
  - 如果是 `'D'`，则返回 `'不及格'`
  - 其他情况返回 `'未知'`

### 2. **条件匹配模式（类似 if-else）**
```sql
CASE
    WHEN 条件1 THEN 结果1
    WHEN 条件2 THEN 结果2
    ...
    ELSE 结果n
END
```
- `WHEN` 直接写条件表达式。
- MySQL 会从上到下依次判断，符合的 `THEN` 就会执行，后面的条件不会再判断。

#### 🔹 **示例 2：根据 `salary` 计算奖金**
```sql
SELECT 
    employee_name,
    salary,
    CASE 
        WHEN salary > 10000 THEN '高薪'
        WHEN salary BETWEEN 5000 AND 10000 THEN '中等薪资'
        WHEN salary < 5000 THEN '低薪'
        ELSE '未知'
    END AS 工资级别
FROM employees;
```
##### **解释**
- `CASE` 语句不使用 `表达式`，而是直接判断 `salary`：
  - `salary > 10000`，返回 `'高薪'`
  - `salary` 介于 `5000` 和 `10000` 之间，返回 `'中等薪资'`
  - `salary < 5000`，返回 `'低薪'`
  - 其他情况返回 `'未知'`

### 3. **结合 `CASE` 进行计算**
`CASE` 语句不仅可以返回字符串，还可以返回计算结果。

### 🔹 **示例 3：计算订单折扣**
```sql
SELECT 
    order_id,
    customer_name,
    total_amount,
    CASE 
        WHEN total_amount >= 1000 THEN total_amount * 0.9  -- 1000以上打9折
        WHEN total_amount >= 500 THEN total_amount * 0.95 -- 500-999打95折
        ELSE total_amount  -- 小于500无折扣
    END AS final_price
FROM orders;
```
##### **解释**
- 如果 `total_amount` ≥ 1000，给 9 折
- 如果 `total_amount` 在 `500-999` 之间，给 95 折
- 否则，不打折

### 4. **在 `UPDATE` 语句中使用 `CASE`**
`CASE` 语句不仅可以用于 `SELECT`，还可以用于 `UPDATE`。

#### 🔹 **示例 4：更新员工奖金**
```sql
UPDATE employees
SET bonus = 
    CASE 
        WHEN salary > 10000 THEN 500
        WHEN salary BETWEEN 5000 AND 10000 THEN 300
        ELSE 100
    END;
```
##### **解释**
- 高于 `10000` 的工资，奖金设为 `500`
- `5000-10000` 之间的工资，奖金设为 `300`
- 低于 `5000` 的工资，奖金设为 `100`

### 5. **在 `BEGIN ... END` 结构中使用 `CASE`**
如果 `CASE` 语句用于 `BEGIN ... END` 代码块中，必须加 `END CASE;`。

#### 🔹 **示例 5：存储过程中的 `CASE`**
```sql
DELIMITER //

CREATE PROCEDURE CheckGrade(IN g CHAR(1))
BEGIN
    CASE g
        WHEN 'A' THEN SELECT '优秀';
        WHEN 'B' THEN SELECT '良好';
        WHEN 'C' THEN SELECT '及格';
        WHEN 'D' THEN SELECT '不及格';
        ELSE SELECT '未知';
    END CASE;
END //

DELIMITER ;
```
##### **解释**
- `CASE` 语句在存储过程中使用 `END CASE;` 结束
- `SELECT` 语句根据 `g` 的值输出不同的评价

### 🔥 **总结**
| 语法 | 作用 |
|------|------|
| `CASE 表达式 WHEN 值 THEN 结果 ELSE 结果 END` | 类似 `switch`，匹配特定值 |
| `CASE WHEN 条件 THEN 结果 ELSE 结果 END` | 类似 `if-else`，判断条件 |
| `CASE` 可用于 `SELECT`、`UPDATE`、`BEGIN ... END` 代码块 | 灵活应用 |
| `CASE` 可以返回字符串、数字、计算结果 | 适用于数据分类和计算 |

---

## 3.4 循环结构之LOOP

`LOOP` 循环语句用来重复执行某些语句。`LOOP` 内的语句一直重复执行直到循环被退出（使用 `LEAVE` 子句），跳出循环过程。

`LOOP` 语句的基本格式如下：

```sql
[loop_label:] LOOP
	循环执行的语句
END LOOP [loop_label]
```

其中，`loop_label` 表示 `LOOP` 语句的标注名称，该参数可以省略。

### 🚀 **LOOP 语句的工作原理**
1. `LOOP` 會無限循環執行區塊內的語句。
2. 需要使用 `LEAVE` 來跳出循環，否則會導致無限循環。
3. 可以使用 `loop_label` 來標記循環，方便使用 `LEAVE` 指定要跳出的循環。

### **📝 範例 1：簡單的 LOOP 迴圈**
假設我們希望從 `1` 加到 `10`，並將結果存入變數中：

```sql
DELIMITER $$

CREATE PROCEDURE sum_numbers()
BEGIN
    DECLARE total INT DEFAULT 0;
    DECLARE i INT DEFAULT 1;
    
    loop_label: LOOP
        SET total = total + i;  -- 累加 i
        SET i = i + 1;          -- i 加 1
        
        -- 當 i > 10 時跳出迴圈
        IF i > 10 THEN
            LEAVE loop_label;
        END IF;
    END LOOP loop_label;

    -- 顯示結果
    SELECT total AS SumResult;
END $$

DELIMITER ;
```

#### **📌 執行這個存儲過程**
```sql
CALL sum_numbers();
```
**🔹 結果**
```
+-----------+
| SumResult |
+-----------+
|        55 |
+-----------+
```
這表示 `1 + 2 + ... + 10 = 55`。

### **📝 範例 2：使用 LOOP 插入多條資料**
假設有一個 `students` 表，我們要批量插入 5 名學生：

```sql
DELIMITER $$

CREATE PROCEDURE insert_students()
BEGIN
    DECLARE i INT DEFAULT 1;

    loop_insert: LOOP
        -- 插入一條記錄
        INSERT INTO students (name, age) VALUES (CONCAT('Student', i), 20 + i);

        -- 計數加 1
        SET i = i + 1;

        -- 當 i > 5 時退出迴圈
        IF i > 5 THEN
            LEAVE loop_insert;
        END IF;
    END LOOP loop_insert;

END $$

DELIMITER ;
```

#### **📌 執行存儲過程**
```sql
CALL insert_students();
```
這將在 `students` 表中插入 5 名學生，例如：
```
+----------+-----+
| name     | age |
+----------+-----+
| Student1 |  21 |
| Student2 |  22 |
| Student3 |  23 |
| Student4 |  24 |
| Student5 |  25 |
+----------+-----+
```

---

## 3.5 循环结构之WHILE
在 MySQL 中，`WHILE` 语句用于创建带条件判断的循环。在执行 `WHILE` 语句时，先检查循环条件是否为 `TRUE`，如果是，则执行循环体；否则，退出循环。

### **WHILE 语句的基本格式**
```sql
[while_label:] WHILE 循环条件 DO
    -- 循环体
END WHILE [while_label];
```
其中：
- `while_label`（可选）：用于标记该 `WHILE` 语句，可用于 `LEAVE` 语句提前终止循环。
- `循环条件`：当条件为 `TRUE` 时，继续执行循环；如果为 `FALSE`，退出循环。
- `循环体`：要执行的 SQL 语句块。

### **WHILE 的基本示例**
假设我们要创建一个存储过程，计算从 `1` 加到 `N` 的累加和：

```sql
DELIMITER $$

CREATE PROCEDURE sum_numbers(IN n INT, OUT result INT)
BEGIN
    DECLARE total INT DEFAULT 0;
    DECLARE counter INT DEFAULT 1;

    WHILE counter <= n DO
        SET total = total + counter;
        SET counter = counter + 1; -- 递增计数器，避免死循环
    END WHILE;

    SET result = total;
END $$

DELIMITER ;
```

**使用存储过程**
```sql
CALL sum_numbers(5, @sum_result);
SELECT @sum_result; -- 输出 15，因为 1+2+3+4+5 = 15
```

### **WHILE 结合 LEAVE 语句**
有时候，我们可能需要在循环中手动退出，这可以用 `LEAVE` 语句实现。例如，我们计算从 `1` 到 `10` 的累加和，但是当和大于 `20` 时提前退出：

```sql
DELIMITER $$

CREATE PROCEDURE sum_until_limit()
BEGIN
    DECLARE total INT DEFAULT 0;
    DECLARE counter INT DEFAULT 1;

    sum_loop: WHILE counter <= 10 DO
        SET total = total + counter;

        IF total > 20 THEN
            LEAVE sum_loop; -- 提前退出循环
        END IF;

        SET counter = counter + 1;
    END WHILE;

    SELECT total AS final_sum;
END $$

DELIMITER ;
```

**调用存储过程**
```sql
CALL sum_until_limit();
```
**输出示例**
```
+-----------+
| final_sum |
+-----------+
| 21        |
+-----------+
```
当 `total` 大于 `20`（也就是 `21`）时，循环被 `LEAVE` 提前终止。

### **WHILE 结合 ITERATE**
如果我们想跳过某些循环迭代，可以使用 `ITERATE` 语句。假設我們只累加 `1~N` 之間的偶數，跳過所有奇數：
```sql
DELIMITER $$

CREATE PROCEDURE sum_even_numbers(IN n INT, OUT result INT)
BEGIN
    DECLARE total INT DEFAULT 0;
    DECLARE counter INT DEFAULT 1;

    sum_loop: WHILE counter <= n DO
        IF counter % 2 = 1 THEN
            SET counter = counter + 1;
            ITERATE sum_loop;  -- 跳過當前迭代，進入下一次循環
        END IF;

        SET total = total + counter;
        SET counter = counter + 1;
    END WHILE;

    SET result = total;
END $$

DELIMITER ;
```

**使用存储过程**
```sql
CALL sum_even_numbers(10, @sum_result);
SELECT @sum_result;
```

**結果**
```
+-----------+
| @sum_result |
+-----------+
| 30        | -- (2+4+6+8+10)
+-----------+
```

> **關鍵解析**
> 1. `ITERATE sum_loop;` 這一行會讓程序直接跳過當前迭代，重新回到 `WHILE` 條件判斷處。
> 2. 因為 `counter % 2 = 1` 時代表它是奇數，所以 `ITERATE` 會讓 `WHILE` 直接進入下一次判斷，這樣就只會累加偶數。

---

## 3.6 循环结构之REPEAT
`REPEAT` 语句在 MySQL 存储过程中用于创建循环结构。它与 `WHILE` 语句的主要区别是：

- `REPEAT` 先执行 **循环体** 代码，然后再检查 `UNTIL` 条件是否成立。
- 只要 `UNTIL` 语句中的条件不满足，循环就会继续执行。
- 当 `UNTIL` 语句的条件满足时，循环终止。

可以类比 `do...while` 结构（先执行一次，再判断是否继续）。

### **REPEAT 语法**
```sql
[repeat_label:] REPEAT
    -- 需要重复执行的 SQL 语句
UNTIL 条件
END REPEAT [repeat_label];
```

- `repeat_label`：可选的标签，用于标记循环（可以省略）。
- `循环体`：要重复执行的 SQL 语句。
- `UNTIL 条件`：当满足此条件时，循环终止。

### **REPEAT 语句示例**
#### **示例 1：计算 1 到 10 的累加和**
```sql
DELIMITER $$

CREATE PROCEDURE SumNumbers()
BEGIN
    DECLARE total INT DEFAULT 0;
    DECLARE i INT DEFAULT 1;

    REPEAT
        SET total = total + i;
        SET i = i + 1;
    UNTIL i > 10  -- 当 i 超过 10 时，结束循环
    END REPEAT;

    SELECT total;  -- 输出 1+2+3+...+10 的结果
END $$

DELIMITER ;
```
**执行存储过程**
```sql
CALL SumNumbers();
```
**输出**
```
+-------+
| total |
+-------+
|    55 |
+-------+
```
**解释**
1. `i` 从 `1` 开始，每次循环 `total` 累加 `i`，然后 `i+1`。
2. 当 `i > 10` 时，`UNTIL` 条件满足，循环终止。
3. 计算 `1+2+3+...+10` 的结果 `55`。

#### **示例 2：倒计时输出从 5 到 1**
```sql
DELIMITER $$

CREATE PROCEDURE Countdown()
BEGIN
    DECLARE n INT DEFAULT 5;
    
    REPEAT
        SELECT n;
        SET n = n - 1;
    UNTIL n = 0  -- 直到 n 变为 0 时结束
    END REPEAT;

END $$

DELIMITER ;
```
**执行存储过程**
```sql
CALL Countdown();
```
**输出**
```
+---+
| n |
+---+
| 5 |
| 4 |
| 3 |
| 2 |
| 1 |
+---+
```
**解释**
1. `n` 初始值为 `5`，每次循环 `SELECT n` 并 `n - 1`。
2. 当 `n = 0` 时，循环终止。

#### **示例 3：寻找第一个能被 7 整除的随机数**
```sql
DELIMITER $$

CREATE PROCEDURE FindDivisibleBy7()
BEGIN
    DECLARE rand_num INT;
    
    REPEAT
        SET rand_num = FLOOR(RAND() * 100);  -- 生成 0~99 之间的随机数
    UNTIL rand_num % 7 = 0  -- 直到找到一个能被 7 整除的数
    END REPEAT;

    SELECT rand_num AS '找到的数';
END $$

DELIMITER ;
```
**执行存储过程**
```sql
CALL FindDivisibleBy7();
```
**输出示例**
```
+--------+
| 找到的数 |
+--------+
|     21 |
+--------+
```
**解释**
1. `RAND()` 生成 0~99 的随机数，使用 `FLOOR()` 取整数部分。
2. `UNTIL rand_num % 7 = 0`，找到能被 7 整除的数后终止。

### **总结**
- `REPEAT` **先执行一次**，再判断 `UNTIL` 是否满足。
- 适用于 **执行一次后需要判断是否继续** 的情况，如累加、倒计时、查找符合条件的数值等。
- `UNTIL` **条件满足即退出**，与 `WHILE` 需要先判断条件不同。

---

## 3.7 对比三种循环结构：
以下是 MySQL 中三种循环结构 (`LOOP`、`WHILE`、`REPEAT`) 的对比总结：

| 循环结构 | 语法 | 运行逻辑 | 何时使用 |
|---------|------|---------|---------|
| **LOOP** | `LOOP... LEAVE... END LOOP;` | **无条件循环**，需要 `LEAVE` 语句主动退出 | 适用于 **必须至少执行一次** 且 **手动控制退出** 的情况 |
| **WHILE** | `WHILE 条件 DO... END WHILE;` | **先判断条件**，满足条件才执行循环体，否则跳出 | 适用于 **可能不会执行**（如果一开始条件不满足）的循环 |
| **REPEAT** | `REPEAT... UNTIL 条件 END REPEAT;` | **先执行一次**，然后判断 `UNTIL` 条件是否满足，满足则退出，否则继续 | 适用于 **至少执行一次**，直到满足条件才退出 |

### **代码示例**
#### **1. LOOP 示例：累加 1 到 10**
```sql
DELIMITER $$

CREATE PROCEDURE LoopExample()
BEGIN
    DECLARE total INT DEFAULT 0;
    DECLARE i INT DEFAULT 1;

    my_loop: LOOP
        SET total = total + i;
        SET i = i + 1;

        IF i > 10 THEN
            LEAVE my_loop;  -- 退出循环
        END IF;
    END LOOP;

    SELECT total;
END $$

DELIMITER ;
```

#### **2. WHILE 示例：累加 1 到 10**
```sql
DELIMITER $$

CREATE PROCEDURE WhileExample()
BEGIN
    DECLARE total INT DEFAULT 0;
    DECLARE i INT DEFAULT 1;

    WHILE i <= 10 DO
        SET total = total + i;
        SET i = i + 1;
    END WHILE;

    SELECT total;
END $$

DELIMITER ;
```

#### **3. REPEAT 示例：累加 1 到 10**
```sql
DELIMITER $$

CREATE PROCEDURE RepeatExample()
BEGIN
    DECLARE total INT DEFAULT 0;
    DECLARE i INT DEFAULT 1;

    REPEAT
        SET total = total + i;
        SET i = i + 1;
    UNTIL i > 10  -- 退出条件
    END REPEAT;

    SELECT total;
END $$

DELIMITER ;
```

### **选择何种循环结构**
- **如果你不确定循环何时结束（如无限循环），手动控制退出：用 `LOOP`**。
- **如果你希望在开始时检查条件，可能不执行：用 `WHILE`**。
- **如果你希望至少执行一次，再检查是否退出：用 `REPEAT`**。

---

## 3.8 跳转语句之LEAVE语句
在 MySQL 中，`LEAVE` 语句用于跳出循环或者 `BEGIN ... END` 代码块（也称为程序体）。你可以将 `LEAVE` 视为类似于 C 语言或 JavaScript 中的 `break`，用于提前终止 `LOOP`、`WHILE` 或 `REPEAT` 语句。

### **LEAVE 使用场景**
1. **用于 LOOP 循环**
2. **用于 WHILE 循环**
3. **用于 REPEAT 循环**
4. **用于 BEGIN ... END 代码块**

### **LEAVE 的基本使用**
语法：
```sql
LEAVE label;
```
- `label`：是循环或 `BEGIN ... END` 代码块的标签（标记名）。
- `LEAVE label;` 表示跳出 `label` 标记的循环或代码块。

### **案例 1：使用 LEAVE 跳出 LOOP**
`LOOP` 语句是一种无限循环，通常需要 `LEAVE` 来终止它。

```sql
DELIMITER //

CREATE PROCEDURE test_loop()
BEGIN
    DECLARE counter INT DEFAULT 0;  -- 定义计数器
    my_loop: LOOP
        SET counter = counter + 1;
        IF counter >= 5 THEN
            LEAVE my_loop;  -- 当 counter 大于等于 5 时，跳出循环
        END IF;
        SELECT counter;  -- 打印当前 counter 值
    END LOOP;
END //

DELIMITER ;

CALL test_loop();  -- 调用存储过程
```

**执行结果**
```
1
2
3
4
5
```
**解释**
1. `LOOP` 进入无限循环，每次 `counter + 1`。
2. 当 `counter >= 5` 时，执行 `LEAVE my_loop;`，跳出循环。

### **案例 2：使用 LEAVE 跳出 WHILE**
```sql
DELIMITER //

CREATE PROCEDURE test_while()
BEGIN
    DECLARE counter INT DEFAULT 0;
    my_while: WHILE counter < 5 DO
        SET counter = counter + 1;
        SELECT counter;
        IF counter = 3 THEN
            LEAVE my_while;  -- 当 counter = 3 时跳出循环
        END IF;
    END WHILE;
END //

DELIMITER ;

CALL test_while();
```

**执行结果**
```
1
2
3
```
**解释**
1. `WHILE` 循环从 `0` 开始，每次 `counter + 1`。
2. 当 `counter = 3` 时，`LEAVE my_while;` 终止循环。

### **案例 3：使用 LEAVE 跳出 REPEAT**
```sql
DELIMITER //

CREATE PROCEDURE test_repeat_leave()
BEGIN
    DECLARE counter INT DEFAULT 0;
    my_repeat: REPEAT
        SET counter = counter + 1;
        SELECT counter;
        
        -- 当 counter = 3 时提前跳出 REPEAT 循环
        IF counter = 3 THEN
            LEAVE my_repeat;
        END IF;
        
    UNTIL counter = 5 END REPEAT my_repeat; -- 本来会执行到 counter = 5，但 LEAVE 让它提前终止
END //

DELIMITER ;

CALL test_repeat_leave();
```

**执行结果**
```
1
2
3
```
**解释**
1. `REPEAT` 结构会 **先执行代码**，然后检查 `UNTIL` 是否满足。
2. 但在 `counter = 3` 时，`IF` 语句执行 `LEAVE my_repeat;`，提前跳出 `REPEAT`。
3. 因此，循环 **不会执行到 5，而是在 3 时结束**。

### **案例 4：使用 LEAVE 退出 BEGIN ... END 代码块**
有时 `BEGIN ... END` 代码块需要提前退出，可以使用 `LEAVE`。

```sql
DELIMITER //

CREATE PROCEDURE test_begin_leave()
BEGIN
    DECLARE counter INT DEFAULT 0;
    my_block: BEGIN
        SET counter = counter + 1;
        SELECT 'Start Block' AS message;
        
        IF counter = 1 THEN
            LEAVE my_block;  -- 直接跳出代码块
        END IF;
        
        SELECT 'This will not be executed' AS message;
    END my_block;
    
    SELECT 'Block exited' AS message;
END //

DELIMITER ;

CALL test_begin_leave();
```

**执行结果**
```
message
------------
Start Block
Block exited
```
**解释**
1. 代码块 `BEGIN ... END` 运行后 `counter+1`。
2. 当 `counter = 1` 时，`LEAVE my_block;` 立即跳出代码块。
3. `SELECT 'This will not be executed';` 不会执行。


### **总结**
- `LEAVE` 适用于 **`LOOP`、`WHILE`、`REPEAT`、`BEGIN ... END`**。
- `LEAVE label;` 会终止对应 `label` 标记的代码块或循环。
- `LOOP` 一般需要 `LEAVE`，否则会变成无限循环。
- `WHILE` 和 `REPEAT` 通常可用 `IF ... LEAVE` 提前终止。

---

## 3.9 跳转语句之ITERATE语句
### 📌 **ITERATE 语句解析**
在 MySQL 的存储过程或存储函数中，`ITERATE` 语句用于控制流程，专门用于**循环语句（LOOP、REPEAT、WHILE）**内。它的作用类似于编程语言中的 `continue` 语句，即**跳过本次循环的剩余部分，直接重新执行循环**。

### **📖 语法**
```sql
ITERATE loop_label;
```
- `loop_label`：循环的标签，标记循环块。
- `ITERATE loop_label;` 表示**直接跳转到该循环的开头**，而不是执行循环剩余的部分。

### **📌 示例 1：使用 `ITERATE` 计算 1-10 之间的偶数和**
在这个例子中，我们使用 `LOOP` 语句循环 1 到 10，遇到奇数时直接 `ITERATE` 跳过，最终计算偶数之和。

```sql
DELIMITER $$

CREATE PROCEDURE sum_even_numbers()
BEGIN
    DECLARE num INT DEFAULT 0;
    DECLARE total INT DEFAULT 0;

    loop_label: LOOP
        SET num = num + 1;

        -- 如果 num 是奇数，则跳过后续代码，直接重新开始循环
        IF num % 2 = 1 THEN
            ITERATE loop_label;
        END IF;

        -- 只有偶数才会执行这行代码
        SET total = total + num;

        -- 终止循环条件
        IF num >= 10 THEN
            LEAVE loop_label;
        END IF;
    END LOOP;

    SELECT total AS even_sum;
END $$

DELIMITER ;

-- 调用存储过程
CALL sum_even_numbers();
```

✅ **运行结果**
```
+----------+
| even_sum |
+----------+
|       30 |
+----------+
```
**解释**
- `num` 依次递增。
- `IF num % 2 = 1 THEN ITERATE loop_label;` ：如果 `num` 是奇数，则直接跳到 `LOOP` 开头，跳过 `SET total = total + num;`。
- 只计算 `2+4+6+8+10=30`。

### **📌 示例 2：使用 `ITERATE` 过滤特定值**
假设我们想从 1 到 10 之间**跳过 5 和 7**，然后将剩下的数字输出：

```sql
DELIMITER $$

CREATE PROCEDURE skip_five_and_seven()
BEGIN
    DECLARE num INT DEFAULT 0;

    loop_label: LOOP
        SET num = num + 1;

        -- 遇到 5 或 7 时跳过
        IF num = 5 OR num = 7 THEN
            ITERATE loop_label;
        END IF;

        -- 输出当前数值
        SELECT num;

        -- 终止循环
        IF num >= 10 THEN
            LEAVE loop_label;
        END IF;
    END LOOP;
END $$

DELIMITER ;

-- 调用存储过程
CALL skip_five_and_seven();
```

✅ **运行结果**
```
+------+
| num  |
+------+
|    1 |
|    2 |
|    3 |
|    4 |
|    6 |
|    8 |
|    9 |
|   10 |
+------+
```
**解释**
- `num = 5` 或 `num = 7` 时，直接 `ITERATE loop_label;`，所以 `5` 和 `7` 没有被 `SELECT` 输出。
- 其余数字正常输出。

### **📌 示例 3：使用 `WHILE` 语句结合 `ITERATE`**
这个例子实现从 `1` 计算到 `10`，但是遇到 `5` 时跳过。

```sql
DELIMITER $$

CREATE PROCEDURE while_iterate_example()
BEGIN
    DECLARE num INT DEFAULT 0;

    loop_label: WHILE num < 10 DO
        SET num = num + 1;

        -- 遇到 5 直接跳过
        IF num = 5 THEN
            ITERATE loop_label;
        END IF;

        -- 输出当前数值
        SELECT num;
    END WHILE;
END $$

DELIMITER ;

-- 调用存储过程
CALL while_iterate_example();
```

✅ **运行结果**
```
+------+
| num  |
+------+
|    1 |
|    2 |
|    3 |
|    4 |
|    6 |
|    7 |
|    8 |
|    9 |
|   10 |
+------+
```

### **🔍 总结**
- `ITERATE` **只能用于循环 (`LOOP`、`WHILE`、`REPEAT`)** 语句内。
- 作用类似于 `continue`，直接回到循环开头，不执行循环内后续的代码。
- 可以用于**跳过特定值、过滤数据、优化循环逻辑**等场景。

---

# 4. 游标

## 4.1 什么是游标（或光标）

虽然我们也可以通过筛选条件 WHERE 和 HAVING，或者是限定返回记录的关键字 LIMIT 返回一条记录，但是，却无法在结果集中像指针一样，向前定位一条记录、向后定位一条记录，或者是`随意定位到某一条记录`，并对记录的数据进行处理。

这个时候，就可以用到游标。游标，提供了一种灵活的操作方式，让我们能够对结果集中的每一条记录进行定位，并对指向的记录中的数据进行操作的数据结构。**游标让 SQL 这种面向集合的语言有了面向过程开发的能力。**

在 SQL 中，游标是一种临时的数据库对象，可以指向存储在数据库表中的数据行指针。这里游标`充当了指针的作用`，我们可以通过操作游标来对数据行进行操作。

MySQL中游标可以在存储过程和函数中使用。

比如，我们查询了 employees 数据表中工资高于15000的员工都有哪些：

```sql
SELECT
	employee_id,
	last_name,
	salary
FROM
	employees
WHERE
	salary > 15000;
```

 ![image-20211111182656990](images/image-20211111182656990.png)

这里我们就可以通过游标来操作数据行，如图所示此时游标所在的行是“108”的记录，我们也可以在结果集上滚动游标，指向结果集中的任意一行。

## 4.2 使用游标步骤
游标（Cursor）是 MySQL 中用于逐行处理查询结果的机制，通常用于存储过程 (Stored Procedure) 中。它适用于当我们需要对查询返回的结果集进行逐行处理，而不是一次性获取所有数据的场景。

### **1. 声明游标**
> 在存储过程中，我们使用 `DECLARE cursor_name CURSOR FOR` 语法来声明游标，并指定查询语句。

在MySQL中，使用DECLARE关键字来声明游标，其语法的基本形式如下：

```sql
DECLARE cursor_name CURSOR FOR select_statement; 
```

这个语法适用于 MySQL，SQL Server，DB2 和 MariaDB。如果是用 Oracle 或者 PostgreSQL，需要写成：

```sql
DECLARE cursor_name CURSOR IS select_statement;
```

要使用 SELECT 语句来获取数据结果集，而此时还没有开始遍历数据，这里 select_statement 代表的是 SELECT 语句，返回一个用于创建游标的结果集。

#### **示例**
比如我们要声明一个游标 `cur_emp`，用于存储 `employees` 表中的 `employee_id` 和 `salary` 两列：

```sql
DECLARE cur_emp CURSOR FOR 
SELECT employee_id, salary FROM employees;
```
这个查询会选取 `employee_id` 和 `salary` 两列，存入游标 `cur_emp`，以便后续逐行读取。

### **2. 打开游标**
> 游标在使用前必须先打开

打开游标的语法如下：

```sql
OPEN cursor_name
```
当我们定义好游标之后，如果想要使用游标，必须先打开游标。打开游标的时候 SELECT 语句的查询结果集就会送到游标工作区，为后面游标的`逐条读取`结果集中的记录做准备。

#### **示例**
我们使用 `OPEN` 打开游标 `cur_emp`：

```sql
OPEN cur_emp;
```
这会将 `SELECT employee_id, salary FROM employees;` 的查询结果存入游标缓冲区。

### **3. 读取游标中的数据**
语法如下：

```sql
FETCH cursor_name INTO var_name [, var_name] ...
```

这句的作用是使用 cursor_name 这个游标来读取当前行，并且将数据保存到 var_name 这个变量中，游标指针指到下一行。如果游标读取的数据行有多个列名，则在 INTO 关键字后面赋值给多个变量名即可。

注意：var_name 必须在声明游标之前就定义好。


#### **示例**
我们使用 `FETCH` 语句逐行读取游标 `cur_emp` 中的数据：

```sql
FETCH cur_emp INTO emp_id, emp_sal;
```
- `emp_id` 和 `emp_sal` 是我们提前声明的变量。
- 每次 `FETCH` 语句执行时，游标会向下移动一行，读取当前行的数据。

> **注意：** 读取的列数必须与 `INTO` 变量的数量一致，否则会报错。

### **4. 关闭游标**
> 当游标使用完毕后，我们需要关闭它，以释放系统资源

语法如下：
```sql
CLOSE cursor_name
```

有 OPEN 就会有 CLOSE，也就是打开和关闭游标。当我们使用完游标后需要关闭掉该游标。因为游标会`占用系统资源`，如果不及时关闭，**游标会一直保持到存储过程结束**，影响系统运行的效率。而关闭游标的操作，会释放游标占用的系统资源。

关闭游标之后，我们就不能再检索查询结果中的数据行，如果需要检索只能再次打开游标。

#### **示例**
我们使用 `CLOSE` 关闭游标 `cur_emp`：
```sql
CLOSE cur_emp;
```
关闭后，游标将无法再读取数据，如需再次访问，需要重新 `OPEN`。

---

## 4.3 举例
**假设 `employees` 表的结构如下：**
```sql
CREATE TABLE employees (
    employee_id INT PRIMARY KEY,
    name VARCHAR(50),
    salary DECIMAL(10,2)
);

INSERT INTO employees (employee_id, name, salary) VALUES 
(1, 'Alice', 5000),
(2, 'Bob', 6000),
(3, 'Charlie', 7000);
```

**存储过程使用游标逐行读取 `employees` 表的内容**
```sql
DELIMITER $$

CREATE PROCEDURE process_employees()
BEGIN
    DECLARE emp_id INT;
    DECLARE emp_sal DECIMAL(10,2);
    
    -- 声明游标
    DECLARE cur_emp CURSOR FOR 
    SELECT employee_id, salary FROM employees;

    -- 打开游标
    OPEN cur_emp;

    -- 逐行读取游标
    loop_label: LOOP
        FETCH cur_emp INTO emp_id, emp_sal;
        
        -- 退出循环的条件：游标到达最后一行
        IF emp_id IS NULL THEN
            LEAVE loop_label;
        END IF;

        -- 这里可以对数据进行处理，比如输出或计算
        SELECT CONCAT('员工ID: ', emp_id, '，薪资: ', emp_sal) AS EmployeeInfo;
    END LOOP;

    -- 关闭游标
    CLOSE cur_emp;
END$$

DELIMITER ;
```

**运行存储过程**
```sql
CALL process_employees();
```
### **关键点解析**
1. **为什么要用 `LOOP` 循环？**
   - 因为 `FETCH` 语句一次只读取一行，通常需要在循环中反复调用 `FETCH` 处理所有数据。

2. **如何检测游标读取完成？**
   - 这里使用 `IF emp_id IS NULL THEN LEAVE loop_label;` 退出循环。
   - 另一种方式是 **使用 `DECLARE CONTINUE HANDLER` 处理 `NOT FOUND` 情况**（见下个示例）。

### **改进版：使用 `CONTINUE HANDLER` 处理结束**
```sql
DELIMITER $$

CREATE PROCEDURE process_employees_v2()
BEGIN
    DECLARE emp_id INT;
    DECLARE emp_sal DECIMAL(10,2);
    DECLARE done INT DEFAULT 0;

    -- 声明游标
    DECLARE cur_emp CURSOR FOR 
    SELECT employee_id, salary FROM employees;

    -- 处理游标结束情况
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 1;

    -- 打开游标
    OPEN cur_emp;

    loop_label: LOOP
        FETCH cur_emp INTO emp_id, emp_sal;

        -- 当 done = 1 时，表示游标到达末尾
        IF done = 1 THEN 
            LEAVE loop_label; 
        END IF;

        -- 这里可以对数据进行处理，比如输出或计算
        SELECT CONCAT('员工ID: ', emp_id, '，薪资: ', emp_sal) AS EmployeeInfo;
    END LOOP;

    -- 关闭游标
    CLOSE cur_emp;
END$$

DELIMITER ;
```

**执行存储过程**
```sql
CALL process_employees_v2();
```

### **总结**
| 步骤 | 语法 | 作用 |
|------|------|------|
| **1. 声明游标** | `DECLARE cursor_name CURSOR FOR select_statement;` | 定义游标，指定查询语句 |
| **2. 打开游标** | `OPEN cursor_name;` | 执行查询，将结果存入游标 |
| **3. 读取数据** | `FETCH cursor_name INTO var_name [, var_name] ...;` | 逐行读取数据到变量 |
| **4. 关闭游标** | `CLOSE cursor_name;` | 释放游标占用的资源 |

### **何时使用游标？**
- 需要 **逐行** 处理查询结果时（如计算某些值）。
- 无法使用 **JOIN** 或 **GROUP BY** 直接完成任务。
- 需要在查询数据时进行额外的逻辑处理（如更新、删除）。

---

## 4.5 小结

游标是 MySQL 的一个重要的功能，为`逐条读取`结果集中的数据，提供了完美的解决方案。跟在应用层面实现相同的功能相比，游标可以在存储程序中使用，效率高，程序也更加简洁。

但同时也会带来一些性能问题，比如在使用游标的过程中，会对数据行进行`加锁`，这样在业务并发量大的时候，不仅会影响业务之间的效率，还会`消耗系统资源`，造成内存不足，这是因为游标是在内存中进行的处理。

建议：养成用完之后就关闭的习惯，这样才能提高系统的整体效率。



# 8. 补充
## MySQL 8.0的新特性—全局变量的持久化
在 **MySQL 8.0** 之前，使用 `SET GLOBAL` 設置全局變量時，該變量的值 **只在當前 MySQL 服務器運行期間生效**，但 **重啟 MySQL 後就會恢復為默認值** 或是 `my.cnf` 配置文件中的值。

而 **MySQL 8.0 引入了 `SET PERSIST`**，允許你 **永久存儲變量的修改**，即使 **重啟 MySQL 也能保留設置**。這個新特性解決了 `SET GLOBAL` 的 **重啟後失效** 問題。

### **1. `SET GLOBAL` vs `SET PERSIST`**
| 設置方式 | 生效範圍 | 影響時間 | 是否能跨重啟保留 |
|----------|----------|----------|----------------|
| `SET GLOBAL` | 當前運行的 MySQL 服務 | 立即生效 | **不能**，重啟後恢復默認 |
| `SET PERSIST` | 當前運行的 MySQL 服務 | 立即生效 | **可以**，重啟後仍然有效 |

### **2. `SET PERSIST` 的作用**
當你執行：
```sql
SET PERSIST max_connections = 1000;
```
MySQL 會將這個配置 **存儲到 `mysqld-auto.cnf` 文件**（通常在 MySQL 數據目錄 `/var/lib/mysql` 下），這樣 **下次重啟時仍然會讀取這個值**，而不會恢復為默認值。

### **3. 示例對比**
#### **(1) `SET GLOBAL` 設置的變量會在重啟後消失**
```sql
SET GLOBAL max_connections = 1000;
```
- **立即生效**
- **重啟 MySQL 後恢復為默認值（151）**

#### **(2) `SET PERSIST` 設置的變量能跨重啟保留**
```sql
SET PERSIST max_connections = 1000;
```
- **立即生效**
- **重啟 MySQL 後依然保持為 `1000`**

### **4. `SET PERSIST_ONLY`**
MySQL 8.0 還引入了 `SET PERSIST_ONLY`，它與 `SET PERSIST` 相似，但 **不會影響當前運行的 MySQL 變量值**，而是 **只影響下一次啟動後的值**。

#### **示例**
```sql
SET PERSIST_ONLY max_connections = 2000;
```
- **當前 max_connections 還是原來的值**
- **下一次重啟後，max_connections 才變為 2000**

### **5. 如何刪除 `PERSIST` 設置**
如果你不想讓 `max_connections = 1000` 在重啟後生效，可以使用：
```sql
RESET PERSIST max_connections;
```
或者刪除 **所有持久化變量**：
```sql
RESET PERSIST;
```

### **6. `mysqld-auto.cnf` 文件**
當使用 `SET PERSIST` 設置變量後，MySQL 會將變量存入 `mysqld-auto.cnf` 文件，例如：
```json
{
  "max_connections": 1000
}
```
這個文件 **位於 MySQL 數據目錄**，MySQL 重啟時會讀取這個文件來應用變更。

### **7. 總結**
| 方式 | 立即生效 | 重啟後保留 | 存儲位置 |
|------|--------|---------|--------|
| `SET GLOBAL` | ✅ 是 | ❌ 否 | 內存 |
| `SET PERSIST` | ✅ 是 | ✅ 是 | `mysqld-auto.cnf` |
| `SET PERSIST_ONLY` | ❌ 否（重啟後才生效） | ✅ 是 | `mysqld-auto.cnf` |

這個 `SET PERSIST` 功能 **避免了每次重啟都要修改 my.cnf 配置文件的麻煩**，適合在 MySQL 運行時調整配置，並希望修改能夠保留到下一次重啟。

---