# 1.索引的声明与使用

## 1.1索引的分类
> MySQL的索引包括普通索引、唯一性索引、全文索引、单列索引、多列索引和空间索引等。

- 从`功能逻辑`上说，索引主要有 4 种，分别是普通索引、唯一索引、主键索引、全文索引。
- 按照`物理实现方式`，索引可以分为 2 种：聚簇索引和非聚簇索引。
- 按照`作用字段个数`进行划分，分成单列索引和联合索引。

### 普通索引（Normal Index）

> 在创建普通索引时，不附加任何限制条件，只是用于提高查询效率。这类索引可以创建在 **任何数据类型** 上，其值是否唯一和非空，要由字段本身的完整性约束条件决定。

普通索引不會對欄位的唯一性或非空性進行強制要求，因此它適合用來加快查詢速度，而不是作為資料完整性的保證工具。這種索引適合那些查詢頻繁，但值可能重複的欄位。例如學生的姓名、地址、城市等。

當我們對某個欄位建立了普通索引後，MySQL 在執行包含該欄位的查詢時，會優先考慮使用該索引進行查找，從而提高查詢效率。

---

#### 範例說明

##### 1. 建立資料表 `student`

```sql
CREATE TABLE student (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(100),
    age INT,
    gender ENUM('M', 'F'),
    address VARCHAR(255)
);
```

##### 2. 在 `name` 欄位上建立普通索引

```sql
CREATE INDEX idx_name ON student(name);
```

這裡 `idx_name` 是索引的名稱，`name` 是被加索引的欄位。這個索引不會限制 `name` 是否唯一，也不會強制其非空，只是用來加速查詢。

##### 3. 使用索引的查詢方式

```sql
SELECT * FROM student WHERE name = '王小明';
```

當你查詢某個特定名字的學生時，由於 `name` 欄位有普通索引，MySQL 將會優先考慮使用 `idx_name` 索引來加快查詢速度，避免全表掃描。

---

#### 🔍 注意事項

- 普通索引 **不保證唯一性**，若你希望索引的欄位不重複，應使用 `UNIQUE INDEX`。
- 雖然建立索引可以提升查詢效率，但同時也會略微增加插入（INSERT）、更新（UPDATE）、刪除（DELETE）操作的成本，因為資料異動時需要同步更新索引。
- 索引應該建立在「查詢頻繁但重複值較少」的欄位上，才會有較高的查詢效率提升效果。

---

### 唯一性索引（Unique Index）

> 使用 `UNIQUE` 参数可以设置索引为唯一性索引，在创建唯一性索引时，限制该索引的值必须是唯一的，但允许存在空值（NULL）。在一张数据表里可以有多个唯一性索引。

唯一性索引的主要作用是防止資料表中出現重複的值。它常用於對於具有唯一特徵的欄位，例如：電子郵件信箱（email）、身分證字號、手機號碼、員工工號等等。

使用唯一性索引除了加速查詢外，還可作為資料的完整性約束，避免插入或更新重複值。

---

#### 範例說明

##### 1. 建立資料表 `student`

```sql
CREATE TABLE student (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(100),
    email VARCHAR(100),
    age INT
);
```

##### 2. 為 `email` 欄位建立唯一性索引

```sql
CREATE UNIQUE INDEX idx_email ON student(email);
```

這裡 `idx_email` 是索引名稱，透過 `UNIQUE` 關鍵字表示這是一個唯一性索引，`email` 欄位的每一筆值 **不能重複**。

---

### 主鍵索引（Primary Key Index）

> 主鍵索引是一種 **特殊的唯一性索引（UNIQUE INDEX）**，在唯一索引的基礎上**額外增加了「不為空」（NOT NULL）**的約束條件，因此主鍵欄位的值具有「**唯一且不可為空**」的特性。

> 一張表中 **只能有一個主鍵索引**。這是由其底層的 **物理存儲實現** 決定的，因為資料在磁碟中只能依據 **一種順序（通常是主鍵順序）** 來進行聚簇存儲（InnoDB 的聚簇索引實現）。

---

#### 特性總結

| 條件 | 唯一索引（UNIQUE） | 主鍵索引（PRIMARY KEY） |
|------|-------------------|------------------------|
| 唯一性 | ✅ | ✅ |
| 不可為 NULL | ❌（允許多個 NULL） | ✅（絕對不允許 NULL） |
| 數量限制 | 多個 | 最多一個 |
| 作為聚簇索引依據（InnoDB） | ❌ | ✅ |

---

#### 範例說明

##### 1. 建立學生表 `student`，以 `id` 作為主鍵

```sql
CREATE TABLE student (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(100),
    email VARCHAR(100),
    age INT
);
```

這裡 `id` 是主鍵（PRIMARY KEY）欄位，自動成為主鍵索引：

- `id` 不能為 NULL
- `id` 的值必須唯一
- MySQL InnoDB 引擎會用 `id` 值的順序作為聚簇索引，實際儲存資料的排序順序也會依照 `id`

##### ✅ 插入唯一且不為空的主鍵值（成功）

```sql
INSERT INTO student (name, email, age)
VALUES ('王小明', 'xiaoming@example.com', 20); -- 自動產生 id = 1
```

##### ❌ 插入重複的主鍵值（失敗）

```sql
INSERT INTO student (id, name, email, age)
VALUES (1, '陳小華', 'xiaohua@example.com', 22);
```

**錯誤訊息：**
```text
ERROR 1062 (23000): Duplicate entry '1' for key 'PRIMARY'
```

##### ❌ 插入主鍵為 NULL（失敗）

```sql
INSERT INTO student (id, name, email, age)
VALUES (NULL, '林小安', 'xiaoan@example.com', 21);
```

如果不是 `AUTO_INCREMENT` 的欄位，這樣會報錯；若是 `AUTO_INCREMENT`，則會自動填補數字。

---

#### 補充：如何在建立表後補加主鍵？

```sql
ALTER TABLE student ADD PRIMARY KEY (id);
```

---

#### 為什麼一張表只能有一個主鍵？

- 因為 **主鍵會作為聚簇索引的基礎**。
- 在 InnoDB 中，資料實際是依據主鍵的值順序來儲存的，因此資料檔案只能用一種順序排列。
- 如果允許多個主鍵索引，就會有矛盾 —— 資料到底該依照哪一個欄位順序來存？

---

### 單列索引（Single-Column Index）

> 單列索引是指在資料表中的 **單個欄位（字段）** 上建立的索引。該索引只針對該欄位建立索引結構，不能同時作用於多個欄位。

單列索引根據索引類型的不同，可以是：
- **普通索引**（加快查詢速度）
- **唯一性索引**（加快查詢速度 + 限制值唯一）
- **全文索引**（用於文字搜尋）

🧠 **注意：** 一張資料表中可以建立多個單列索引，只要這些索引各自對應一個不同欄位即可。

---

#### 📌 特性簡要

| 索引類型 | 是否允許重複值 | 是否可為空 | 適用場景 |
|----------|----------------|------------|-----------|
| 普通索引 | ✅ | ✅ | 查詢加速 |
| 唯一索引 | ❌ | ✅（允許多個 NULL） | 限制資料唯一性 |
| 全文索引 | ✅ | ✅ | 模糊全文搜尋（InnoDB 5.6+） |

---

#### 範例說明

##### 1️⃣ 建立資料表 `student`

```sql
CREATE TABLE student (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(100),
    email VARCHAR(100),
    age INT,
    bio TEXT
);
```

---

#### 2️⃣ 建立各類型的單列索引

##### 📌 普通索引（在 `name` 欄位）

```sql
CREATE INDEX idx_name ON student(name);
```

適用於依照 `name` 查詢時加快速度：

```sql
SELECT * FROM student WHERE name = '王小明';
```

---

##### 📌 唯一性索引（在 `email` 欄位）

```sql
CREATE UNIQUE INDEX idx_email ON student(email);
```

此索引會強制 `email` 不可重複，但可以為 `NULL`：

```sql
INSERT INTO student (name, email, age) VALUES ('李小華', 'a@example.com', 20); -- ✅
INSERT INTO student (name, email, age) VALUES ('王小明', 'a@example.com', 21); -- ❌ 重複報錯
```

---

##### 📌 全文索引（在 `bio` 欄位）

（適用於 InnoDB 引擎且版本 >= 5.6）

```sql
CREATE FULLTEXT INDEX idx_bio ON student(bio);
```

可用於全文搜尋：

```sql
SELECT * FROM student WHERE MATCH(bio) AGAINST('喜歡編程');
```

---

#### 🔍 單列索引適用場景

- 使用者名稱、信箱、手機號碼這類**獨立特徵**：使用「唯一索引」保證唯一性。
- 頻繁查詢但值可能重複的欄位，如「城市」、「姓名」：使用「普通索引」提升效率。
- 大量文本內容搜尋，例如「文章內容」或「使用者自介」：使用「全文索引」。

---

#### ❓補充問答

##### Q：可以為同一張表的不同欄位建立多個單列索引嗎？

✅ 可以。例如：

```sql
CREATE INDEX idx_age ON student(age);
CREATE INDEX idx_gender ON student(gender);
```

---

### 多列索引（Composite / Multi-Column / 联合索引）

> 多列索引是針對**多個欄位的組合**建立的一個索引，用來加快多欄位條件查詢的效率。MySQL 會將這些欄位組合起來，當作一個索引鍵值存入 B+ 樹結構中。

📌 重點：**多列索引 ≠ 多個單列索引**  
它只建立一棵索引樹，根據欄位組合而非分開索引。

---

#### ✅ 語法範例

假設有以下資料表：

```sql
CREATE TABLE student (
    id INT,
    name VARCHAR(100),
    gender ENUM('M', 'F'),
    age INT,
    PRIMARY KEY (id)
);
```

你可以為 `id`、`name`、`gender` 三個欄位建立一個多列索引：

```sql
CREATE INDEX idx_id_name_gender ON student(id, name, gender);
```

這樣就會建立一個覆蓋三個欄位順序的複合索引。

---

#### 🔍 最左前綴原則（Leftmost Prefix）

MySQL 使用多列索引時，**必須從索引中定義的第一個欄位開始查找**，才會使用該索引。否則，即使你查的是索引中其他欄位，MySQL 也不會使用該索引！

##### 使用多列索引的條件：

| 查詢條件 | 是否使用 `idx_id_name_gender` 索引 | 說明 |
|----------|--------------------------|------|
| `WHERE id = 1` | ✅ | 使用第一欄位 |
| `WHERE id = 1 AND name = '王小明'` | ✅ | 使用前兩欄位 |
| `WHERE id = 1 AND name = '王小明' AND gender = 'M'` | ✅ | 使用全部欄位 |
| `WHERE name = '王小明'` | ❌ | 不符合最左前綴，無法使用索引 |
| `WHERE gender = 'M'` | ❌ | 不符合最左前綴，無法使用索引 |
| `WHERE name = '王小明' AND gender = 'M'` | ❌ | 跳過第一欄位 `id`，索引無效 |

✅ **只有從第一欄位開始，並按照順序連續使用時，索引才會生效。**

---

#### 📈 查詢範例與解釋

```sql
-- 使用索引：只查 id
SELECT * FROM student WHERE id = 1001;

-- 使用索引：查 id + name
SELECT * FROM student WHERE id = 1001 AND name = '王小明';

-- 使用索引：查 id + name + gender（最佳使用情境）
SELECT * FROM student WHERE id = 1001 AND name = '王小明' AND gender = 'M';

-- 不使用索引：只查 name，會全表掃描
SELECT * FROM student WHERE name = '王小明';
```

---

#### ✅ 補充：覆蓋索引（Covering Index）

若查詢中使用的欄位全部包含在某個索引中，MySQL 可以只從索引中拿資料，不必回表查找原資料，這種稱為 **覆蓋索引（Covering Index）**。

```sql
-- 覆蓋索引查詢
SELECT id, name FROM student WHERE id = 1001 AND name = '王小明';
```

這裡 `id` 和 `name` 都在 `idx_id_name_gender` 中，查詢效率更高。

---

#### 🧠 使用建議

- 若查詢中會依照多個欄位進行篩選，建議使用多列索引。
- 須注意欄位順序：放在越前面的欄位查詢越頻繁，命中率才高。
- 若多個查詢條件不固定，可改考慮建立「複數個單列索引」+「查詢覆蓋策略」。

---

### 🔍 全文索引（FULLTEXT Index）

> 全文索引（全文檢索）是一種針對**大量文字型欄位內容進行高效查詢**的技術，廣泛用於部落格、文章、評論、商品描述等應用場景。它支援**分詞技術**，能夠根據關鍵字進行模糊搜尋與匹配分析。

---

#### ✅ 適用情境與限制條件

| 條件 | 說明 |
|------|------|
| 支援欄位類型 | `CHAR`, `VARCHAR`, `TEXT` 及其變體 |
| MySQL 引擎支援 | **MyISAM**（MySQL 3.23.23+）<br>**InnoDB**（MySQL 5.6.4+） |
| 是否支援中文 | MySQL 5.7.6+ 內建 `ngram` 分詞器；其他版本需額外安裝分詞插件（如 `jieba`） |
| 是否支援 NULL / 重複值 | ✅ 允許 NULL 和重複值 |
| 查詢語法 | 使用 `MATCH(...) AGAINST(...)` |
| 適合應用 | 大型文章、評論、搜尋系統 |

---

#### 📘 建立全文索引的範例

##### 1. 建立表格 `student`

```sql
CREATE TABLE student (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(100),
    information TEXT
) ENGINE=InnoDB;
```

> 🔔 注意：`ENGINE=InnoDB` 並確保 MySQL 版本 ≥ 5.6.4

---

##### 2. 為 `information` 欄位建立全文索引

```sql
CREATE FULLTEXT INDEX idx_information ON student(information);
```

---

##### 3. 插入樣本資料

```sql
INSERT INTO student (name, information) VALUES
('王小明', '我喜歡學習MySQL與資料庫設計。'),
('李小華', '資料庫優化是一門值得深入研究的學問。'),
('陳小安', '他正在準備資料結構與演算法的考試。');
```

---

#### 📌 查詢語法說明：兩種搜尋模式

---

##### ✅ 1. **自然語言模式**（Natural Language）

> 根據詞語的**重要性（出現頻率）**自動評分，返回**匹配度高的結果**。

```sql
SELECT *, MATCH(information) AGAINST('資料庫') AS score
FROM student
WHERE MATCH(information) AGAINST('資料庫');
```

- 出現次數少但與查詢詞完全匹配的紀錄會有較高的 `score`。
- 出現過於頻繁的字（如「的」、「是」等）會被忽略。
- 詞語若出現在超過 50% 的紀錄中，將會被排除在自然語言搜尋之外。

---

##### ✅ 2. **布林模式（BOOLEAN MODE）**

> 自行指定搜尋邏輯（支援邏輯符號如 `+`, `-`, `*`, `"` 等）

```sql
SELECT * FROM student
WHERE MATCH(information) AGAINST('+資料庫 -演算法' IN BOOLEAN MODE);
```

- `+資料庫`：必須包含「資料庫」
- `-演算法`：不能包含「演算法」
- `資料*`：模糊匹配開頭為「資料」的詞
- `"資料庫設計"`：完全匹配詞組

---

#### 🧠 補充知識：ngram 中文分詞器（MySQL 5.7.6+）

```sql
CREATE TABLE article (
    id INT PRIMARY KEY AUTO_INCREMENT,
    content TEXT,
    FULLTEXT idx_content (content) WITH PARSER ngram
) ENGINE=InnoDB;
```

- 使用內建 ngram 分詞器實現中文分詞
- 須搭配 `innodb_ft_min_token_size=1` 以支援單字搜尋（預設是 3）

---

#### 🔄 全文索引 vs 傳統LIKE查詢

| 查詢方式 | 優點 | 缺點 |
|----------|------|------|
| `LIKE '%keyword%'` | 實作簡單，支援任何欄位 | 無法使用索引，全表掃描，效率低 |
| `MATCH AGAINST` | 有索引支援，效率高，語意搜尋 | 僅適用文字欄位，需建索引與版本限制 |

---

#### 🔚 為什麼現在多用 ElasticSearch？

全文索引在 MySQL 雖然可用，但在以下場景仍不夠強大：
- 巨量文字內容
- 複雜條件與排序（例如權重、距離、地點）
- 高度自訂詞典、分詞邏輯
- 多欄位、多語言的全文搜尋需求

因此在大型系統中，多改用如：
- **Elasticsearch**（目前主流）
- **Solr**（Apache 項目）
- **Sphinx**（較早期使用）

---

### 🧭 空間索引（SPATIAL INDEX）

> 空間索引是針對 **空間數據類型（Spatial Data Types）** 設計的索引，主要應用於地理資訊（GIS）資料的查詢和分析，例如：查找範圍內的點、測量距離、檢查是否相交等空間運算。

使用 `SPATIAL` 關鍵字可以建立空間索引，以提高如「位置相交」或「範圍查詢」的效率。

---

#### ✅ MySQL 空間資料類型

| 類型 | 說明 |
|------|------|
| `GEOMETRY` | 空間數據的通用類型，其他類型的父類 |
| `POINT` | 單一點（經緯度） |
| `LINESTRING` | 線段（如：公路、河流） |
| `POLYGON` | 多邊形（如：地區、建築物範圍） |

---

#### ⚠️ 使用限制

| 條件 | 說明 |
|------|------|
| 支援引擎 | 早期只有 **MyISAM** 支援空間索引<br>**InnoDB 從 MySQL 5.7 開始** 支援 SPATIAL 索引 |
| 資料不可為 NULL | 建立索引的欄位不能包含 NULL |
| 索引欄位 | 必須是空間資料類型欄位（如 `POINT`） |
| 不支援複合索引 | 空間索引無法與其他欄位一起作為多列索引使用 |

---

#### 🧪 實作範例

##### 1. 建立使用 `MyISAM` 引擎的資料表（或 MySQL 5.7+ 用 InnoDB）

```sql
CREATE TABLE places (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(100),
    location POINT NOT NULL,
    SPATIAL INDEX(location)
) ENGINE=MyISAM;
```

> 注意：早期版本需使用 `MyISAM`，MySQL 5.7 以後可使用 `InnoDB`。

---

##### 2. 插入範例資料

```sql
INSERT INTO places (name, location)
VALUES 
('公園', ST_GeomFromText('POINT(121.56 25.04)')),
('咖啡廳', ST_GeomFromText('POINT(121.52 25.02)')),
('圖書館', ST_GeomFromText('POINT(121.50 25.06)'));
```

---

##### 3. 查詢距離某座標點在一定範圍內的地點（以台北市為例）

```sql
SELECT * FROM places
WHERE MBRContains(
    ST_GeomFromText('POLYGON((121.50 25.00, 121.50 25.08, 121.58 25.08, 121.58 25.00, 121.50 25.00))'),
    location
);
```

此查詢會找出 `location` 點在給定「多邊形」範圍內的所有地點。

---

#### 📌 空間運算函數（部分常用）

| 函數 | 說明 |
|------|------|
| `MBRContains(g1, g2)` | 判斷空間物件 g2 是否在 g1 的最小外接矩形（MBR）內 |
| `ST_Within(g1, g2)` | 判斷 g1 是否完全包含於 g2 中 |
| `ST_Distance(g1, g2)` | 計算兩個空間物件的距離 |
| `ST_Intersects(g1, g2)` | 判斷兩個物件是否相交 |

---

#### 🔍 實際應用場景

- 查詢一定範圍內的餐廳、加油站、ATM（LBS：Location-Based Service）
- 判斷某地址是否位於某縣市的多邊形範圍內（行政區分析）
- 配送系統判斷用戶是否在服務區域內

---

#### ⚠️ 延伸說明：為什麼空間索引初學者少用？

- 實作需搭配空間資料型別與空間函數，學習曲線較高
- 適合使用在有地理資訊需求的專案中，否則通常會使用數值或文字索引
- 真正大型地理資訊系統會使用專門引擎如：
  - **PostGIS**（PostgreSQL 的空間擴充）
  - **MongoDB Geospatial Index**
  - **Elasticsearch Geo Queries**

---

### 🧩 小結：不同存儲引擎支援的索引類型比較

| 存儲引擎 | B-Tree 索引 | Hash 索引 | Full-text 索引 | Spatial 索引 | 說明補充 |
|-----------|--------------|-------------|------------------|---------------|--------------|
| **InnoDB** | ✅ 支援 | ❌ 不支援 | ✅（MySQL 5.6+） | ✅（MySQL 5.7+） | 支援最廣泛，預設引擎 |
| **MyISAM** | ✅ 支援 | ❌ 不支援 | ✅（MySQL 3.23+） | ✅ | 適用讀多寫少、舊版默認引擎 |
| **Memory** | ✅ 支援 | ✅ 預設使用 | ❌ 不支援 | ❌ | 資料存在記憶體中，適合暫存 |
| **NDB（Cluster）** | ❌ 不支援 | ✅ 支援 | ❌ 不支援 | ❌ | 分散式儲存引擎，適合高可用性需求 |
| **Archive** | ❌ 不支援 | ❌ 不支援 | ❌ 不支援 | ❌ | 僅支援插入與壓縮查詢，無索引特性 |

## 1.2创建索引

> MySQL支持多种方法在单个或多个列上创建索引：在创建表的定义语句CREATE TABLE 中指定索引列，使用 ALTER TABLE 语句在存在的表上创建索引，或者使用 CREATE INDEX 语句在已存在的表上添加索引。

### 1.2.1 创建表的时候创建索引
> 使用CREATE TABLE创建表时，除了可以定义列的数据类型外，还可以定义主键约束、外键约束或者唯一性约束，而不论创建哪种约束，在定义约束的同时相当于在指定列上创建了一个索引。

#### 隐式的方式创建索引。在声明有主键约束、唯一性约束、外键约束的字段上，会自动的添加相关的索引

```sql
CREATE TABLE dept(
	dept_id INT PRIMARY KEY AUTO_INCREMENT,
	dept_name VARCHAR(20)
);
 
-- 隐式的方式创建索引。在声明有主键约束、唯一性约束、外键约束的字段上，会自动的添加相关的索引 
CREATE TABLE emp(
	emp_id INT PRIMARY KEY AUTO_INCREMENT,
	emp_name VARCHAR(20) UNIQUE,
	dept_id INT,
	CONSTRAINT emp_dept_id_fk FOREIGN KEY(dept_id) REFERENCES dept(dept_id)
);
```

#### 但是，如果显式创建表时创建索引的话，基本语法格式如下：

```sql
CREATE TABLE table_name [col_name data_type] 
[UNIQUE | FULLTEXT | SPATIAL] [INDEX | KEY] [index_name] (col_name [length]) [ASC | DESC]
```

- `UNIQUE`、`FULLTEXT`和`SPATIAL`为可选参数，分别表示唯一索引、全文索引和空间索引；
- `INDEX`与`KEY`为同义词，两者的作用相同，用来指定创建索引；
- `index_name`指定索引的名称，为可选参数，如果不指定，那么MySQL默认col_name为索引名；
- `col_name`为需要创建索引的字段列，该列必须从数据表中定义的多个列中选择；
- `length`为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度；
- `ASC`或`DESC`指定升序或者降序的索引值存储。

#### 1. 创建普通索引

在book表中的year_publication字段上建立普通索引，SQL语句如下：

```sql
CREATE TABLE book( 
    book_id INT , 
    book_name VARCHAR(100), 
    authors VARCHAR(100), 
    info VARCHAR(100) , 
    comment VARCHAR(100), 
    year_publication YEAR, 
    -- 声明索引
    INDEX(year_publication) 
);

# 通过命令查看索引
# 方式1:
SHOW CREATE TABLE book;
# 方式2:
SHOW INDEX FROM book;
```


#### 2. 创建唯一索引
```sql
CREATE TABLE test1( 
    id INT NOT NULL, 
    name varchar(30) NOT NULL, 
    
    -- 创建唯一索引,(也相当于创建了唯一性约束)
    -- #声明有唯一索引的字段，在添加数据时，也要保证唯一性，但是可以添加null
    UNIQUE INDEX uk_idx_id(id) 
);
```

该语句执行完毕之后，使用SHOW CREATE TABLE查看表结构：
```sql
SHOW INDEX FROM test1
```

#### 3. 主键索引
设定主键后数据库会自动建立索引，innodb为聚簇索引，语法：

随表一起建索引（通过定义主键约束的方式自动生成主键索引）：

```sql
CREATE TABLE student ( 
    id INT(10) UNSIGNED AUTO_INCREMENT, 
    student_no VARCHAR(200),
    student_name VARCHAR(200), 
    PRIMARY KEY(id)  -- 通过定义主键约束的方式定义主键索引
);
```

删除主键索引

```sql
alter table student modify id int; -- 删除auto_increment约束
# 删除主键索引（通过删除主键约束的方式删除主键索引）
ALTER TABLE student drop PRIMARY KEY ;
```

修改主键索引：必须先删除掉(drop)原索引，再新建(add)索引

```sql
alter table student modify  id int primary key;
```

#### 4. 创建单列索引
```sql
CREATE TABLE test2( 
    id INT NOT NULL, 
    name CHAR(50) NULL, 
    INDEX single_idx_name(name(20)) 
);
```

#### 5. 创建组合索引

组合索引是在多个字段上创建一个索引。

举例：创建表test3，在表中的id、name和age字段上建立组合索引，SQL语句如下

```sql
CREATE TABLE test3( 
    id INT(11) NOT NULL, 
    name CHAR(30) NOT NULL, 
    age INT(11) NOT NULL, 
    info VARCHAR(255), 
    INDEX multi_idx(id,name,age) 
);
```

该语句执行完毕之后，使用SHOW INDEX查看:

```sql
SHOW INDEX FROM test3;
```

![](./images/2402456-20220611163030010-220039274.png "")

由结果可以看到，id、name和age字段上已经成功建立了一个名为multi_idx的组合索引。

组合索引可起几个索引的作用，但是使用时并不是随便查询哪个字段都可以使用索引，而是遵从 **最左前缀**。例如，索引可以搜索的字段组合为: (id, name, age). (id, name) 或者 id。而 (age) 或者 (name,age) 组合不能使用索引查询。

在test3表中，查询id和name字段，使用EXPLAIN语句查看索引的使用情况：

```shell
EXPLAIN SELECT id,name FROM test3 WHERE id=1 AND name='songhongkang' \G
```

![](./images/2402456-20220611163029770-1863403537.png "")

可以看到，查询id和name字段时，使用了名称为Multildx的索引，如果查询(name,age)组合或者单独查询name和age字段，会发现结果中possible_keys和key值为NULL，并没有使用在test3表中创建的索引进行查询。

#### 6. 创建全文索引
##### ✅ 什麼是 FULLTEXT 全文索引？

- `FULLTEXT` 是一種 **全文檢索技術**，適合用於對長篇文章、說明文字、內容描述等欄位進行搜尋。
- 適用欄位型別：`CHAR`、`VARCHAR`、`TEXT`
- 適用引擎：MySQL 5.6 起 `InnoDB` 開始支援，`MyISAM` 也支援。
- 只能建立在 **整個欄位** 上，**不支援前綴索引（如 column(10)）**
- 查詢方式使用 `MATCH(...columns...) AGAINST('關鍵字')`

---

##### ✅ 基本語法範例

####### 🔹 範例 1：在 `MyISAM` 上建立全文索引

```sql
CREATE TABLE papers (
  id INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,
  title VARCHAR(200) DEFAULT NULL,
  content TEXT,
  PRIMARY KEY (id),
  FULLTEXT KEY ft_title_content (title, content)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;
```

###### 🔹 範例 2：在 `InnoDB` 上建立全文索引（MySQL 5.6+）

```sql
CREATE TABLE articles (
  id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  title VARCHAR(200),
  body TEXT,
  FULLTEXT INDEX ft_title_body (title, body)
) ENGINE=InnoDB;
```

---

##### ✅ 使用方式：全文檢索語法

```sql
SELECT * 
FROM articles 
WHERE MATCH(title, body) AGAINST ('MySQL 索引');
```

###### 📌 說明：
- `MATCH(title, body)` 指要搜尋的欄位；
- `AGAINST('關鍵字')` 是搜尋的文字內容；
- `AGAINST` 可結合布林模式與自然語言模式（後面補充）。

---

##### ✅ 與 `LIKE` 查詢的比較

| 查詢方式 | 語法 | 特點 |
|----------|------|------|
| LIKE 查詢 | `WHERE content LIKE '%關鍵字%'` | 範圍模糊搜尋、但效率低（全表掃描） |
| FULLTEXT 查詢 | `WHERE MATCH(...) AGAINST('關鍵字')` | 使用全文索引搜尋、效率高 |

###### 🔹 範例比較：

```sql
-- LIKE 模糊查詢（效率較差）
SELECT * FROM papers WHERE content LIKE '%索引%';

-- FULLTEXT 全文索引查詢（效率較高）
SELECT * FROM papers WHERE MATCH(title, content) AGAINST('索引');
```

---

##### ✅ 建議使用時機

- **適合處理大量文本欄位的搜尋**，例如文章、評論、部落格、新聞等。
- 若資料量大，建議先插入資料，再建立 FULLTEXT 索引，可提高效率。

---

##### ✅ 查詢模式選擇（AGAINST）

MySQL 中的 `AGAINST` 支援兩種主要模式：

| 模式 | 語法範例 | 說明 |
|------|-----------|------|
| 自然語言模式（預設） | `AGAINST('mysql index')` | 基於關鍵字相關度自動排序 |
| 布林模式 | `AGAINST('+mysql -index' IN BOOLEAN MODE)` | 支援 AND(+)、OR(空格)、NOT(-) 等邏輯符號 |

---

##### ✅ 額外補充：檢查是否建立了全文索引

```sql
SHOW INDEX FROM articles;
```

---

##### ✅ 建議順序（建立大量資料時）

```sql
-- Step 1: 建立表但先不加 FULLTEXT 索引
CREATE TABLE articles (
  id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  title VARCHAR(200),
  body TEXT
) ENGINE=InnoDB;

-- Step 2: 批次插入大量資料

-- Step 3: 再加上全文索引
ALTER TABLE articles ADD FULLTEXT INDEX ft_title_body (title, body);
```

---

#### 7. 创建空间索引
##### ✅ 什麼是空間索引（SPATIAL INDEX）？

- 空間索引是一種針對 **幾何資料（空間資料）** 的特殊索引，用來加速對如位置、地理形狀等資訊的查詢。
- 通常使用在如地圖、座標、區域邊界等與 GIS（地理資訊系統）有關的資料上。
- MySQL 支援以下空間資料類型：
  - `GEOMETRY`
  - `POINT`
  - `LINESTRING`
  - `POLYGON`

---

##### ✅ 空間索引的使用限制

| 條件 | 說明 |
|------|------|
| 儲存引擎 | 只能用 `MyISAM`（MySQL 5.x）<br>MySQL 8.0 起，`InnoDB` 也支援 |
| 欄位 | 必須是 **空間資料類型**，如 `GEOMETRY` |
| 欄位值 | 必須為 **NOT NULL**，不能是 `NULL` |
| 不支援前綴索引 | 空間索引只能建在整個欄位上 |

---

##### ✅ 基本語法：建立空間索引

```sql
CREATE TABLE test5 (
  geo GEOMETRY NOT NULL,
  SPATIAL INDEX spa_idx_geo (geo)
) ENGINE=MyISAM;
```

---

##### ✅ 查詢語句：確認索引建立成功

```sql
SHOW INDEX FROM test5 \G
```

###### 輸出會包含：
- Key_name: `spa_idx_geo`
- Column_name: `geo`
- Index_type: `SPATIAL`

---

##### ✅ GEOMETRY 與空間資料舉例

可以使用內建的幾何函數（如 `ST_GeomFromText()`）來插入空間資料：

```sql
INSERT INTO test5 (geo)
VALUES (ST_GeomFromText('POINT(121.5 25.1)')); -- 台北附近一個經緯度點
```

---

##### ✅ 額外範例：使用 `POINT` 類型（更常用）

```sql
CREATE TABLE locations (
  id INT PRIMARY KEY AUTO_INCREMENT,
  name VARCHAR(100),
  location POINT NOT NULL,
  SPATIAL INDEX idx_location (location)
) ENGINE=MyISAM;
```

插入地理座標資料：

```sql
INSERT INTO locations (name, location)
VALUES ('Taipei 101', ST_GeomFromText('POINT(121.5645 25.0330)'));
```

---

##### ✅ 注意：查詢需結合空間函數

例如查詢範圍內的地點：

```sql
-- 找出範圍內的點 (此為虛構範圍範例)
SELECT * FROM locations
WHERE MBRContains(
  ST_GeomFromText('POLYGON((121.5 25.0, 121.6 25.0, 121.6 25.1, 121.5 25.1, 121.5 25.0))'),
  location
);
```

> `MBRContains()` 是基於最小外接矩形（Minimum Bounding Rectangle）的查詢方式，比精確幾何查詢效率更高。

---

##### 📌 小結

| 項目 | 說明 |
|------|------|
| 使用資料型別 | `GEOMETRY`、`POINT` 等空間資料型別 |
| 建立條件 | 欄位 `NOT NULL`，`ENGINE=MyISAM`（8.0可用 InnoDB） |
| 索引方式 | `SPATIAL INDEX` |
| 查詢方式 | `MBRContains()`、`MBRWithin()`、`ST_Contains()` 等 |

---

### 1.2.2. 在已经存在的表上创建索引
#### ✅ 一、使用 `ALTER TABLE` 建立索引

這種方式屬於**修改表結構**來新增索引，是最常見的做法之一。

##### 🔹 語法結構：

```sql
ALTER TABLE 表名
ADD [UNIQUE | FULLTEXT | SPATIAL] [INDEX | KEY] [索引名稱] (欄位名[length]...) [ASC | DESC];
```

##### 🔹 範例 1：建立普通索引（單欄位）

```sql
ALTER TABLE book5
ADD INDEX idx_cmt (COMMENT);
```

##### 🔹 範例 2：建立唯一索引

```sql
ALTER TABLE book5
ADD UNIQUE INDEX uk_idx_bname (book_name);
```

##### 🔹 範例 3：建立組合索引（多欄位）

```sql
ALTER TABLE book5
ADD INDEX mul_bid_bname_info (book_id, book_name, info);
```

---

#### ✅ 二、使用 `CREATE INDEX` 建立索引

這種方式比較語義直觀，專門用來建立索引。實際上 MySQL 底層會轉成 `ALTER TABLE`。

##### 🔹 語法結構：

```sql
CREATE [UNIQUE | FULLTEXT | SPATIAL] INDEX 索引名稱
ON 表名 (欄位1[length], 欄位2[length]...) [ASC | DESC];
```

##### 🔹 範例 1：建立普通索引

```sql
CREATE INDEX idx_cmt
ON book6 (COMMENT);
```

##### 🔹 範例 2：建立唯一索引

```sql
CREATE UNIQUE INDEX uk_idx_bname
ON book6 (book_name);
```

##### 🔹 範例 3：建立組合索引

```sql
CREATE INDEX mul_bid_bname_info
ON book6 (book_id, book_name, info);
```

---

#### ✅ 注意事項

| 條件 | 說明 |
|------|------|
| 欄位名稱 | 可以是一個或多個欄位，組合索引欄位順序會影響查詢效率 |
| 字串型欄位 | 可選擇加上 `[length]`，用來指定索引長度（僅限 CHAR/VARCHAR） |
| 降序索引 | `[ASC | DESC]` 可以指定，但在 MySQL 中實際影響很有限 |
| 表存在資料 | 可以不清除資料直接加索引，但大量資料時會影響效能，建議閒時執行 |
| FULLTEXT、SPATIAL | 限定欄位型別與儲存引擎（例如 SPATIAL 只能在空間類型欄位上建立） |

---

#### ✅ 如何查看目前表的索引？

```sql
SHOW INDEX FROM book5;
```

---

#### ✅ 小結

| 方法 | 使用語法 | 適用時機 |
|------|----------|-----------|
| `ALTER TABLE` | 修改表結構時直接加索引 | 比較常見的做法 |
| `CREATE INDEX` | 專門加索引的語法，語義清楚 | 單獨建立索引時使用 |

---

## 1.3 刪除索引
#### ✅ 一、使用 `ALTER TABLE` 刪除索引

這是最常見的方式，用於刪除指定索引（包括普通索引、唯一索引、組合索引、全文索引等）。

##### 🔹 基本語法：

```sql
ALTER TABLE 表名 DROP INDEX 索引名稱;
```

##### 🔹 範例：刪除唯一索引 `idx_bk_id`（book 表）

```sql
-- 查看目前索引
SHOW INDEX FROM book \G;

-- 刪除索引
ALTER TABLE book DROP INDEX idx_bk_id;
```

> ⚠️ 注意：若 `idx_bk_id` 是 `AUTO_INCREMENT` 欄位（例如主鍵或唯一鍵），則不能直接刪除索引，否則會報錯。

---

#### ✅ 二、使用 `DROP INDEX` 刪除索引

這是另一種刪除方式，語法稍微不同，但結果相同。

##### 🔹 基本語法：

```sql
DROP INDEX 索引名稱 ON 表名;
```

##### 🔹 範例：刪除組合索引 `idx_aut_info`（book 表）

```sql
DROP INDEX idx_aut_info ON book;
```

##### 🔹 查看索引是否成功刪除：

```sql
SHOW CREATE TABLE book \G;
```

---

#### ✅ 額外補充：AUTO_INCREMENT 欄位的限制

```sql
CREATE TABLE example (
  id INT AUTO_INCREMENT,
  name VARCHAR(50),
  UNIQUE INDEX idx_id (id)
);
```

即使 `id` 上設的是唯一索引，如果它是 `AUTO_INCREMENT` 的欄位，則不能使用 `DROP INDEX` 或 `ALTER TABLE ... DROP INDEX` 來刪除該索引，否則會出現錯誤訊息：

```
ERROR 1553 (HY000): Cannot drop index 'idx_id': needed in a foreign key constraint
```

##### 🔹 正確處理方式：
你需要先移除 `AUTO_INCREMENT` 屬性，再刪索引：

```sql
-- 1. 移除 AUTO_INCREMENT
ALTER TABLE example MODIFY id INT;

-- 2. 再刪除索引
ALTER TABLE example DROP INDEX idx_id;
```

---

#### ✅ 補充說明：欄位與索引之間的關係

- 當你刪除某個欄位時，若該欄位有包含在索引中：
  - 該欄位會從該索引中移除；
  - 若該欄位是**唯一組成欄位**，則整個索引會被刪除；
  - 若該欄位是**組合索引的一部分**，則該欄位會從索引中移除，剩餘欄位會繼續構成索引。

##### 🔹 範例：

```sql
CREATE TABLE demo (
  id INT,
  name VARCHAR(50),
  email VARCHAR(50),
  INDEX idx_name_email (name, email)
);
```

若刪除欄位 `name`：

```sql
ALTER TABLE demo DROP COLUMN name;
```

那麼原本的組合索引 `idx_name_email` 會被轉為：

```sql
INDEX idx_name_email (email)
```

---

#### ✅ 小結

| 方法 | 語法 | 備註 |
|------|------|------|
| `ALTER TABLE DROP INDEX` | `ALTER TABLE table_name DROP INDEX index_name;` | 適用於大多數情境 |
| `DROP INDEX ON` | `DROP INDEX index_name ON table_name;` | 語法更語義化 |
| `SHOW INDEX` | `SHOW INDEX FROM table_name \G` | 查看現有索引 |
| `SHOW CREATE TABLE` | `SHOW CREATE TABLE table_name \G` | 查看索引結構 |
| ⚠️ 注意 | AUTO_INCREMENT 欄位的索引不能直接刪除 | 需先移除屬性 |

---

# 2. MySQL8.0索引新特性
## 2.1 支持降序索引
降序索引以降序存储键值。虽然在语法上，从MySQL 4版本开始就已经支持降序索引的语法了，但实际上该DESC定义是被忽略的，直到MySQL 8.x版本才开始真正支持降序索引(仅限于InnoDB存储引擎)。

MySQL在 8.0版本之前创建的仍然是升序索引，如果在使用时进行反向扫描（降序），会大大降低了数据库的效率 。在某些场景下，降序索引意义重大。例如，如果一个查询，需要对多个列进行排序，且顺序要求不一致，那么使用降序索引将会避免数据库使用额外的文件排序操作，从而提高性能。

举例：分别在MySQL 5.7版本和MySQL 8.0版本中创建数据表ts1，结果如下：

```sql
CREATE TABLE ts1(a int,b int,index idx_a_b(a,b desc));
```

- 在MySQL 5.7版本中查看数据表ts1的结构，结果如下：
    - ![](./images/2402456-20220611163029498-1179292386.png "")
    - 从结果可以看出，索引仍然是默认的升序。

- 在MySQL 8.0版本中查看数据表ts1的结构，结果如下：
    - ![](./images/2402456-20220611163029248-1864871598.png "")
    - 从结果可以看出，索引已经是降序了。

下面继续测试降序索引在执行计划中的表现。分别在MySQL 5.7版本和MySQL 8.0版本的数据表ts1中插入800条随机数据，执行语句如下：

```sql
DELIMITER //
CREATE PROCEDURE ts_insert()
BEGIN
	DECLARE i INT DEFAULT 1;
	WHILE i < 800
	DO
		insert into ts1 select rand()*80000,rand()*80000;
		SET i = i + 1;
	END WHILE;
	commit;
END //
DELIMITER ;
 
#调用
CALL ts_insert();
```

在MySQL 5.7版本中查看数据表ts1的执行计划，结果如下：

```sql
EXPLAIN SELECT * FROM ts1 ORDER BY a,b DESC LIMIT 5;
```

从结果可以看出，执行计划中扫描数为799，而且使用了Using filesort。

> **提示:** Using filesort是MySQL中一种速度比较慢的外部排序，能避免是最好的。多数情况下，管理员可以通过优化索引来尽量避免出现Using filesort，从而提高数据库执行速度。

在MySQL 8.0版本中查看数据表ts1的执行计划。从结果可以看出，执行计划中扫描数为5，而且没有使用 Using filesort。

![](./images/2402456-20220611163029005-776851968.png "")

将排序条件修改为 `order by a desc, b desc` 后，下面来对比不同版本中执行计划的效果。 在MySQL 5.7版本中查看数据表ts1的执行计划，结果如下：

```sql
EXPLAIN SELECT * FROM ts1 ORDER BY a DESC,b DESC LIMIT 5;
```

在MySQL 8.0版本中查看数据表ts1的执行计划。从结果可以看出，修改后MySQL 5.7的执行计划要明显好于MySQL 8.0。

![](./images/2402456-20220611163028752-1057909917.png "")

> **注意**
> - 降序索引只对查询中特定的排序顺序有效，如果使用不当，反而查询效率更低。例如，上述查询排序条件改为order by a desc, b desc，MySQL 5.7的执行计划要明显好于MySQL 8.0。

## 2.2 隱藏索引
在MySQL 5.7版本及之前，只能通过显式的方式删除索引。此时，如果发现删除索引后出现错误，又只能通过显式创建索引的方式将删除的索引创建回来。如果数据表中的数据量非常大，或者数据表本身比较大，这种操作就会消耗系统过多的资源，操作成本非常高。

从MySQL 8.x开始支持隐藏索引（invisible indexes），只需要将待删除的索引设置为隐藏索引，使查询优化器不再使用这个索引（即使使用force index（强制使用索引），优化器也不会使用该索引），确认将索引设置为隐藏索引后系统不受任何响应，就可以彻底删除索引。这种通过先将索引设置为隐藏索引，再删除索引的方式就是软删除。

同时，如果你想验证某个索引删除之后的查询性能影响，就可以暂时先隐藏该索引。

> **注意:**
> - 主键不能被设置为隐藏索引。当表中没有显式主键时，表中第一个唯一非空索引会成为隐式主键，也不能设置为隐藏索引。

索引默认是可见的，在使用 **CREATE TABLE**， **CREATE INDEX** 或者 **ALTERT ABLE** 等语句时可以通过 VISIBLE 或者 INVISIBLE 关键词设置索引的可见性。

### 1. 创建表时直接创建

在MySQL中创建隐藏索引通过SQL语句INVISIBLE来实现，其语法形式如下：

```sql
CREATE TABLE tablename( 
    propname1 type1[CONSTRAINT1], 
    propname2 type2[CONSTRAINT2], 
    ……
    propnamen typen, 
    INDEX [indexname](propname1 [(length)]) INVISIBLE 
);
```

上述语句比普通索引多了一个关键字INVISIBLE，用来标记索引为不可见索引。

### 2. 在已经存在的表上创建

可以为已经存在的表设置隐藏索引，其语法形式如下：

```sql
CREATE INDEX indexname 
ON tablename(propname[(length)]) INVISIBLE;
```

### 3. 通过ALTER TABLE语句创建
```sql
ALTER TABLE tablename 
ADD INDEX indexname (propname [(length)]) INVISIBLE;
```

### 4. 修改索引可见状态

已存在的索引可通过如下语句切换可见状态：

```sql
ALTER TABLE tablename ALTER INDEX index_name INVISIBLE; #切换成隐藏索引 
ALTER TABLE tablename ALTER INDEX index_name VISIBLE; #切换成非隐藏索引
```

如果将index_cname索引切换成可见状态，通过explain查看执行计划，发现优化器选择了index_cname索引。

> **注意:**
> - 当索引被隐藏时，它的内容仍然是和正常索引一样实时更新的。如果一个索引需要长期被隐藏，那么可以将其删除，因为索引的存在会影响插入、更新和删除的性能。

通过设置隐藏索引的可见性可以查看索引对调优的帮助。

### 5. 使隐藏索引对查询优化器可见（了解）
在MySQL 8.x版本中，为索引提供了一种新的测试方式，可以通过查询优化器的一个开关（use_invisible_indexes）来打开某个设置，使隐藏索引对查询优化器可见。如果 use_invisible_indexes 设置为off(默认)，优化器会忽略隐藏索引。如果设置为on，即使 隐藏索引不可见，优化器在生成执行计划时仍会考虑使用隐藏索引。

##### （1）在MySQL命令行执行如下命令查看查询优化器的开关设置。
```shell
mysql> select @@optimizer_switch \G
```

在输出的结果信息中找到如下属性配置。

```shell
use_invisible_indexes=off
```

此属性配置值为off，说明隐藏索引默认对查询优化器不可见。

##### （2）使隐藏索引对查询优化器可见，需要在MySQL命令行执行如下命令：
```shell
mysql> set session optimizer_switch="use_invisible_indexes=on";
Query OK, 0 rows affected (0.00 sec)
```

SQL语句执行成功，再次查看查询优化器的开关设置。

```shell
mysql>  select @@optimizer_switch \G
*************************** 1. row ***************************
@@optimizer_switch:
index_merge=on,index_merge_union=on,index_merge_sort_union=on,index_merge_
intersection=on,engine_condition_pushdown=on,index_condition_pushdown=on,mrr=on,mrr_co
st_based=on,block_nested_loop=on,batched_key_access=off,materialization=on,semijoin=on
,loosescan=on,firstmatch=on,duplicateweedout=on,subquery_materialization_cost_based=on
,use_index_extensions=on,condition_fanout_filter=on,derived_merge=on,use_invisible_indexes=on,skip_scan=on,hash_join=on
1 row in set (0.00 sec)
```

此时，在输出结果中可以看到如下属性配置。

```shell
use_invisible_indexes=on
```

> use_invisible_indexes属性的值为on，说明此时隐藏索引对查询优化器可见。

##### （3）使用EXPLAIN查看以字段invisible_column作为查询条件时的索引使用情况
```sql
explain select * from classes where cname = '高一2班';
```

> 查询优化器会使用隐藏索引来查询数据

##### （4）如果需要使隐藏索引对查询优化器不可见，则只需要执行如下命令即可。
```shell
mysql> set session optimizer_switch="use_invisible_indexes=off";
Query OK, 0 rows affected (0.00 sec)
```

再次查看查询优化器的开关设置。

```shell
mysql> select @@optimizer_switch \G
```

> 此时，use_invisible_indexes属性的值已经被设置为“off”。


# 3. 索引的设计原则