# 1. 数据库服务器的优化步骤
当我们遇到数据库调优问题的时候，该如何思考呢？这里把思考的流程整理成下面这张图。
整个流程划分成了 **观察（Show status） 和  行动（Action）** 两个部分。字母 S 的部分代表观察（会使用相应的分析工具），字母 A 代表的部分是行动（对应分析可以采取的行动）。

![](./images/2402456-20220611163057954-383032458.png "")

![](./images/2402456-20220611163057670-182622087.png "")

## 小結

![](./images/2402456-20220611163057420-115654700.png "")

# 2. 查看系统性能参数
在MySQL中，可以使用 **SHOW STATUS** 语句查询一些MySQL数据库服务器的 **性能参数 、 执行频率** 。

SHOW STATUS语句语法如下：

```sql
SHOW [GLOBAL|SESSION] STATUS LIKE '参数';
```

- 一些常用的性能参数如下：
    - Connections：连接MySQL服务器的次数。
    - Uptime：MySQL 服务器的上线时间。
    - Slow_queries：慢查询的次数。
    - Innodb_rows_read：Select查询返回的行数
    - Innodb_rows_inserted：执行INSERT操作插入的行数
    - Innodb_rows_updated：执行UPDATE操作更新的行数
    - Innodb_rows_deleted：执行DELETE操作删除的行数
    - Com_select：查询操作的次数。
    - Com_insert：插入操作的次数。对于批量插入的 INSERT 操作，只累加一次。
    - Com_update：更新操作的次数。
    - Com_delete：删除操作的次数。

若查询MySQL服务器的连接次数，则可以执行如下语句:

```sql
SHOW STATUS LIKE 'connections';
```

若查询服务器工作时间，则可以执行如下语句:

```sql
SHOW STATUS LIKE 'Uptime';
```

若查询MySQL服务器的慢查询次数，则可以执行如下语句:

```sql
SHOW STATUS LIKE 'Slow_queries';
```

慢查询次数参数可以结合慢查询日志找出慢查询语句，然后针对慢查询语句进行表结构优化或者查询语句优化。再比如，如下的指令可以查看相关的指令情况:

```sql
show status like 'Innodb_rows_%';
```

# 3. 统计SQL的查询成本：last_query_cost
一条SQL查询语句在执行前需要确定查询执行计划，如果存在多种执行计划的话，MySQL会计算每个执行计划所需要的成本，从中选择 **成本最小** 的一个作为最终执行的执行计划。

如果我们想要查看某条SQL语句的查询成本，可以在执行完这条SQL语句之后，通过查看当前会话中的 **last_query_cost** 变量值来得到当前查询的成本。它通常也是我们 评价一个查询的执行效率的一个常用指标 。这个查询成本对应的是 SQL语句所需要读取的页的数量 。

我们依 然使用第8章的 student_info 表为例：

```sql
use atguigudb1;
 
CREATE TABLE `student_info` (
    `id` INT(11) NOT NULL AUTO_INCREMENT,
    `student_id` INT NOT NULL ,
    `name` VARCHAR(20) DEFAULT NULL,
    `course_id` INT NOT NULL ,
    `class_id` INT(11) DEFAULT NULL,
    `create_time` DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    PRIMARY KEY (`id`)
) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;
```

如果我们想要查询 `id=900001` 的记录，然后看下查询成本，我们可以直接在聚簇索引上进行查找：

```shell
mysql> select * from student_info where id = 900001;
 
+--------+------------+--------+-----------+----------+---------------------+
| id     | student_id | name   | course_id | class_id | create_time         |
+--------+------------+--------+-----------+----------+---------------------+
| 900001 |      40881 | LXFjgc |     10100 |    10087 | 2021-12-20 16:05:22 |
+--------+------------+--------+-----------+----------+---------------------+
1 row in set (0.03 sec)
```

运行结果（1 条记录，运行时间为 0.03s ）
然后再看下查询优化器的成本，实际上我们只需要检索一个页即可：

```shell
mysql> SHOW STATUS LIKE 'last_query_cost';
+-----------------+----------+
| Variable_name  | Value  |
+-----------------+----------+
| Last_query_cost | 1.000000 |
+-----------------+----------+
```

如果我们想要查询 id 在 900001 到 9000100 之间的学生记录呢？

```sql
SELECT student_id, class_id, NAME, create_time FROM student_info
WHERE id BETWEEN 900001 AND 900100;
```

运行结果（100 条记录，运行时间为 0.046s）：

然后再看下查询优化器的成本，这时我们大概需要进行 20 个页的查询。

```shell
mysql> SHOW STATUS LIKE 'last_query_cost';
+-----------------+-----------+
| Variable_name  | Value   |
+-----------------+-----------+
| Last_query_cost | 21.134453 |
+-----------------+-----------+
```

你能看到页的数量是刚才的 20 倍，但是查询的效率并没有明显的变化，实际上这两个 SQL 查询的时间基本上一样，就是因为采用了顺序读取的方式将页面一次性加载到缓冲池中，然后再进行查找。虽然 **页数量（last_query_cost）增加了不少** ，但是通过缓冲池的机制，并 **没有增加多少查询时间** 。

### 使用场景：它对于比较开销是非常有用的，特别是我们有好几种查询方式可选的时候。
> SQL 查询是一个动态的过程，从页加载的角度来看，我们可以得到以下两点结论：

1. **位置决定效率:** 如果页就在数据库缓冲池中，那么效率是最高的，否则还需要从内存或者磁盘中进行读取，当然针对单个页的读取来说，如果页存在于内存中，会比在磁盘中读取效率高很多。

2. **批量决定效率:** 如果我们从磁盘中对单一页进行随机读，那么效率是很低的（差不多10ms），而采用顺序读取的方式，批量对页进行读取，平均一页的读取效率就会提升很多，甚至要快于单个页面在内存中的随机读取。

所以说，遇到 I/O 并不用担心，方法找对了，效率还是很高的。我们首先要考虑数据存放的位置，如果是经常使用的数据就要尽量放到缓冲池中，其次我们可以充分利用磁盘的吞吐能力，一次性批量读取数据，这样单个页的读取效率也就得到了提升。

# 4. 定位执行慢的SQL：慢查询日志
MySQL的慢查询日志，用来记录在MySQL中响应时间超过阈值的语句，具体指运行时间超过 **long_query_time** 的值的 SQL，则会被记录到慢查询日志中。**long_query_time** 的默认值为10，意思是运行10秒以上（不含10秒）的语句，认为是超出了我们的最大忍耐时间值。

它的主要作用是，帮助我们发现那些执行时间特别长的SQL查询语句，并且有针对性地进行优化，从而提高系统的整体效率。当我们的数据库服务器发生阻塞、运行变慢的时候，检查一下慢查询日志，找到那些慢查询sql，对解决问题很有帮助。比如一条SQL执行超过5秒钟，我们就算慢SQL，希望能收集超过5秒的sql，结合explain进行全面分析。

默认情况下，MySQL数据库没有开启慢查询日志，需要我们手动来设置这个参数。如果不是调优需要的话，一般不建议启动该参数，因为开启慢查询日志会或多或少带来一定的性能影响。

慢查询日志支持将日志记录写入文件。

## 4.1 开启慢查询日志参数
### 1. 开启 `slow_query_log`

在使用前，我们需要先看下慢查询是否已经开启，使用下面这条命令即可:

```sql
set global slow_query_log='ON';
```

然后我们再来查看下慢查询日志是否开启，以及慢查询日志文件的位置：

```sql
show variables like '%slow_query_log%';
```

![](./images/2402456-20220611163057186-1770010563.png "")

> 你能看到这时慢查询分析已经开启，同时文件保存在 `/var/lib/mysql/atguigu1-slow.log` 文件中

### 2. 修改long_query_time阈值

接下来我们来看下慢查询的时间阈值设置，使用如下命令：

```sql
show variables like '%long_query_time%';
```

![](./images/2402456-20220611163056947-516006204.png "")

这里如果我们想把时间缩短，比如设置为 1 秒，可以这样设置：

```sql
-- 测试发现：设置global的方式对当前session的long_query_time失效。对新连接的客户端-- 有效。所以可以一并 执行下述语句  
set global long_query_time = 1; 
show global variables like '%long_query_time%'; 
```

### 补充:配置文件中一并设置参数

如下的方式相较于前面的命令行方式，可以看作是永久设置的方式。

修改 **my .cnf** 文件，[mysqld]下增加或修改参数 `long_query_time 、slow_query_log 和 slow_query_log_file` 后，然后重启MySQL服务器。

```shell
[mysqld]
slow_query_log=ON   #开启慢查询日志的开关
slow.query_log_file=/var/lib/mysq1/atguigu-slow.log  #慢查询日志的目录和文件名信息
long.query_time=3  #设置慢查询的阈值为3秒，超出此设定值的SQL即被记录到慢查询日志
log_output=FILE
```

> 如果不指定存储路径，慢查询日志将默认存储到MySQL数据库的数据文件夹下。如果不指定文件名，默认文件名为 **hostname-slow.log**

## 4.2 查看慢查询数目
查询当前系统中有多少条慢查询记录

```sql
SHOW GLOBAL STATUS LIKE '%Slow_queries%';
```

## 4.3 案例演示
### 步骤1. 建表

```sql
CREATE TABLE `student` (
    `id` INT(11) NOT NULL AUTO_INCREMENT,
    `stuno` INT NOT NULL ,
    `name` VARCHAR(20) DEFAULT NULL,
    `age` INT(3) DEFAULT NULL,
    `classId` INT(11) DEFAULT NULL,
PRIMARY KEY (`id`)
) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;
```

### 步骤2：创建函数

随机产生字符串：（同上一章）

```sql
DROP FUNCTION IF EXISTS atguigudb1.rand_string;

DELIMITER $$
$$
CREATE DEFINER=`root`@`localhost` FUNCTION `atguigudb1`.`rand_string`(n INT) RETURNS varchar(255) CHARSET utf8mb4
BEGIN 
	DECLARE chars_str VARCHAR(100) DEFAULT 'abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ';
	DECLARE return_str VARCHAR(255) DEFAULT '';
	DECLARE i INT DEFAULT 0;
	WHILE i < n DO
		SET return_str = CONCAT(return_str,SUBSTRING(chars_str, FLOOR(1 + RAND() * 52), 1));
		SET i = i + 1;
	END WHILE;
	RETURN return_str;
END $$
DELIMITER ;

#测试
SELECT rand_string(10);
```

产生随机数值：（同上一章）

```sql
DROP FUNCTION IF EXISTS atguigudb1.rand_num;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` FUNCTION `atguigudb1`.`rand_num`(from_num INT ,to_num INT) RETURNS int
BEGIN
	DECLARE i INT DEFAULT 0; 
	SET i = FLOOR(from_num + RAND() * (to_num - from_num + 1));
	RETURN i; 
END $$
DELIMITER ;

#测试：
SELECT rand_num(10,100);
```

##### 创建函数，假如报错：
```text
This function has none of DETERMINISTIC......
```

命令开启：允许创建函数设置：

```sql
set global log_bin_trust_function_creators=1;
```

### 步骤4：创建存储过程
```sql
DROP PROCEDURE IF EXISTS atguigudb1.insert_stu1;

DELIMITER $$
$$
CREATE PROCEDURE atguigudb1.insert_stu1(START INT , max_num INT)
BEGIN 
	DECLARE i INT DEFAULT 0; 
	SET autocommit = 0; #设置手动提交事务
	REPEAT	#循环
	SET i = i + 1;	#赋值
		INSERT INTO student (stuno, NAME ,age ,classId ) VALUES ((START+i),rand_string(6),rand_num(10,100),rand_num(10,1000)); 
	UNTIL i = max_num 
	END REPEAT; 
	COMMIT;	#提交事务
END $$
DELIMITER ;
```

### 步骤5：调用存储过程
```sql
-- 调用刚刚写好的函数, 4000000条记录,从100001号开始
CALL insert_stu1(100001,4000000);
```
## 4.4 测试及分析
### 测试
```shell
mysql> SELECT * FROM student WHERE stuno = 3455655;
+---------+---------+--------+------+---------+
| id   | stuno  | name  | age | classId |
+---------+---------+--------+------+---------+
| 3523633 | 3455655 | oQmLUr |  19 |    39 |
+---------+---------+--------+------+---------+
1 row in set (2.09 sec)
```
 
```shell
mysql> SELECT * FROM student WHERE name = 'oQmLUr';
+---------+---------+--------+------+---------+
| id   | stuno  | name  | age | classId |
+---------+---------+--------+------+---------+
| 1154002 | 1243200 | OQMlUR |  266 |    28 |
| 1405708 | 1437740 | OQMlUR |  245 |   439 |
| 1748070 | 1680092 | OQMlUR |  240 |   414 |
| 2119892 | 2051914 | oQmLUr |  17 |    32 |
| 2893154 | 2825176 | OQMlUR |  245 |   435 |
| 3523633 | 3455655 | oQmLUr |  19 |    39 |
+---------+---------+--------+------+---------+
6 rows in set (2.39 sec)
```

> 从上面的结果可以看出来，查询学生编号为 `3455655` 的学生信息花费时间为 `2.09`秒。查询学生姓名为 `oQmLUr` 的学生信息花费时间为 `2.39` 秒。已经达到了秒的数量级，说明目前查询效率是比较低的，下面的小节我们分析一下原因。

### 分析
```shell
mysql> show status like 'slow_queries';
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| Slow_queries  | 2     |
+---------------+-------+
1 row in set (0.00 sec)
```

##### 补充说明:

除了上述变量，控制慢查询日志的还有一个系统变量: min_examined_row_limit。这个变量的意思是，查询 **扫描过的最少记录数** 。这个变量和查询执行时间，共同组成了判别一个查询是否是慢查询的条件。如果查询扫描过的记录数大于等于这个变量的值，并且查询执行时间超过`long_query_time` 的值，那么，这个查询就被记录到慢查询日志中;反之，则不被记录到慢查询日志中。

![](./images/2402456-20220611163056682-1189492312.png "")

这个值默认是0。与 `long_query_time=10` 合在一起，表示只要查询的执行时间超过10秒钟，哪怕一个记录也没有扫描过，都要被记录到慢查询日志中。你也可以根据需要，通过修改"my.ini""文件，来修改查询时长，或者通过SET指令，用SQL语句修改"min_examined_row_limit"的值。

## 4.5 慢查询日志分析工具：mysqldumpslow
在生产环境中，如果要手工分析日志，查找、分析SQL，显然是个体力活，MySQL提供了日志分析工具 `mysqldumpslow` 。

查看mysqldumpslow的帮助信息

```shell
mysqldumpslow --help
```

![](./images/2402456-20220611163056401-1144837486.png "")

- mysqldumpslow 命令的具体参数如下：
    - -a: 不将数字抽象成N，字符串抽象成S
    - -s: 是表示按照何种方式排序：
    - c: 访问次数
    - l: 锁定时间
    - r: 返回记录
    - t: 查询时间
    - al:平均锁定时间
    - ar:平均返回记录数
    - at:平均查询时间 （默认方式）
    - ac:平均查询次数
    - -t: 即为返回前面多少条的数据；
    - -g: 后边搭配一个正则匹配模式，大小写不敏感的；

举例：我们想要按照查询时间排序，查看前五条 SQL 语句，这样写即可：

```shell
mysqldumpslow -s t -t 5 /var/lib/mysql/atguigu1-slow.log
```

```shell
[root@bogon ~]# mysqldumpslow -s t -t 5 /var/lib/mysql/atguigu1-slow.log
Reading mysql slow query log from /var/lib/mysql/atguigu01-slow.log
Count: 1  Time=2.39s (2s)  Lock=0.00s (0s) Rows=13.0 (13), root[root]@localhost
 SELECT * FROM student WHERE name = 'S'
Count: 1  Time=2.09s (2s)  Lock=0.00s (0s) Rows=2.0 (2), root[root]@localhost
 SELECT * FROM student WHERE stuno = N
Died at /usr/bin/mysqldumpslow line 162, <> chunk 2.
```

### 工作常用参考：
```shell
#得到返回记录集最多的10个SQL 
mysqldumpslow -s r -t 10 /var/lib/mysql/atguigu1-slow.log 

#得到访问次数最多的10个SQL 
mysqldumpslow -s c -t 10 /var/lib/mysql/atguigu1-slow.log

#得到按照时间排序的前10条里面含有左连接的查询语句 
mysqldumpslow -s t -t 10 -g "left join" /var/lib/mysql/atguigu1-slow.log 

#另外建议在使用这些命令时结合 | 和more 使用 ，否则有可能出现爆屏情况 
mysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log | more
```

## 4.6 关闭慢查询日志
MySQL服务器停止慢查询日志功能有两种方法：

### 方式1：永久性方式
```shell
[mysqld] 
slow_query_log=OFF
```

或者，把slow_query_log一项注释掉 或 删除

```shell
[mysqld]
#slow_query_log =OFF
```

重启MySQL服务，执行如下语句查询慢日志功能。

```shell
SHOW VARIABLES LIKE '%slow%';  #查询慢查询日志所在目录
SHOW VARIABLES LIKE '%long_query_time%';  #查询超时时长
```

### 方式2：临时性方式
使用SET语句来设置。

##### （1）停止MySQL慢查询日志功能，具体SQL语句如下。
```sql
SET GLOBAL slow_query_log=off;
```
##### （2）重启MySQL服务，使用SHOW语句查询慢查询日志功能信息，具体SQL语句如下
```sql
SHOW VARIABLES LIKE '%slow%';
#以及
SHOW VARIABLES LIKE '%long_query_time%';
```

## 4.7 删除慢查询日志
使用SHOW语句显示慢查询日志信息，具体SQL语句如下。

```sql
SHOW VARIABLES LIKE 'slow_query_log%';
```

![](./images/2402456-20220611163056161-518598455.png "")

从执行结果可以看出，慢查询日志的目录默认为MySQL的数据目录，在该目录下 **手动删除慢查询日志文件** 即可。使用命令 `mysqladmin flush-logs` 来重新生成查询日志文件，具体命令如下，执行完毕会在数据目录下重新生成慢查询日志文件。

```shell
mysqladmin -root -p flush-logs slow
```

> **提示：**
> - 慢查询日志都是使用 `mysqladmin flush-logs` 命令来删除重建的。使用时一定要注意，一旦执行了这个命令，慢查询日志都只存在新的日志文件中，如果需要旧的查询日志，就必须事先备份。

# 5. 查看 SQL 执行成本：SHOW PROFILE
show profile在《逻辑架构》章节中讲过，这里作为复习。

Show Profile是MySQL提供的可以用来分析当前会话中SQL都做了什么、执行语句资源消耗情况的工具，可用于sql调优的测量。默认情况下处于关闭状态，并保存最近15次的运行结果。

我们可以在会话级别开启这个功能

```sql
show variables like 'profiling';
```

![](./images/2402456-20220611163055918-137123187.png "")

通过设置 profiling='ON’ 来开启 show profile：

```sql
set profiling = 'ON';
```

![](./images/2402456-20220611163055667-1164299501.png "")

然后执行相关的查询语句。接着看下当前会话都有哪些 profiles，使用下面这条命令：

```sql
show profiles;
```

![](./images/2402456-20220611163055406-1607349789.png "")

你能看到当前会话一共有 2 个查询。如果我们想要查看最近一次查询的开销，可以使用：

```sql
show profile;
```

![](./images/2402456-20220611163055105-623397091.png "")

我们也可以查看指定的Query ID的开销，比如 show profile for query 2 查询结果是一样的。在SHOW PROFILE 中我们可以查看不同部分的开销，比如cpu、block.io等:

```sql
show profile cpu,block io for query 2;
```

![](./images/2402456-20220611163054793-2141970373.png "")

### show profile 的常用查询参数：
① ALL：显示所有的开销信息。

② BLOCK IO：显示块IO开销。

③ CONTEXT SWITCHES：上下文切换开销。

④ CPU：显示CPU开销信息。

⑤ IPC：显示发送和接收开销信息。

⑥ MEMORY：显示内存开销信息。

⑦ PAGE FAULTS：显示页面错误开销信息。

⑧ SOURCE：显示和Source_function，Source_file，Source_line相关的开销信息。

⑨ SWAPS：显示交换次数开销信息。

### 日常开发需注意的结论:

①converting HEAP to MyISAM:查询结果太大，内存不够，数据往磁盘上搬了。

②Creating tmp table:创建临时表。先拷贝数据到临时表，用完后再删除临时表。

③Copying to tmp table on disk:把内存中临时表复制到磁盘上，警惕!

④locked。

> 如果在show profile诊断结果中出现了以上4条结果中的任何一条，则sql语句需要优化。

### 注意:

不过SHOW PROFILE命令将被弃用，我们可以从information_schema中的profiling数据表进行查看。

# 6. 分析查询语句：EXPLAIN
## 6.1 概述
定位了查询慢的SQL之后，我们就可以使用EXPLAIN或 DESCRIBE 工具做针对性的分析查询语句。DESCRIBE语句的使用方法与EXPLAIN语句是一样的，并且分析结果也是一样的。

MySQL中有专门负责优化 SELECT 语句的优化器模块，主要功能：通过计算并分析系统中收集到的统计信息，为客户端请求的Query提供它认为最优的 **执行计划** (他认为最优的数据检索方式，但不见得是DBA认为是最优的，这部分最耗费时间)。

这个执行计划展示了接下来具体执行查询的方式，比如多表连接的顺序是什么，对于每个表采用什么访问方法来执行查询等等。MySQL为我们提供了 EXPLAIN 语句来帮助我们查看某个查询语句的具体执行计划，大家看懂 EXPLAIN 语句的各个输出项，可以有针对性的提升我们查询语句的性能。

##### 1. 能做什么?
- 表的读取顺序
- 数据读取操作的操作类型
- 哪些索引可以使用
- 哪些索引被实际使用
- 表之间的引用
- 每张表有多少行被优化器查

##### 2. 官网介绍
![](./images/2402456-20220611163054437-1512143686.png "")

- 版本情况
    - MySQL 5.6.3以前只能 EXPLAIN SELECT ；MYSQL 5.6.3以后就可以 EXPLAIN SELECT，UPDATE，DELETE
    - 在5.7以前的版本中，想要显示 partitions 需要使用 explain partitions 命令；想要显示 filtered 需要使用 explain extended 命令。在5.7版本后，默认explain直接显示partitions和filtered中的信息。

## 6.2 基本语法
EXPLAIN 或 DESCRIBE语句的语法形式如下：

```sql
EXPLAIN SELECT select_options 
#或者
DESCRIBE SELECT select_options
```

如果我们想看看某个查询的执行计划的话，可以在具体的查询语句前边加一个 EXPLAIN ，就像这样：

```sql
EXPLAIN SELECT 1 FROM DUAL;
```

![](./images/2402456-20220611163053925-711276488.png "")

输出的上述信息就是所谓的 执行计划 。在这个执行计划的辅助下，我们需要知道应该怎样改进自己的查询语句以使得执行起来更高效。其实除了以 SELECT 开头的查询语句，其余的 DELETE、INSERT、REPLACE 以及 UPDATE 语句等都可以加上EXPLAIN，用来查看这些语句的执行计划，只是平时我们对SELECT语句更感兴趣。

> 注意：执行EXPLAIN时并没有真正的执行该后面的语句，因此可以安全的查看执行计划。

### EXPLAIN 语句输出的各个列的作用如下：

| 列名 | 描述 |
|---|---|
| id | 在一个大的查询语句中每个SELECT关键字都对应一个唯一的id |
| select_type | SELECT关键字对应的那个查询的类型 |
| table	| 表名 |
| partitions | 匹配的分区信息 |
| type | 针对单表的访问方法 |
| possible_keys | 可能用到的索引 |
| key | 实际上使用的索引 |
| key_len | 实际使用到的索引长度 |
| ref | 当使用索引列等值查询时，与索引列进行等值匹配的对象信息 |
| rows | 预估的需要读取的记录条数 |
| filtered | 某个表经过搜索条件过滤后剩余记录条数的百分比 |
| Extra | 一些额外的信息 |

> 在这里把它们都列出来只是为了描述一个轮廓，让大家有一个大致的印象。

## 6.3 数据准备

### 建表
```sql
use atguigudb1;
 
CREATE TABLE s1 (
	id INT,
	key1 VARCHAR (100),
	key2 INT,
	key3 VARCHAR (100),
	key_part1 VARCHAR (100),
	key_part2 VARCHAR (100),
	key_part3 VARCHAR (100),
	common_field VARCHAR (100),
	PRIMARY KEY (id),
	INDEX idx_key1 (key1),
	UNIQUE INDEX idx_key2 (key2),
	INDEX idx_key3 (key3),
	INDEX idx_key_part (key_part1, key_part2, key_part3) 
) ENGINE = INNODB CHARSET = utf8;
 
 
CREATE TABLE s2 (
	id INT AUTO_INCREMENT,
	key1 VARCHAR ( 100 ),
	key2 INT,
	key3 VARCHAR ( 100 ),
	key_part1 VARCHAR ( 100 ),
	key_part2 VARCHAR ( 100 ),
	key_part3 VARCHAR ( 100 ),
	common_field VARCHAR ( 100 ),
	PRIMARY KEY ( id ),
	INDEX idx_key1 ( key1 ),
	UNIQUE INDEX idx_key2 ( key2 ),
	INDEX idx_key3 ( key3 ),
	INDEX idx_key_part ( key_part1, key_part2, key_part3 ) 
) ENGINE = INNODB CHARSET = utf8;
```

### 设置参数 log_bin_trust_function_creators
创建函数，假如报错，需开启如下命令：允许创建函数设置：

```sql
set global log_bin_trust_function_creators=1;   # 不加global只是当前窗口有效
```

### 创建函数
```sql
DROP FUNCTION IF EXISTS atguigudb1.rand_string1;

DELIMITER $$
$$
CREATE FUNCTION atguigudb1.rand_string1(n INT)
RETURNS VARCHAR(255) #该函数会返回一个字符串
BEGIN
	DECLARE chars_str VARCHAR(100) DEFAULT
'abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ';
	DECLARE return_str VARCHAR(255) DEFAULT '';
	DECLARE i INT DEFAULT 0;
	WHILE i < n DO
		SET return_str =CONCAT(return_str,SUBSTRING(chars_str,FLOOR(1+RAND()*52),1));
		SET i = i + 1;
	END WHILE;
	RETURN return_str;
END$$
DELIMITER ;
```

### 创建存储过程

创建往s1表中插入数据的存储过程：

```sql
DROP PROCEDURE IF EXISTS atguigudb1.insert_s1;

DELIMITER $$
$$
CREATE PROCEDURE atguigudb1.insert_s1(IN min_num INT (10),IN max_num INT (10))
BEGIN
DECLARE i INT DEFAULT 0;
SET autocommit = 0;
REPEAT
SET i = i + 1;
INSERT INTO s1 VALUES(
	(min_num + i),
	rand_string1(6),
	(min_num + 30 * i + 5),
	rand_string1(6),
	rand_string1(10),
	rand_string1(5),
	rand_string1(10),
	rand_string1(10));
UNTIL i = max_num
END REPEAT;
COMMIT;
END$$
DELIMITER ;
```

创建往s2表中插入数据的存储过程：

```sql
DROP PROCEDURE IF EXISTS atguigudb1.insert_s2;

DELIMITER $$
$$
CREATE PROCEDURE atguigudb1.insert_s2(IN min_num INT ( 10 ),IN max_num INT ( 10 )) 
BEGIN
	DECLARE i INT DEFAULT 0;
	SET autocommit = 0;
	REPEAT
		SET i = i + 1;
		INSERT INTO s2 VALUES(
		( min_num + i ),
		rand_string1 ( 6 ),
		( min_num + 30 * i + 5 ),
		rand_string1 ( 6 ),
		rand_string1 ( 10 ),
		rand_string1 ( 5 ),
		rand_string1 ( 10 ),
		rand_string1 ( 10 )
		);
		UNTIL i = max_num 
	END REPEAT;
	COMMIT;
	
END$$
DELIMITER ;
```

### 调用存储过程

s1表数据的添加：加入1万条记录：

```sql
CALL insert_s1(10001,10000);
```

s2表数据的添加：加入1万条记录：

```sql
CALL insert_s2(10001,10000);
```

## 6.4 EXPLAIN各列作用
> 为了让大家有比较好的体验，我们调整了下 EXPLAIN 输出列的顺序。

### 1. table
當我們使用 `EXPLAIN` 來分析 MySQL 查詢時，它會回傳一張表格，這張表格每一列對應「一次對單一表的存取」，也就是說，不論你原始查詢涉及幾個表（JOIN、多層子查詢等），最後都會拆解成對每個表的單獨訪問行為，並逐列顯示這些行為的細節。

---

#### ✅ 第 1 欄：`table`
##### 💡 說明：
`table` 欄表示當前這一行描述的是哪個資料表的存取。  
- 通常是表的名稱；
- 若是子查詢或派生表，可能會出現「別名」或「臨時名稱」；
- 若使用了**物化子查詢（derived table）或 temporary table**，這邊會顯示該臨時表的代號（例如 `derived2` 或 `subquery1`）。

---

##### 🧪 範例：
假設你有以下兩個表：

```sql
CREATE TABLE students (
  id INT PRIMARY KEY,
  name VARCHAR(50),
  class_id INT
);

CREATE TABLE classes (
  id INT PRIMARY KEY,
  class_name VARCHAR(50)
);
```

查詢語句如下：

```sql
EXPLAIN
SELECT s.name, c.class_name
FROM students s
JOIN classes c ON s.class_id = c.id;
```

回傳的 EXPLAIN 表格中可能會看到如下內容：

| id | select_type | table  | type   | ... |
|----|-------------|--------|--------|-----|
| 1  | SIMPLE      | c      | ALL    | ... |
| 1  | SIMPLE      | s      | ref    | ... |

🔍 解釋：
- `table` 第一行顯示 `c`：這代表 MySQL 首先會處理 `classes` 表。
- `table` 第二行顯示 `s`：這代表它會根據 `s.class_id = c.id` 去查找 `students` 表。

如果你查詢用到了子查詢，會是這樣：

```sql
EXPLAIN
SELECT name
FROM students
WHERE class_id IN (
  SELECT id FROM classes WHERE class_name LIKE 'Math%'
);
```

| id | select_type | table     | type   | ... |
|----|-------------|-----------|--------|-----|
| 1  | PRIMARY     | students  | ALL    | ... |
| 2  | SUBQUERY    | classes   | range  | ... |

🔍 `table` 會顯示 `students` 與 `classes`，分別是主查詢與子查詢處理的表名。

---

### 2. id
當你使用 `EXPLAIN` 分析 SQL 查詢時，第二欄的 `id` 是非常關鍵的欄位，它代表的是 **「執行計劃中的一個步驟」** 或 **一趟獨立的查詢操作**。  
我們可以把 `id` 想像成「這一行是第幾個子查詢或子步驟的執行單位」。

---

#### 💡 說明總結：

| `id` 數值特性 | 說明 |
|---------------|------|
| 相同的 `id` 值 | 表示這些行屬於同一層查詢（同一趟查詢），按照從上到下執行 |
| `id` 數值越大 | 執行優先級越高，表示它會「**先被執行**」 |
| 不同的 `id` | 表示不同層級的查詢（例如主查詢 vs 子查詢） |

---

#### 🧪 範例 1：簡單單表查詢
```sql
EXPLAIN
SELECT * FROM students WHERE class_id = 1;
```

| id | select_type | table    | ... |
|----|-------------|----------|-----|
| 1  | SIMPLE      | students | ... |

🔍 說明：
- `id = 1`，表示整體只有一趟查詢。

---

#### 🧪 範例 2：JOIN 查詢（還是只有一趟）
```sql
EXPLAIN
SELECT s.name, c.class_name
FROM students s
JOIN classes c ON s.class_id = c.id;
```

| id | select_type | table  | ... |
|----|-------------|--------|-----|
| 1  | SIMPLE      | c      | ... |
| 1  | SIMPLE      | s      | ... |

🔍 說明：
- 雖然查詢兩個表，但 `id` 都是 1，代表這是同一趟查詢，MySQL 會按照順序處理 `c` 和 `s` 表。

---

#### 🧪 範例 3：含子查詢的 SELECT
```sql
EXPLAIN
SELECT name FROM students
WHERE class_id IN (
  SELECT id FROM classes WHERE class_name LIKE 'Math%'
);
```

| id | select_type | table    | ... |
|----|-------------|----------|-----|
| 1  | PRIMARY     | students | ... |
| 2  | SUBQUERY    | classes  | ... |

🔍 說明：
- `id = 2` 的子查詢會 **先執行**，因為它數字比較大；
- 然後才是 `id = 1` 的主查詢。

---

#### 🧪 範例 4：更複雜的嵌套查詢
```sql
EXPLAIN
SELECT * FROM students
WHERE class_id IN (
  SELECT id FROM classes
  WHERE teacher_id IN (
    SELECT id FROM teachers WHERE name = 'Ms. Wang'
  )
);
```

| id | select_type | table     | ... |
|----|-------------|-----------|-----|
| 1  | PRIMARY     | students  | ... |
| 2  | SUBQUERY    | classes   | ... |
| 3  | SUBQUERY    | teachers  | ... |

🔍 說明：
- `id = 3`（最內層子查詢）會先執行；
- 然後 `id = 2`（查 classes）使用上層結果；
- 最後 `id = 1`（主查詢）再依據 class_id 去查 students。

---

#### 📌 重點提醒：
- `id` **不是代表資料表順序，而是執行步驟順序**。
- 一個查詢語句的 `id` 數量越多，代表這個查詢越複雜；
- 查詢次數越多，對效能越不利（可優化的潛力也越大）。

---

### 3. select_type
#### 💡 說明：

`select_type` 表示 **這一行所屬的 SELECT 語句的類型**，也就是它在整個 SQL 執行計畫中扮演的角色。  
每一個 `SELECT` 關鍵字都會被 MySQL 當成一個「小查詢單位」，系統會給這個小查詢一個 select_type。

---

#### 🧩 常見的 `select_type` 類型

| 類型名稱 | 說明 |
|----------|------|
| `SIMPLE` | 不包含子查詢或 UNION 的簡單查詢 |
| `PRIMARY` | 最外層的 SELECT，包含子查詢或 UNION 時的主查詢 |
| `SUBQUERY` | 被包含在 `SELECT`, `WHERE`, 或 `HAVING` 中的子查詢 |
| `DERIVED` | 從 FROM 子句中出現的子查詢（也就是派生表、臨時表） |
| `UNION` | UNION 中的第二個 SELECT（及之後的） |
| `UNION RESULT` | 代表整個 UNION 結果集的臨時表 |
| `DEPENDENT SUBQUERY` | 子查詢依賴於外層查詢（外層值變了，它會重跑） |
| `DEPENDENT UNION` | 同上，用在 UNION 裡的子查詢 |
| `MATERIALIZED` | 表示使用了物化子查詢（MySQL 8.0+ 的新優化方式） |
| `UNCACHEABLE SUBQUERY` | 子查詢中有變數，導致不能快取 |

---

#### 🧪 範例 1：簡單查詢
```sql
EXPLAIN SELECT * FROM students WHERE id = 1;
```

| id | select_type | table    | ... |
|----|-------------|----------|-----|
| 1  | SIMPLE      | students | ... |

🔍 `SIMPLE` → 單表查詢，沒子查詢、沒 UNION。

---

#### 🧪 範例 2：子查詢在 WHERE 子句中
```sql
EXPLAIN
SELECT name FROM students
WHERE class_id IN (
  SELECT id FROM classes WHERE class_name LIKE 'Math%');
```

| id | select_type | table    | ... |
|----|-------------|----------|-----|
| 1  | PRIMARY     | students | ... |
| 2  | SUBQUERY    | classes  | ... |

🔍 `PRIMARY` 是最外層查詢；`SUBQUERY` 是 WHERE 子句裡的內部 SELECT。

---

#### 🧪 範例 3：FROM 子句中有子查詢（派生表）
```sql
EXPLAIN
SELECT * FROM (
  SELECT * FROM students WHERE class_id = 1
) AS s1;
```

| id | select_type | table    | ... |
|----|-------------|----------|-----|
| 1  | PRIMARY     | <derived2> | ... |
| 2  | DERIVED     | students | ... |

🔍 外層查詢是 `PRIMARY`；  
內層 `FROM (...)` 是 `DERIVED` → MySQL 會物化成一個臨時表處理。

---

#### 🧪 範例 4：UNION 查詢
```sql
EXPLAIN
(SELECT id FROM students WHERE class_id = 1)
UNION
(SELECT id FROM students WHERE class_id = 2);
```

| id | select_type     | table    | ... |
|----|------------------|----------|-----|
| 1  | PRIMARY          | students | ... |
| 2  | UNION            | students | ... |
| NULL | UNION RESULT   | <union1> | ... |

🔍
- 第一個 SELECT 是 `PRIMARY`
- 第二個是 `UNION`
- `UNION RESULT` 表示合併結果的臨時表（通常 `table` 顯示 `<union1>`）

---

#### 🧠 小技巧總結：
- 查詢越複雜，`select_type` 越能幫你快速了解整體結構。
- `DERIVED`, `SUBQUERY`, `UNION` 等值的出現通常代表著可以優化的空間，例如將子查詢改寫成 JOIN。

---

### 4. partitions（了解）
#### 💡 說明：

- `partitions` 表示：**這條查詢會掃描哪些分區（partition）**。
- 如果這張表是「**分區表（Partitioned Table）**」，這個欄位就會顯示匹配的分區名稱；
- 如果是「**非分區表**」，這一欄會是 `NULL`。

---

#### 🧪 範例：手動測試分區查詢命中情況

##### Step 1️⃣ 建立分區表（按 `id` 範圍分區）
```sql
CREATE TABLE user_partitions (
  id INT AUTO_INCREMENT,
  name VARCHAR(12),
  PRIMARY KEY(id)
)
PARTITION BY RANGE(id)(
  PARTITION p0 VALUES LESS THAN (100),
  PARTITION p1 VALUES LESS THAN MAXVALUE
);
```

##### Step 2️⃣ 查詢執行計畫（命中某個分區）
```sql
EXPLAIN
SELECT * FROM user_partitions WHERE id > 200;
```

###### 查詢結果可能如下：

| id | select_type | table           | partitions | type | ... |
|----|-------------|------------------|------------|------|-----|
| 1  | SIMPLE      | user_partitions  | p1         | range | ... |

🔍 `partitions = p1`：表示這次查詢只會掃描 `p1` 分區（也就是 `id >= 100` 的資料）。

---

#### 🧪 範例：不命中任何分區（WHERE 條件不符）
```sql
EXPLAIN
SELECT * FROM user_partitions WHERE id < 50;
```

| id | select_type | table           | partitions | type | ... |
|----|-------------|------------------|------------|------|-----|
| 1  | SIMPLE      | user_partitions  | p0         | range | ... |

🔍 `partitions = p0`：這次只掃描 `p0` 分區（`id < 100`）

---

#### 🧪 範例：無法確定命中的分區（使用變數）
```sql
SET @x = 150;
EXPLAIN
SELECT * FROM user_partitions WHERE id < @x;
```

| id | select_type | table           | partitions | type | ... |
|----|-------------|------------------|------------|------|-----|
| 1  | SIMPLE      | user_partitions  | p0,p1      | range | ... |

🔍 `partitions = p0,p1`：因為 `@x` 是變數，MySQL 編譯階段無法提前預測它的值，所以會掃描所有分區。

---

#### 🧠 小補充：分區命中越精準 → 效能越好

使用分區表時：
- 若 `EXPLAIN` 的 `partitions` 欄只命中一個分區 → 查詢效率最好；
- 命中多個分區 → 雖然比全表好，但可能還有優化空間；
- 出現 `NULL` → 表示不是分區表，這個欄位沒作用。

---

#### 📌 小結

| 查詢方式 | partitions 欄位 | 效能 |
|----------|------------------|------|
| 命中單一分區 | `p1` 或 `p0` 等 | ✅ 最佳 |
| 命中多個分區 | `p0,p1` 等       | ⚠️ 中等 |
| 非分區表     | `NULL`           | 🆗 無此欄位意義 |

---

### 5. type（重点）
> 這個欄位描述 MySQL **如何存取某一個表中的資料**。  
> - 依據存取方式的不同，查詢效能可能差非常多，從一筆查詢資料的效率（如 `const`）到全表掃描（如 `ALL`）。

---

#### 🧩 `type` 值從好到壞（效能由高到低）：

| 優先級 | 類型 | 解釋 |
|--------|------|------|
| ✅ 1 | `system` | 表只有一筆資料，非常快（特殊情況） |
| ✅ 2 | `const` | 主鍵或唯一索引匹配常數，只會有一筆結果 |
| ✅ 3 | `eq_ref` | 單筆資料查詢，通常出現在 JOIN 中主鍵或唯一索引匹配 |
| ✅ 4 | `ref` | 非唯一索引匹配，會返回多筆結果（常見於 JOIN） |
| ✅ 5 | `fulltext` | 使用全文索引搜尋 |
| ⚠️ 6 | `ref_or_null` | 與 `ref` 類似，但還會查 `NULL` |
| ⚠️ 7 | `index_merge` | 合併多個索引查詢（不一定比 `ref` 好） |
| ⚠️ 8 | `unique_subquery` | 子查詢返回唯一結果，用於 IN 子句的優化 |
| ⚠️ 9 | `index_subquery` | 與 `unique_subquery` 類似但非唯一 |
| ⚠️ 10 | `range` | 使用索引範圍查詢（例如 BETWEEN、>、<） |
| ⚠️ 11 | `index` | 全索引掃描（沒用到 WHERE 過濾） |
| ❌ 12 | `ALL` | 全表掃描，效能最差 |

---

#### 🧪 範例解析：

##### 範例資料表：
```sql
CREATE TABLE students (
  id INT PRIMARY KEY,
  name VARCHAR(50),
  class_id INT,
  INDEX idx_class (class_id)
);
```

---

##### 📌 範例 1：`const`（最佳！）
```sql
EXPLAIN SELECT * FROM students WHERE id = 5;
```

| table    | type  | possible_keys | key | rows | Extra |
|----------|-------|---------------|-----|------|-------|
| students | const | PRIMARY        | PRIMARY | 1    | ...   |

🔍 解釋：
- 使用主鍵精確匹配 → `const`
- 最理想的查詢方式之一！

---

##### 📌 範例 2：`ref`（非常常見於 JOIN）
```sql
EXPLAIN SELECT * FROM students WHERE class_id = 2;
```

| table    | type | possible_keys | key        | rows | Extra |
|----------|------|---------------|------------|------|-------|
| students | ref  | idx_class     | idx_class  | 10   | ...   |

🔍 解釋：
- 使用 `class_id` 索引，但這不是唯一索引 → 多筆符合 → `ref`

---

##### 📌 範例 3：`range`（使用範圍查詢）
```sql
EXPLAIN SELECT * FROM students WHERE class_id BETWEEN 1 AND 5;
```

| table    | type  | key        | rows | Extra |
|----------|-------|------------|------|-------|
| students | range | idx_class  | ...  | ...   |

🔍 解釋：
- 使用範圍查詢 (`BETWEEN`) → 屬於 `range`

---

##### 📌 範例 4：`ALL`（最差，全表掃描）
```sql
EXPLAIN SELECT * FROM students WHERE name = 'Tom';
```

| table    | type | key  | rows | Extra |
|----------|------|------|------|-------|
| students | ALL  | NULL | 1000 | ...   |

🔍 解釋：
- `name` 沒有索引 → 只能用 `ALL` 全表掃描 → 效能很差 ❌

---

#### 🧠 小提醒：

##### ✅ 優化建議：
- **務必避免 `ALL`！**  
- 至少讓查詢達到 `range`，更理想是 `ref` 或 `const`；
- 若 EXPLAIN 顯示 `ALL`，就要思考是否該對欄位加索引，或改寫 SQL。

---

#### 🔧 查詢效能目標建議（對照阿里巴巴開發規範）：

| 效能等級 | 建議 | 達標說明 |
|----------|------|----------|
| 🟢 `const`、`eq_ref`、`ref` | ✅ 最佳查詢效能 | 索引有效使用 |
| 🟡 `range` | ⚠️ 可接受 | 範圍查詢較慢但仍使用索引 |
| 🔴 `index`、`ALL` | ❌ 不建議 | 未善用索引，查詢代價高 |

---

### 6. possible_keys和key

在EXPLAIN语句输出的执行计划中, possible_keys 列表示在某个查询语句中，对某个表执行 单表查询时可能用到的索引 有哪些。一般查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用。key 列表示 实际用到的索引 有哪些，如果为NULL，则没有使用索引。比方说下边这个查询：

```sql
EXPLAIN SELECT * FROM s1 WHERE key1 > 'z' AND key3 = 'a';
```

![](./images/2402456-20220611163046709-1465851848.png "")

### 7. key_len（重点）
#### 💡 意義：
> `key_len` 是 `EXPLAIN` 中非常有用的一個欄位，用來表示 **MySQL 實際用到了索引的長度（byte 數）**。這個長度越準確，代表使用索引的「覆蓋度」越高，有助於判斷是否完全用上了複合索引。

- `key_len` 表示 **MySQL 使用索引時實際用到的位元組長度（bytes）**
- 數值越小，不一定代表效能差，而是**表示用了幾個欄位進行匹配**
- 數值準確反映：MySQL 使用了複合索引的哪幾個欄位

---

#### ✳️ 搭配範例來說明：

##### 建立資料表與索引：

```sql
CREATE TABLE user_info (
  id INT NOT NULL,
  name VARCHAR(10) NOT NULL,
  email VARCHAR(20),
  PRIMARY KEY(id),
  KEY idx_name_email (name, email)
) CHARACTER SET utf8mb4;
```

---

##### 📌 查詢 1：只用到 name
```sql
EXPLAIN SELECT * FROM user_info WHERE name = 'Tom';
```

| key          | key_len |
|--------------|---------|
| idx_name_email | 42      |

🔍 解釋：

- `name VARCHAR(10)`，使用 `utf8mb4`：每字元 4 bytes
- 10 × 4 = 40 + 2（可變長欄位）= **42 bytes**
- 所以 `key_len = 42` → 使用了 `name` 欄位（第一個索引欄位）

---

##### 📌 查詢 2：name 和 email 都使用
```sql
EXPLAIN SELECT * FROM user_info WHERE name = 'Tom' AND email = 'a@b.com';
```

| key          | key_len |
|--------------|---------|
| idx_name_email | 42 + 82 = 124 |

🔍 解釋：

- `email VARCHAR(20)`：20 × 4 = 80 + 2（可變長欄位）= 82
- 加上 name 的 42：總共使用了 124 bytes
- 所以 `key_len = 124` → **完整使用了複合索引兩個欄位**

---

#### 🧮 `key_len` 計算規則：

##### ✳️ 針對不同欄位類型（整理版）

| 欄位型態 | 字元集 | NULL? | 計算方式（byte） |
|-----------|--------|-------|------------------|
| `char(N)` | utf8   | 否    | N × 3            |
| `char(N)` | utf8   | 是    | N × 3 + 1        |
| `varchar(N)` | utf8 | 否    | N × 3 + 2        |
| `varchar(N)` | utf8 | 是    | N × 3 + 2 + 1    |
| `int`     | -      | 否    | 4                |
| `int`     | -      | 是    | 5                |

- **+1** 是 NULL 標記位元（nullable 字段）
- **+2** 是可變長欄位的長度儲存開銷

---

#### 🧠 優化建議與用途

- `key_len` 可以幫你判斷 **複合索引是否「完全用上」**：
  - 如果你定義了 `(a, b, c)` 的索引，但 `key_len` 只對應到 `a`，表示查詢中只使用了第一個欄位
- 若你明明寫了 `WHERE a AND b`，卻只看到 `key_len` 代表 `a`，可能是 `b` 不符合範圍查詢或不是恰當的型態

---

### 8. ref
> `ref` 欄位描述的是：**MySQL 在查詢時，是用哪個值（常數 or 另一個欄位）去與索引進行比對的**。  
它**只會出現在使用索引等值比對**的存取方式下（例如：`type` 是 `const`、`eq_ref`、`ref`、`ref_or_null`...）。

---

#### 📌 `ref` 欄位常見的值型態：

| `ref` 值         | 說明 |
|------------------|------|
| `const`          | 和某個常數進行索引等值比對（如 `id = 1`） |
| `func`           | 使用了函數的結果 |
| `NULL`           | 沒有使用等值查詢 |
| `table.col_name` | 和另一張表的欄位進行等值比對（常見於 JOIN） |
| `field_func`     | 對某欄位使用了函數，如 `YEAR(date)` |

---

#### 🧪 多個範例解析

---

##### 📘 範例 1：等值匹配常數（`ref = const`）

```sql
CREATE TABLE students (
  id INT PRIMARY KEY,
  class_id INT,
  name VARCHAR(20),
  INDEX idx_class_id (class_id)
);
```

```sql
EXPLAIN SELECT * FROM students WHERE class_id = 101;
```

| table    | type | key          | ref   | rows | Extra |
|----------|------|--------------|-------|------|-------|
| students | ref  | idx_class_id | const | 10   | ...   |

🔍 解釋：
- `WHERE class_id = 101` 是常數匹配
- `ref = const`：表示用常數比對索引欄位

---

##### 📘 範例 2：JOIN 用另一張表欄位做匹配（`ref = 表.欄位`）

```sql
CREATE TABLE classes (
  id INT PRIMARY KEY,
  name VARCHAR(50)
);

-- 查詢：JOIN student 和 class
EXPLAIN
SELECT s.* FROM students s
JOIN classes c ON s.class_id = c.id;
```

| table    | type   | key          | ref        | rows | Extra |
|----------|--------|--------------|------------|------|-------|
| classes  | index  | PRIMARY      | NULL       | ...  |       |
| students | ref    | idx_class_id | c.id       | ...  |       |

🔍 解釋：
- `ON s.class_id = c.id` 是用「另一個表的欄位」比對索引
- `ref = c.id` → 很常見於 JOIN 查詢

---

##### 📘 範例 3：多欄位複合索引匹配其中一欄

```sql
CREATE TABLE orders (
  id INT PRIMARY KEY,
  customer_id INT,
  order_date DATE,
  INDEX idx_composite (customer_id, order_date)
);
```

```sql
EXPLAIN SELECT * FROM orders WHERE customer_id = 5;
```

| table  | type | key           | ref   | rows | Extra |
|--------|------|---------------|-------|------|-------|
| orders | ref  | idx_composite | const | ...  |       |

🔍 解釋：
- 雖然是複合索引 `(customer_id, order_date)`，但只用到 `customer_id`
- `ref = const`：仍然等值匹配，但沒有覆蓋到整個索引

---

##### 📘 範例 4：`ref = func`（使用函數，無法使用索引）

```sql
EXPLAIN SELECT * FROM students WHERE YEAR(class_id) = 2024;
```

| table    | type | key  | ref  | rows | Extra              |
|----------|------|------|------|------|--------------------|
| students | ALL  | NULL | NULL | 1000 | Using where        |

🔍 解釋：
- 使用 `YEAR(class_id)` → 索引失效
- `ref = NULL`，實際是全表掃描 → `type = ALL`

---

#### 🧠 重點總結

| 情境             | ref 顯示        | type           |
|------------------|------------------|----------------|
| 常數比對索引     | `const`          | `ref`, `const` |
| JOIN 等值比對    | `table.column`   | `eq_ref`, `ref` |
| 索引失效         | `NULL`           | `ALL`（全表掃描） |
| 使用函數比對     | `func`           | 視情況而定      |

---

### 9. rows（重点）

预估的需要读取的记录条数

```sql
EXPLAIN SELECT * FROM s1 WHERE key1 > 'z';
```

![](./images/2402456-20220611163044473-1414009720.png "")

### 10. filtered
#### 💡 定義：

`filtered` 表示：
> **MySQL 預估某張表在應用完 `WHERE` 條件之後，留下來的記錄比例（%）**。

也就是說，如果 `rows` 預估有 1000 筆資料被掃描，而 `filtered = 10.0`，表示大約只有 `1000 × 10% = 100` 筆會通過過濾條件。

---

#### 🎯 使用時機：

- ✅ **單表查詢**：幫你了解篩選條件是否有效。
- ✅ **JOIN 查詢（重點）**：用來預估**被驅動表**（也就是 JOIN 右邊表）會被查詢幾次。

👉 **總查詢次數 ≈ 上一張表的 rows × filtered**

---

#### 🧪 範例解析

##### 📘 範例 1：單表查詢

```sql
EXPLAIN SELECT * FROM students WHERE age > 20 AND grade = 'A';
```

| table    | rows | filtered | Extra         |
|----------|------|----------|---------------|
| students | 1000 | 10.00    | Using where   |

🔍 解釋：
- `rows = 1000`：MySQL 預估會掃描 1000 筆
- `filtered = 10.00`：預估只有 10%（= 100 筆）會符合 `WHERE` 條件
- 用來評估「過濾效率」

---

##### 📘 範例 2：JOIN 查詢（重點！）

```sql
EXPLAIN
SELECT * FROM students s
JOIN classes c ON s.class_id = c.id
WHERE c.name = 'Math';
```

| id | table   | rows | filtered | Extra         |
|----|---------|------|----------|---------------|
| 1  | classes | 100  | 10.00    | Using where   |
| 1  | students| 1000 | 100.00   | Using index   |

🔍 解釋流程：

1. `classes` 是 **驅動表**，預估過濾後剩 `100 × 10% = 10 筆`
2. 每筆 `classes` 結果（c.id）都會去找 `students.class_id = c.id`
3. 因為 `students.filtered = 100.00`，所以每次都會完整執行一次查詢
4. 整體對 `students` 查詢次數為：**10 × 1 = 10 次**

---

#### 🧮 加強理解：filtered 是怎麼來的？

以這個查詢為例：

```sql
SELECT * FROM users WHERE age > 30 AND status = 'active';
```

假設：

- 資料總數為 10,000
- 索引用了 `status = 'active'`（這是 ref 查詢）
- 而 `age > 30` 不能用索引，只能逐筆過濾

那麼：
- `rows ≈ 2000`（根據索引抓出 2000 筆 status = 'active'）
- `filtered ≈ 25.0`（代表 age > 30 約佔 25%）

👉 所以預估最終結果筆數為：`2000 × 25% = 500`

---

#### 🧠 小結與優化提示

| 指標        | 說明 |
|-------------|------|
| `rows`      | 預估要掃描幾筆資料 |
| `filtered`  | 預估符合條件的比例 |
| `rows × filtered` | 預估最終符合條件的筆數（特別重要於 JOIN 被驅動表） |

🛠 **優化建議**：
- 如果 `filtered` 太低（如 0.1%），表示可能很多資料被無效掃描 → 應該優化索引
- JOIN 查詢中，被驅動表的 `filtered` × `rows` 決定效能關鍵 → 減少扇出值最有效

---

### 11. Extra（重要）
從這裡開始

# 補充內容
## ✅ 什麼是「分區表（Partitioned Table）」？

在 MySQL 中，「**分區表**」是指把一張大表的資料，**依據某個欄位的值**（例如 `id`、`日期` 等）**拆分成多個分區**（Partition）儲存。  
邏輯上它還是**一張表**，但底層在儲存時會分開管理。

> ✅ 這樣做的目的：是為了**提高查詢效率、改善大資料量的處理效能**。

---

### 🧠 分區的類型（最常見的）

| 類型 | 說明 | 常用情境 |
|------|------|-----------|
| RANGE | 根據某個欄位的「範圍」切分（例如 id<100、100<=id<200） | 連續 id、連續時間 |
| LIST  | 根據某個欄位的「具體值」切分（例如 `region IN ('north', 'south')`）| 區域、類型分類 |
| HASH  | 根據某個欄位做 hash 運算後分區 | 平均分布大量資料 |
| KEY   | 和 HASH 類似，但使用 MySQL 自己的 hash 演算法 | 自動 hash 分布 |

你目前使用的是最常見的 `RANGE` 分區。

---

### 🎯 分區表的應用場景

#### 📌 1. **歷史資料很多的表**
像是日誌表、訂單表、交易紀錄表等，如果資料量以「百萬筆、千萬筆」計的時候，建議使用「時間分區」。

```sql
PARTITION BY RANGE (YEAR(order_date)) (
  PARTITION p2021 VALUES LESS THAN (2022),
  PARTITION p2022 VALUES LESS THAN (2023),
  PARTITION pmax  VALUES LESS THAN MAXVALUE
);
```

#### 📌 2. **查詢條件明確（能命中特定分區）**
```sql
SELECT * FROM orders WHERE order_date >= '2022-01-01' AND order_date < '2023-01-01';
```
這樣就只會掃描 `p2022` 分區，而不會掃整張表！

---

### 🚀 分區表的效能優勢

| 功能面 | 說明 |
|--------|------|
| ✅ 加快查詢 | 查詢可以只掃描命中的分區（Partition Pruning） |
| ✅ 加快刪除 | `ALTER TABLE ... DROP PARTITION p2021` 一行就能砍整年的資料 |
| ✅ 資料管理方便 | 每個分區資料可以獨立儲存、備份 |
| ✅ 有效分攤 IO 壓力 | 尤其是用於磁碟型儲存時，幫助查詢「跳過不相干的資料」 |

---

### ⚠️ 使用分區的注意事項

1. **分區欄位必須是主鍵的一部分**
2. **有些操作不支援分區表**，例如外鍵（Foreign Key）不支援。
3. **資料分布不均會降低效能**：如果某些分區有太多資料，就失去了分區的效益。

---

### ✅ 小結：你什麼時候該用分區表？

| 情境 | 建議 |
|------|------|
| 表非常大（千萬筆以上） | ✅ 考慮分區 |
| 查詢條件通常根據 `時間`、`ID`、`類型` 篩選 | ✅ 用 `RANGE` 或 `LIST` |
| 每年、每月要定期清除資料 | ✅ 可以快速 `DROP PARTITION` |
| 表格很小 | ❌ 不需要分區，反而多此一舉 |

---