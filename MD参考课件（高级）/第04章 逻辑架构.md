# 1. 逻辑架构剖析
## 1.1 服务器处理客户端请求
### 🔧 MySQL 的邏輯架構（Logical Architecture）

MySQL 整體邏輯架構可概括為以下三層：

![](./images/2402456-20220611162545764-2071278868.png "")

#### **第一層：連接層（Connection Layer）**
- 負責接收客戶端連線請求，並進行身份驗證、權限檢查。
- 成功連接後會為每個連線建立一個對應的 **Thread 線程**。
- 同時負責管理一些快取（如查詢快取 Query Cache，MySQL 8.0 已移除）與 thread 資源。

🔸 **範例說明：**
```sql
-- 用戶透過 mysql 命令列連接資料庫
mysql -u root -p
```
系統會進行身份驗證，並為此用戶分配一個獨立線程。

---

#### **第二層：SQL 層（SQL Layer）**
這是 MySQL 的核心，處理各種 SQL 查詢語句的具體實作。

包含以下處理流程：

###### 1. **語法解析器（Parser）**
將 SQL 字串轉換為語法樹，若語法有誤就此結束。
```sql
SELECT * FROM employees WHERE id = 1;
```
會被解析成一棵抽象語法樹（AST）。

###### 2. **預處理（Preprocessor）**
驗證語法樹中的元素（表名、欄位名）是否存在，檢查用戶是否有權限等。

###### 3. **查詢優化器（Optimizer）**
針對語法樹進行查詢優化，例如：
- 選擇最佳的索引
- 決定表的連接順序（JOIN 的順序）

###### 4. **查詢執行計劃（Execution Plan）**
輸出優化後的執行策略，並交給執行器執行。

---

#### **第三層：存儲引擎層（Storage Engine Layer）**
- 負責實際的資料存取。
- MySQL 是一個 **插件式架構**，可支援多種儲存引擎（如 InnoDB、MyISAM、Memory 等）。
- 儲存引擎根據執行器傳來的指令，實際從磁碟或記憶體中取出資料。

🔸 **範例：** 儲存引擎 InnoDB 收到「讀取 id=1 的員工資料」請求，從資料頁中查找並返回資料給上層。

---

### 🎯 查詢請求範例說明

假設你執行：
```sql
SELECT name FROM employees WHERE id = 1;
```

MySQL 的處理流程如下：

1. **連線層處理：**
   - 驗證帳號密碼 → 通過 → 為此連線建立一個 Thread。

2. **SQL 層處理：**
   - **語法分析：** 確認語法正確。
   - **預處理：** 確認 `employees` 表存在且當前用戶可存取。
   - **優化：** 檢查是否有對 `id` 欄位的索引，若有，選用索引加速查詢。
   - **產生執行計劃：** 根據索引走查，快速定位到 `id=1` 的記錄。

3. **存儲引擎處理：**
   - **InnoDB** 接手，根據主鍵索引讀取磁碟資料頁，找出符合條件的記錄，返回 `name` 欄位資料。

4. **返回結果：**
   - 資料由儲存引擎 → 傳回 SQL 執行器 → 傳給連線層 → 最後回傳給使用者的 MySQL 客戶端。

---

### 🧠 小結

| 階層        | 功能                     | 重點模組             |
|-------------|--------------------------|----------------------|
| 連線層      | 管理用戶連線與身份驗證   | thread pool, auth   |
| SQL 層      | 分析、優化與執行查詢     | Parser, Optimizer   |
| 存儲引擎層  | 與實際資料進行交互       | InnoDB, MyISAM 等    |

![](./images/2402456-20220611162545051-816027509.png "")

這種清楚分層的架構，讓 MySQL 同時具備高彈性與高效能，也讓不同層級可以各自優化和擴充。

---

如果你想進一步了解某層具體的模組或 debug 一段 SQL 查詢的執行流程，我也可以幫你帶入 EXPLAIN 等實務工具來看！需要的話，隨時告訴我～

## 1.2 Connectors
### 🔌 Connectors 層（連接器層）

#### 📌 說明：
Connectors 是 MySQL 與不同程式語言之間進行互動的「橋樑」，它們透過 TCP/IP 與 MySQL Server 建立連線並進行資料交換。

你可以使用各種語言的 Connector 來操作 MySQL，包括：

- **Java** ➜ JDBC（Java Database Connectivity）
- **Python** ➜ mysql-connector-python、PyMySQL
- **PHP** ➜ PDO_MySQL、mysqli
- **C/C++** ➜ libmysqlclient
- **Node.js** ➜ `mysql2` 模組
- **ODBC** ➜ 支援資料來源整合，如 Excel、Power BI 等

無論哪一種，最終都是透過 **MySQL 協議在 TCP 之上通訊**。

---

#### 🧪 範例：

###### Java 程式與 MySQL 的連線流程（JDBC）

```java
// 匯入 JDBC 套件
import java.sql.*;

public class MySQLExample {
    public static void main(String[] args) {
        String url = "jdbc:mysql://localhost:3306/testdb"; // JDBC URL
        String user = "root";
        String password = "123456";

        try (Connection conn = DriverManager.getConnection(url, user, password);
             Statement stmt = conn.createStatement()) {

            ResultSet rs = stmt.executeQuery("SELECT name FROM employees WHERE id = 1");
            while (rs.next()) {
                System.out.println("姓名: " + rs.getString("name"));
            }

        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}
```

在這個例子中：
- JDBC 是 Java 語言的 Connector。
- 透過 JDBC，程式碼與 MySQL Server 建立 TCP 連線。
- 然後 MySQL Server 接收到 SQL 字串後進入邏輯架構的下一層進行處理。

---

### 🧱 MySQL Server 三層邏輯架構（完整補充）

從 Connectors 進入後，MySQL Server 可以邏輯上分為以下三層：

#### 1️⃣ **連接層（Connection Layer）**
- 管理客戶端連接。
- 驗證帳號密碼與權限。
- 建立 Session，對每個用戶維護一條獨立的執行緒。
- 可選擇啟用查詢快取（MySQL 8.0 已移除）。

#### 2️⃣ **服務層（SQL Layer）**
- 負責 SQL 處理邏輯：
  - SQL Parser：語法與語義分析。
  - Preprocessor：資料表與欄位合法性驗證。
  - Optimizer：選擇最佳查詢方式（是否使用索引？如何 Join？）
  - Executor：根據計劃執行 SQL 並組裝結果。

#### 3️⃣ **儲存引擎層（Storage Engine Layer）**
- 負責與磁碟進行實際資料存取。
- 多種儲存引擎（InnoDB、MyISAM、Memory...）
- 每個儲存引擎使用統一 API 與上層交互，但內部資料存取機制可完全不同。

---

#### 🖼️ 圖解理解（文字版本）

```text
+--------------------+
|      Connectors    |   ← 各語言的 SDK、ODBC、JDBC
+--------------------+
|   Connection Pool  |   ← 建立連線、驗證帳號、管理 session
|   Thread Handling  |
+--------------------+
|   SQL Parser       |   ← 語法分析器
|   Preprocessor     |   ← 權限、表/欄位驗證
|   Optimizer        |   ← 查詢優化器
|   Executor         |   ← 查詢執行器
+--------------------+
|   Storage Engine   |   ← 具體儲存與存取資料
+--------------------+
```

---

### 📌 小結與回顧

| 名稱 | 作用 | 範例 |
|------|------|------|
| **Connectors** | 與 MySQL Server 建立 TCP 連線並傳送 SQL 字串 | JDBC、ODBC、mysqlclient、PDO |
| **Connection Layer** | 驗證、建立 session、管理快取 | 驗證帳號密碼、thread pool |
| **SQL Layer** | SQL 分析、優化與執行 | 解析 `SELECT * FROM users` |
| **Storage Engine Layer** | 實際存取資料、索引操作 | InnoDB 根據主鍵索引取值 |

---

如你還想補上 MySQL 實體架構（比如檔案層、頁結構、緩衝池）或更進一步探討某層的 debug 工具（如 `EXPLAIN`, `SHOW PROFILE`），我也可以幫你整理～

## 1.3 第一層：連接層
> 當我們談到 **MySQL 邏輯架構的第 1 層：連接層（Connection Layer）** 時，重點是了解它如何處理「用戶端連線」這一最基礎但關鍵的步驟。以下是補充說明與範例，幫助你清楚理解這層的運作流程與作用。

![](./images/2402456-20220611162542080-1301016175.png "")

---

### 🔐 第 1 層：連接層（Connection Layer）

這一層是整個 MySQL 架構的「第一道門檻」，用來管理來自用戶端的連線與驗證。

---

#### 🔄 處理流程詳解

1. **建立 TCP 連線（三次握手）**
   - 當客戶端（如 JDBC、MySQL CLI 工具）想要與 MySQL 溝通，首先會發起 TCP 連線。
   - 成功建立後，MySQL 就能接收來自該連線的 SQL 請求。

2. **身份認證（Authentication）**
   - 用戶端會發送帳號密碼資訊。
   - MySQL 根據 `mysql.user` 等系統表對帳號進行驗證。
   - ❌ 若失敗，會返回：
     ```
     ERROR 1045 (28000): Access denied for user 'test'@'localhost' (using password: YES)
     ```
   - ✅ 若通過，則會查出該帳號擁有的所有權限資訊並暫存於記憶體，後續 SQL 查詢都會根據這份權限來判斷能否執行。

3. **連線數與資源限制（連線池 + 線程池）**
   - 每個 TCP 連線對應一條執行緒，用於處理該連線的所有 SQL 指令。
   - 為了效能與資源優化：
     - **使用長連線（Keep-alive）**：避免頻繁建立與關閉連線。
     - **使用線程池（Thread Pool）**：避免每次新建線程造成高昂資源開銷。

4. **多客戶端連線**
   - MySQL 可同時處理大量連線。
   - 可配置最大連線數：`max_connections`（例如：151）
   - 可查詢目前連線數：`SHOW STATUS LIKE 'Threads_connected';`

---

### 📦 範例：MySQL 的連線與連線池概念模擬

#### 🧪 使用 MySQL CLI 嘗試連線：

```bash
mysql -u root -p
```

- 此時 MySQL 服務器將根據 TCP 連線建立會話（session），驗證 `root` 帳號。
- 若通過，即分配線程開始處理 SQL。

#### 🧪 觀察當前連線數與上限：

```sql
-- 查看當前連線數
SHOW STATUS LIKE 'Threads_connected';

-- 查看最大允許連線數
SHOW VARIABLES LIKE 'max_connections';
```

---

### 🧰 小補充：連線相關變數

| 系統變數 | 說明 |
|----------|------|
| `max_connections` | 最大允許的連線數 |
| `thread_cache_size` | 線程快取池的大小，可重複利用舊的線程 |
| `wait_timeout` | 客戶端非活躍連線在斷開前等待的秒數（預設8小時） |
| `interactive_timeout` | 對於互動式連線的 timeout 時間 |

---

### 🧠 小結

| 組件名稱     | 功能                                       |
|--------------|--------------------------------------------|
| TCP 連線     | 建立基本通訊通道                            |
| 認證驗證     | 驗證用戶身份、密碼                         |
| 權限綁定     | 綁定該連線使用者的權限集                   |
| 連線池       | 限制連線數、防止系統過載                   |
| 線程池       | 減少頻繁建立與銷毀線程的資源開銷           |

這層的運作就像是「接待大廳 + 保全系統」，先確保來的人有正確身份，然後幫他指派一位專屬客服（線程）處理後續所有事務。

---

若你有興趣，我可以進一步說明連線超時錯誤、如何設定最大連線數上限，以及如何針對高併發場景設計 MySQL 連線策略（如 ProxySQL 或連線池管理）！

## 1.4 第2层：服务层
### 🔌 1. SQL Interface（SQL 接口）

#### 📌 功能：
- 負責接收從連線層傳來的 SQL 指令（文字形式）。
- 支援多種 SQL 子語言：  
  - **DML**（Data Manipulation Language）：如 `SELECT`、`INSERT`、`UPDATE`、`DELETE`
  - **DDL**（Data Definition Language）：如 `CREATE`、`DROP`、`ALTER`
  - **DCL**（Data Control Language）：如 `GRANT`、`REVOKE`
  - **其他**：儲存程序、觸發器、函數、視圖...

#### 🧪 範例：
```sql
-- DML
SELECT name FROM student WHERE gender = '女';

-- DDL
CREATE TABLE product (
  id INT PRIMARY KEY,
  name VARCHAR(100),
  price DECIMAL(10,2)
);

-- 調用儲存程序
CALL calculate_discount(1000);
```
這些語句會先進入 SQL 接口，由它轉發給後續模組進行處理。

---

### 📖 2. Parser（解析器）

#### 📌 功能：
- 對 SQL 語句做 **語法與語義解析**。
- 建構 **語法樹（Syntax Tree）**。
- 根據資料字典（Data Dictionary）驗證表、欄位、函數是否存在。
- 檢查當前使用者是否有執行該指令的權限。
- 執行查詢重寫（如消除不必要的子查詢）。

#### 🧪 範例：
```sql
SELECT name, age FROM student WHERE age > 18;
```

- Parser 將語句解析成語法樹：
  ```
  SELECT → 投影列: name, age
         → 選取條件: age > 18
         → 資料來源: student
  ```
- 檢查 `student` 表是否存在、`name` 和 `age` 欄位是否存在。
- 確認使用者是否有 `SELECT` 權限。

---

### 🧠 3. Optimizer（查詢優化器）

#### 📌 功能：
- 負責產生最佳的 **執行計劃（Execution Plan）**。
- 決定是否使用索引、JOIN 順序、過濾條件的應用順序等。
- 使用 **選取（Selection）- 投影（Projection）- 連接（Join）** 策略優化查詢。

#### 🧪 範例：

```sql
SELECT id, name FROM student WHERE gender = '女';
```

- 優化器會評估：
  - `gender` 欄位是否有索引？若有，就走索引篩選。
  - 投影（只取 id 與 name，不取全部欄位）。
  - 不會做全表掃描（若有索引）。
- 執行計劃產生後，可以用 `EXPLAIN` 查看：
```sql
EXPLAIN SELECT id, name FROM student WHERE gender = '女';
```

---

### 🧠 4. Caches & Buffers（查詢快取機制）

#### 📌 功能：
- 當 SQL 查詢執行過，會把結果暫存於 Query Cache（在 MySQL 5.7.20 以前）。
- 若完全相同的 SQL 再次出現，直接回傳快取結果，不需重複經歷解析 → 優化 → 執行的步驟。

#### 🧠 快取種類包括：
| 快取 | 功能 |
|------|------|
| **Query Cache** | SELECT 結果快取（已移除於 8.0） |
| **Table Cache** | 表描述符快取 |
| **Key Cache** | MyISAM 的索引塊快取 |
| **Innodb Buffer Pool** | InnoDB 資料與索引緩衝池 |
| **Privilege Cache** | 權限資訊快取 |

#### 🧪 小故事例子：
```text
問你：「9+8×16-3×2×17」是多少？你算一次得出「35」。
下次再問同樣的題目，你會直接回答「35」而不是重算，這就是快取的概念。
```

#### 🧪 範例：
如果你在 MySQL 5.7 中執行以下語句多次：
```sql
SELECT COUNT(*) FROM student WHERE gender = '女';
```
第一次會執行整個查詢流程，第二次若快取開啟且資料未改變，就直接回傳查詢結果。

開啟查詢快取（MySQL 5.7）：
```sql
SET GLOBAL query_cache_size = 262144;
SET GLOBAL query_cache_type = 1;
```

---

### ✅ 小結總覽

| 模組名稱 | 功能說明 | 範例 |
|----------|----------|------|
| SQL Interface | 接收 SQL 並分類分派處理 | `SELECT`, `CREATE`, `CALL` 等 |
| Parser | 將 SQL 轉語法樹 + 權限與語法驗證 | 查表、查欄位、驗證權限 |
| Optimizer | 建立最佳執行計劃（索引、Join順序） | 使用 `EXPLAIN` 分析 |
| Caches | 查詢結果與結構快取，提升效能 | `Query Cache`、`Table Cache` |

---

如果你想進一步深入了解 Optimizer 如何決定執行計劃（例如 index merge、range scan、ref join 等），或 Buffer Pool 如何配置大小，我可以為你延伸說明，甚至搭配 `SHOW PROFILE` 做查詢性能分析都沒問題！

## 1.5 第3层：引擎层
> 你提到的是 MySQL 邏輯架構中的 **第3層：引擎層（Storage Engine Layer）**，這一層真正掌控了資料的**實際存取與操作邏輯**，是 MySQL 與其他資料庫系統很大不同的特色之一。以下是補充說明與範例解析，幫助你理解這一層的設計意圖與使用方式。

---

### 🧱 第3層：引擎層（Storage Engine Layer）

---

#### 🔍 核心特性：插件式儲存引擎架構

MySQL 採用**模組化設計**，將查詢邏輯與資料儲存分離，讓使用者可以根據場景選擇適合的儲存引擎來儲存資料。  
這種架構允許：

- 資料處理層（SQL 層）專注於語法、優化、執行計劃等邏輯處理。
- 儲存層（引擎層）專注於底層資料如何存取與儲存（記憶體、磁碟、索引結構、事務...）。
- 支援 **自定義儲存引擎**。

> 📌 MySQL 通過統一的儲存引擎 API（例如 `handler` 接口）與上層通訊。

---

#### ✅ 常見儲存引擎與特性對比

以下是 MySQL 8.0.25 預設支援的主要儲存引擎：

| 儲存引擎 | 支援事務 | 支援外鍵 | 鎖類型 | 特色用途 |
|-----------|-----------|-----------|--------|----------|
| **InnoDB** | ✅ 是 | ✅ 是 | 行級鎖 | 默認引擎，支援 ACID、崩潰恢復 |
| **MyISAM** | ❌ 否 | ❌ 否 | 表級鎖 | 查詢快，適合讀多寫少場景 |
| **Memory** | ❌ 否 | ❌ 否 | 表級鎖 | 資料存在 RAM 中，速度快但重啟會丟失 |
| **CSV** | ❌ 否 | ❌ 否 | 表級鎖 | 以 CSV 格式儲存，可用於資料匯出 |
| **Archive** | ❌ 否 | ❌ 否 | 表級鎖 | 適合長期儲存大量歷史資料 |
| **NDB (Cluster)** | ✅ 是 | ✅ 是 | 分布式架構 | 適合高可用、高擴展性集群場景 |
| **BLACKHOLE** | ❌ 否 | ❌ 否 | - | 所有寫入皆會被丟棄（用於複製架構） |

> 可用 `SHOW ENGINES;` 查看當前支援的所有儲存引擎。

---

#### 🧪 範例 1：指定儲存引擎建立資料表

```sql
CREATE TABLE test_innodb (
  id INT PRIMARY KEY,
  name VARCHAR(100)
) ENGINE = InnoDB;

CREATE TABLE test_myisam (
  id INT PRIMARY KEY,
  name VARCHAR(100)
) ENGINE = MyISAM;
```

- `test_innodb` 使用 InnoDB：支援事務與行級鎖。
- `test_myisam` 使用 MyISAM：不支援事務，但查詢效率快。

---

#### 🧪 範例 2：查看表的儲存引擎

```sql
SHOW TABLE STATUS LIKE 'test_innodb'\G
```

輸出中會看到 `Engine: InnoDB`

---

#### 🧠 插件式架構的好處

| 好處 | 說明 |
|------|------|
| **可插拔** | 不同引擎針對不同場景：如 OLTP 用 InnoDB、報表用 MyISAM |
| **維護性強** | 引擎升級不影響上層 SQL 層架構 |
| **支援開發自定儲存引擎** | MySQL 開源可讓開發者撰寫自訂儲存邏輯 |
| **功能擴充性** | 未來可整合如分散式、NoSQL、內存型引擎等 |

---

### 🧰 進階使用：變更現有表的儲存引擎

```sql
ALTER TABLE test_myisam ENGINE = InnoDB;
```

這會將 `test_myisam` 表轉換成使用 InnoDB 儲存引擎（若欄位定義允許的話）。

---

### ✅ 小結：三層架構中「引擎層」的角色

| 層級 | 功能重點 | 與儲存引擎的關係 |
|------|----------|------------------|
| **連線層** | 建立連線、權限管理 | 無直接關係 |
| **SQL 層** | 處理語法、優化查詢 | 通過統一接口與儲存引擎通訊 |
| **引擎層** | 實際操作磁碟資料 | 根據表指定的引擎進行存取與管理 |

---

如你有興趣，我可以帶你看看 InnoDB 的具體結構（例如：表空間、資料頁、UNDO、Redo log、Buffer Pool），進一步了解資料是怎麼「真正」存起來的！是否需要我幫你補上這一段？

## 1.6 第ˋ層：存储层
### 🗂️ 第四層：**存儲層（Storage Layer）**

#### 📌 作用：
- 負責將資料「**寫入磁碟**」與「**從磁碟讀出**」。
- 包括表結構、欄位資料、索引、系統元資料（metadata）等所有實體資料。
- 與「儲存引擎層」合作，但再下一層處理的是實體文件與作業系統的檔案系統。

---

#### 🧱 資料如何存儲？

MySQL 中的資料，最終會被寫入作業系統上的檔案，這些檔案通常有以下幾種型態（以 InnoDB 為例）：

| 檔案類型 | 說明 | 預設副檔名 |
|----------|------|------------|
| 表定義檔 | 儲存表的 schema 結構 | `.frm`（MySQL 5.x）→ 8.0後整合到 `data dictionary` |
| 表資料檔 | 儲存表的實際資料（資料列） | `.ibd`（InnoDB 獨立表空間） |
| 共享表空間 | 儲存事務資料（UNDO、REDO）、系統頁等 | `ibdata1`, `ib_logfile0` |
| 日誌檔案 | 用於崩潰恢復（重做日誌 REDO）、事務撤銷（UNDO） | `ib_logfile*`, binlog |
| 索引檔案 | 儲存索引樹結構（如 B+ Tree） | 也在 `.ibd` 中（InnoDB） |

---

### 🧰 範例：建立表後的磁碟實體變化

假設我們在名為 `mydb` 的資料庫中建立一張表：

```sql
CREATE TABLE users (
  id INT PRIMARY KEY,
  name VARCHAR(100),
  age INT
) ENGINE = InnoDB;
```

如果你設定了獨立表空間（通常預設為 `innodb_file_per_table=ON`），MySQL 會在資料目錄中建立一個對應的檔案：

```text
/data/mysql/mydb/users.ibd  ← 儲存這張表的所有資料與索引
```

此外，InnoDB 還會持續使用以下檔案進行寫入與恢復：

- `/data/mysql/ibdata1` （共享表空間）
- `/data/mysql/ib_logfile0`、`ib_logfile1`（REDO 日誌）

---

#### 🧪 查詢資料目錄與表檔案

你可以這樣確認：

```sql
-- 確認資料目錄位置
SHOW VARIABLES LIKE 'datadir';
```

在 Linux 上，可以透過命令查看實體檔案：

```bash
ls -lh /var/lib/mysql/mydb/
# 可以看到 users.ibd 等檔案
```

---

#### 📦 儲存後端技術（補充）

MySQL 的資料最終會交給作業系統的 **檔案系統（File System）** 儲存，也可能搭配不同的底層硬體：

| 類型 | 說明 |
|------|------|
| **本地磁碟** | 常見於單機部署 |
| **DAS（Direct Attached Storage）** | 本地直連的外接磁碟設備 |
| **NAS（Network Attached Storage）** | 檔案級網路儲存，透過網路傳輸 |
| **SAN（Storage Area Network）** | 區塊級儲存裝置，效能高，多用於大型資料庫集群 |

InnoDB 曾支援「裸裝置（raw device）」直寫，但現代的檔案系統（如 XFS、EXT4）已非常高效，一般不再使用。

---

### 🔄 與上層的關係

MySQL 各層的互動流程（簡化）：

```
Client → SQL 層（解析器/優化器）→ 儲存引擎層（InnoDB）→ 檔案系統 → 磁碟
```

資料的「寫入與讀取」都是透過這樣一路下行與回傳的過程完成的。

---

### ✅ 小結

| 層級 | 負責處理 | 儲存位置 | 關鍵檔案舉例 |
|------|----------|----------|--------------|
| 引擎層 | 管理資料頁、索引、事務邏輯 | 還是交給 OS 處理 | `.ibd`, `ibdata1`, `ib_logfile0` |
| 存儲層 | 最終把資料寫入磁碟（OS層） | 檔案系統、磁碟 | `/var/lib/mysql/mydb/*.ibd` |

---

如果你想更進一步理解 InnoDB 資料頁的結構（如 Page Header、Page Directory、行格式），或事務崩潰恢復流程（通過 REDO/UNDO），我也可以為你進行延伸說明。是否需要？

## 1.7 小結
MySQL架构图本节开篇所示。下面为了熟悉SQL执行流程方便，我们可以简化如下：

![](./images/2402456-20220611162544254-1677918799.png "")

- 简化为三层结构：
  - 连接层：客户端和服务器端建立连接，客户端发送 SQL 至服务器端；
  - SQL 层（服务层）：对 SQL 语句进行查询处理；与数据库文件的存储方式无关；
  - 存储引擎层：与数据库文件打交道，负责数据的存储和读取。

# 2. 