# 1. 概述 
> 为了管理方便，人们把连接管理、查询缓存、语法解析、查询优化这些并不涉及真实数据存储的功能划分为MySQL server 的功能，把真实存取数据的功能划分为存储引擎的功能。所以在MySQL server完成了查询优化后，只需按照生成的执行计划调用底层存储引擎提供的API，获取到数据后返回给客户端就好了。

> MySQL中提到了存储引擎的概念。简而言之，存储引擎就是指表的类型。其实存储引擎以前叫做表处理器，后来改名为存储引擎，它的功能就是接收上层传下来的指令，然后对表中的数据进行提取或写入操作。

## 🔧 一、MySQL 架構的分層概念

MySQL 其實是**分層架構設計**的，主要分成兩層：

| 層級 | 功能 |
|------|------|
| **MySQL Server 層** | 負責處理與資料儲存**無關**的事，如：連線管理、查詢語法解析、查詢優化、快取、權限控制等 |
| **儲存引擎層（Storage Engine）** | 負責實際**存取數據**的動作，像是讀取/寫入磁碟、索引處理等 |

🔸 **簡單理解**：  
你可以把 MySQL Server 想像成一位主管，他接收指令、擬定執行計畫後，會把工作交給實際處理數據的工人──「存儲引擎」來執行。

---

## 🗃️ 二、什麼是「存儲引擎」？

### ✔ 定義：
「存儲引擎」就像是資料表的「內部處理方式」，決定了該表的資料**如何儲存、索引如何建立、是否支援交易（transaction）、鎖機制是什麼、是否支援全文搜尋等等功能**。

### ✔ 常見引擎：

| 引擎名稱 | 特點 |
|----------|------|
| **InnoDB** | 支援交易（ACID）、行鎖、外鍵，現代MySQL預設引擎 |
| **MyISAM** | 不支援交易，查詢速度快，適合讀多寫少的應用 |
| **Memory** | 資料儲存在記憶體中，速度超快，但重啟資料就會消失 |
| **CSV** | 將表資料儲存為CSV格式，方便匯出與交換資料 |

---

## 🧪 三、範例說明

### 🎯 1. 建立不同儲存引擎的表

```sql
-- 建立 InnoDB 表（支援交易）
CREATE TABLE users_innodb (
  id INT PRIMARY KEY,
  name VARCHAR(50)
) ENGINE = InnoDB;

-- 建立 MyISAM 表（不支援交易）
CREATE TABLE users_myisam (
  id INT PRIMARY KEY,
  name VARCHAR(50)
) ENGINE = MyISAM;
```

### 🧪 2. 測試交易支持

```sql
-- 開始交易（僅 InnoDB 有效）
START TRANSACTION;
INSERT INTO users_innodb VALUES (1, '小明');
ROLLBACK;  -- 回滾後，資料不會寫入

SELECT * FROM users_innodb;  -- 結果為空

-- 如果你這麼做在 MyISAM 表：
START TRANSACTION;
INSERT INTO users_myisam VALUES (1, '小明');
ROLLBACK;

SELECT * FROM users_myisam;  -- 還是會看到「小明」 => 因為 MyISAM 不支援交易
```

---

## 🧠 小結

| 分類 | 說明 |
|------|------|
| MySQL Server | 負責處理邏輯操作與查詢計畫（像是「要查什麼資料」） |
| 儲存引擎 | 實際執行對磁碟中表的操作（像是「去哪裡拿資料」） |
| 儲存引擎 = 表類型 | 每個表可以指定不同儲存引擎，選擇會影響效能、功能、可靠性等 |

---

# 2.查看存储引擎
## 🧾 一、指令說明：查看所有可用的存儲引擎

```sql
SHOW ENGINES;
-- 或者使用更漂亮的格式：
SHOW ENGINES\G
```

這個指令會列出當前 MySQL 版本支援的所有存儲引擎。

---

## 📊 二、查詢結果的欄位解釋

| 欄位 | 說明 |
|------|------|
| **Engine** | 存儲引擎名稱（例如 InnoDB、MyISAM） |
| **Support** | `DEFAULT` 表示預設引擎，`YES` 表示支援，`NO` 表示不支援 |
| **Comment** | 關於該引擎用途的簡單描述 |
| **Transactions** | 是否支援「交易處理（Transaction）」功能 |
| **XA** | 是否支援 **XA 分布式交易協議**（跨多資料來源的交易） |
| **Savepoints** | 是否支援 **SAVEPOINT 部分回滾** |

---

## 📚 三、常見存儲引擎簡介（MySQL 8.x）

| 引擎名稱 | Support | Comment | Transactions | XA | Savepoints |
|----------|---------|---------|--------------|----|------------|
| **InnoDB** | DEFAULT | 支援交易、行鎖、外鍵 | YES | YES | YES |
| **MyISAM** | YES | 不支援交易，速度快 | NO | NO | NO |
| **MEMORY** | YES | 儲存在記憶體中，重啟會消失 | NO | NO | NO |
| **CSV** | YES | 以 CSV 格式儲存，適合匯出匯入 | NO | NO | NO |
| **ARCHIVE** | YES | 用於壓縮存儲大量歷史資料，只能插入和查詢 | NO | NO | NO |
| **BLACKHOLE** | YES | 接收資料但不儲存（測試用） | NO | NO | NO |
| **PERFORMANCE_SCHEMA** | YES | 儲存效能監控資料 | NO | NO | NO |
| **FEDERATED** | NO（需手動啟用） | 可連結其他 MySQL 資料庫伺服器 | NO | NO | NO |
| **MRG_MYISAM** | YES | 將多個 MyISAM 表合併成一張虛擬表 | NO | NO | NO |

---

## 🧪 四、範例操作

### 1️⃣ 查看支援的儲存引擎：

```sql
SHOW ENGINES\G
```

📌 **範例結果部分內容**（格式化後）：

![](./images/2402456-20220611162625370-165221704.png "")

### 2️⃣ 建立使用特定儲存引擎的資料表

```sql
-- 建立使用 InnoDB 的表（預設）
CREATE TABLE products_innodb (
  id INT PRIMARY KEY,
  name VARCHAR(50)
) ENGINE = InnoDB;

-- 建立使用 MEMORY 引擎的表（資料存在 RAM 中）
CREATE TABLE cache_data (
  id INT PRIMARY KEY,
  value VARCHAR(100)
) ENGINE = MEMORY;

-- 建立使用 BLACKHOLE 引擎的表（寫入資料後不儲存）
CREATE TABLE test_sink (
  id INT PRIMARY KEY,
  message VARCHAR(255)
) ENGINE = BLACKHOLE;
```

---

## 🔍 五、應用場合建議

| 引擎 | 適合情境 |
|------|-----------|
| **InnoDB** | 幾乎所有正式專案，支援交易與併發控制 |
| **MyISAM** | 查詢遠多於寫入的舊專案或只讀報表 |
| **MEMORY** | 暫存資料、快取表 |
| **BLACKHOLE** | 日誌測試、不想儲存資料但需觸發 log 或 replication |
| **ARCHIVE** | 歷史資料歸檔、壓縮存儲 |
| **CSV** | 和外部工具（如 Excel）交換資料 |
| **FEDERATED** | 跨伺服器查詢遠端 MySQL（需手動安裝） |

---

# 3. 设置系统默认的存储引擎
## 🔍 一、什麼是「預設存儲引擎」？

MySQL 支援多種儲存引擎，例如 `InnoDB`、`MyISAM`、`MEMORY` 等。  
當你**在建表時沒有指定引擎時**，MySQL 就會使用「預設儲存引擎」。

例如這段建表語句：

```sql
CREATE TABLE users (
  id INT PRIMARY KEY,
  name VARCHAR(50)
);
```

若你**沒有指定 `ENGINE = ???`**，那這張表會使用預設的引擎，通常是 `InnoDB`。

---

## 🔎 二、如何查詢目前的預設存儲引擎？

### ✅ 方法一：用 `SHOW VARIABLES`
```sql
SHOW VARIABLES LIKE '%storage_engine%';
```

你會看到類似結果：
```
+------------------------+--------+
| Variable_name          | Value  |
+------------------------+--------+
| default_storage_engine | InnoDB |
+------------------------+--------+
```

### ✅ 方法二：用變數查詢
```sql
SELECT @@default_storage_engine;
```

結果會是：
```
InnoDB
```

---

## ✏️ 三、如何修改預設存儲引擎？

### ✅ 方法一：臨時修改（只對當前連線有效）
```sql
SET DEFAULT_STORAGE_ENGINE = MyISAM;
```

> ⚠️ **此設定只在當前 MySQL session 有效**，斷線就會失效。

你可以這樣測試：

```sql
SET DEFAULT_STORAGE_ENGINE = MyISAM;

CREATE TABLE test1 (
  id INT PRIMARY KEY
);  -- 這張表會使用 MyISAM 引擎

SHOW TABLE STATUS LIKE 'test1'\G;
-- 查看 Engine 欄位確認是否為 MyISAM
```

---

### ✅ 方法二：永久修改（修改設定檔）

要讓改動永久生效，需修改設定檔 `my.cnf`（Linux）或 `my.ini`（Windows）：

```ini
[mysqld]
default-storage-engine = MyISAM
```

然後重啟 MySQL 服務：

```bash
sudo systemctl restart mysqld.service
```

或：

```bash
sudo service mysql restart
```

---

## 🧪 四、範例：驗證預設引擎是否生效

### 1️⃣ 修改為 MyISAM（臨時或永久）

```sql
SET DEFAULT_STORAGE_ENGINE = MyISAM;
```

### 2️⃣ 建立測試資料表（不指定 ENGINE）

```sql
CREATE TABLE test_engine (
  id INT PRIMARY KEY,
  msg VARCHAR(100)
);
```

### 3️⃣ 查看實際使用的引擎

```sql
SHOW TABLE STATUS LIKE 'test_engine'\G
```

查詢結果中會看到：
```
Engine: MyISAM
```

---

## 📌 小結

| 操作 | 說明 |
|------|------|
| 查詢預設引擎 | `SHOW VARIABLES LIKE '%storage_engine%'` 或 `SELECT @@default_storage_engine;` |
| 臨時修改預設引擎 | `SET DEFAULT_STORAGE_ENGINE = xxx;`（只對當前連線有效） |
| 永久修改預設引擎 | 編輯 `my.cnf` 的 `[mysqld]` 區塊，加上 `default-storage-engine = xxx` 並重啟服務 |
| 建表未指定引擎時 | 會使用當前預設的儲存引擎 |

---

如果你想，我也可以幫你寫一段**完整腳本**，一步步測試並比較不同引擎的行為（例如：支援交易、查詢速度差異等）。是否需要呢？

# 4. 设置表的存储引擎
## 🔧 一、什麼是「儲存引擎」？

- 儲存引擎（Storage Engine）是資料表背後「負責實際操作磁碟資料」的元件。
- 不同儲存引擎 = 不同的資料存儲與查詢邏輯。
- **一個 MySQL 資料庫可以同時使用多種儲存引擎**，每張表各自選擇最合適的。

---

## ✨ 二、建立表時指定儲存引擎

### 📌 語法格式：
```sql
CREATE TABLE 表名 (
    欄位1 資料型別,
    欄位2 資料型別
) ENGINE = 儲存引擎名稱;
```

### 🧪 範例：
```sql
-- 建立一張使用 MyISAM 的表
CREATE TABLE users_myisam (
  id INT PRIMARY KEY,
  name VARCHAR(50)
) ENGINE = MyISAM;

-- 建立一張使用 InnoDB（預設引擎）的表
CREATE TABLE users_innodb (
  id INT PRIMARY KEY,
  name VARCHAR(50)
) ENGINE = InnoDB;
```

---

## 🔄 三、修改表的儲存引擎

有時表已經建好，但你後來發現需要用不同的引擎（例如從不支援交易的 MyISAM 改為 InnoDB），可以用以下語法：

### 📌 語法格式：
```sql
ALTER TABLE 表名 ENGINE = 新的儲存引擎;
```

### 🧪 範例操作：
```sql
-- 將 users_myisam 表轉換為 InnoDB 引擎
ALTER TABLE users_myisam ENGINE = InnoDB;
```

✅ 修改成功後，可以用這個語句來驗證引擎是否正確更新：

```sql
SHOW CREATE TABLE users_myisam\G
```

輸出內容會顯示這行：

```
ENGINE=InnoDB DEFAULT CHARSET=utf8
```

---

## 🔍 四、常見應用場景對比

| 儲存引擎 | 是否支援交易 | 支援外鍵 | 鎖機制 | 適合用途 |
|----------|---------------|-----------|---------|-----------|
| InnoDB   | ✅ 是          | ✅ 是      | 行鎖     | 大多數應用系統、寫入多的系統 |
| MyISAM   | ❌ 否          | ❌ 否      | 表鎖     | 查詢為主、報表分析 |
| MEMORY   | ❌ 否          | ❌ 否      | 表鎖     | 暫存資料、速度要求高但可容忍資料丟失 |
| ARCHIVE  | ❌ 否          | ❌ 否      | 行鎖     | 歷史資料壓縮存放，只讀不更新 |
| BLACKHOLE| ❌ 否          | ❌ 否      | 無       | 測試 replication、不保存資料 |

---

## ✅ 小結整理

| 操作目標 | 語法或步驟 |
|----------|-------------|
| 建表時設定引擎 | `CREATE TABLE ... ENGINE = xxx;` |
| 查詢某表使用哪個引擎 | `SHOW CREATE TABLE 表名\G` |
| 修改表的儲存引擎 | `ALTER TABLE 表名 ENGINE = xxx;` |

---

# 5. 引擎介绍
## 5.1 InnoDB 引擎：具备外键支持功能的事务存储引擎
### 🧠 一、InnoDB 儲存引擎重點整理

| 特性 | 說明 |
|------|------|
| ✅ 支援交易 | 提供 **ACID** 保證，可 `COMMIT`、`ROLLBACK`、`SAVEPOINT` |
| ✅ 支援外鍵 | 可定義外鍵，建立表與表之間的「參照完整性」 |
| ✅ 行級鎖定 | 避免整張表鎖住，提高併發效能 |
| ✅ 支援資料與索引快取 | 同時快取資料與索引，效能佳但佔用記憶體大 |
| ✅ 適合 CRUD 都頻繁的應用 | 包含查詢、插入、更新、刪除 |
| ✅ MySQL 5.5 起預設引擎 | MySQL 8.0 完整整合為 `*.ibd` 檔案 |

---

### 🆚 二、與 MyISAM 差異比較

| 特性 | InnoDB | MyISAM |
|------|--------|--------|
| 交易支援 | ✅ 有 | ❌ 無 |
| 鎖機制 | 行鎖 | 表鎖 |
| 外鍵支援 | ✅ 有 | ❌ 無 |
| 快取策略 | 同時快取資料與索引 | 只快取索引 |
| 效能特性 | 寫入較慢但穩定性高 | 查詢快但不安全 |
| 檔案格式 | `.ibd` 檔案（資料+索引） | `.MYD` 資料 + `.MYI` 索引 |

---

### 🧪 三、InnoDB 儲存引擎範例操作

#### ✅ 1. 建立兩張具有外鍵關聯的 InnoDB 表

```sql
-- 主表：部門表
CREATE TABLE departments (
  dept_id INT PRIMARY KEY,
  dept_name VARCHAR(50)
) ENGINE=InnoDB;

-- 子表：員工表（引用部門ID）
CREATE TABLE employees (
  emp_id INT PRIMARY KEY,
  emp_name VARCHAR(50),
  dept_id INT,
  FOREIGN KEY (dept_id) REFERENCES departments(dept_id)
) ENGINE=InnoDB;
```

✅ 外鍵限制會保證：
- 不能插入一個不存在部門的員工。
- 當部門被刪除時，如果有員工對應該部門，會阻止刪除或自動連動（看你設定的 ON DELETE 行為）。

---

#### ✅ 2. 測試交易（Transaction）能力

```sql
-- 開始交易
START TRANSACTION;

-- 插入資料
INSERT INTO departments VALUES (10, 'IT');
INSERT INTO employees VALUES (1, '小明', 10);

-- 發現錯誤，回滾所有操作
ROLLBACK;

-- 查詢表，會發現資料沒寫入
SELECT * FROM departments;
SELECT * FROM employees;
```

---

#### ✅ 3. 檢查表使用的儲存引擎

```sql
SHOW TABLE STATUS LIKE 'employees'
```

結果中會看到：
```
Engine: InnoDB
```

---

### 📁 四、InnoDB 的檔案結構（MySQL 8.0）

- **以前版本（5.x）**：
  - `.frm`：儲存表結構（已棄用）
  - `.ibd`：資料 + 索引
- **MySQL 8.0 起：**
  - 所有內容整合到 `.ibd` 檔案中（使用獨立表空間 innodb_file_per_table）

你可以在資料目錄中看到：
```
/var/lib/mysql/你的資料庫/
  └── employees.ibd
```

---

### 📌 小結

| InnoDB 優勢 | 適用場景 |
|-------------|-----------|
| ✅ 交易支援、行鎖、外鍵 | 線上購物系統、銀行系統、ERP、CRM |
| ✅ 避免資料不一致風險 | 高併發、資料一致性要求高 |
| ✅ 可持久化快取（索引+資料） | 記憶體夠大效能好 |

---

是否需要我設計一個實作任務：例如「用 InnoDB 實作一個帶外鍵、交易回滾的訂單系統」幫你練習？只要你說一聲，我可以直接幫你出題設計 😊

## 5.2 MyISAM 引擎：主要的非事务处理存储引擎 
### 🔍 一、MyISAM 儲存引擎特色

| 特性 | 說明 |
|------|------|
| ❌ 不支援交易 | 沒有 COMMIT / ROLLBACK |
| ❌ 不支援行鎖 | 只有 **表級鎖**，多使用者寫入容易阻塞 |
| ❌ 不支援外鍵 | 表與表之間無參照完整性限制 |
| ✅ 支援全文索引（FULLTEXT） | 適合文章搜尋、部落格等應用 |
| ✅ 查詢速度快 | 特別是 `COUNT(*)` 查詢非常快（維護有資料行數統計） |
| ❌ 當機後無法安全恢復 | 資料容易損壞，不建議用於重要交易系統 |
| ✅ 空間函數（GIS）支援 | 適合簡單地理位置查詢 |
| 📂 檔案格式 | `.frm` 結構、`.MYD` 資料、`.MYI` 索引（可備份拷貝） |

---

### 📁 二、MyISAM 的檔案結構

如果你建立一張 `user` 表，MySQL 會生成以下 3 個檔案（前提是使用 MyISAM 引擎）：

| 檔名        | 說明           |
|-------------|----------------|
| `user.frm`  | 表結構         |
| `user.MYD`  | 表數據         |
| `user.MYI`  | 表索引         |

這種「**分檔存儲**」的方式可以直接備份資料檔，不需要導出 SQL。

---

### 🧪 三、MyISAM 範例操作

#### ✅ 1. 建立一張 MyISAM 表

```sql
CREATE TABLE blog_posts (
  id INT PRIMARY KEY,
  title VARCHAR(100),
  content TEXT,
  FULLTEXT(title, content)
) ENGINE = MyISAM;
```

這張表的特點：
- 使用 MyISAM 引擎
- 建立了全文索引 `FULLTEXT(title, content)`，可進行關鍵字搜尋

---

#### ✅ 2. 測試 FULLTEXT 全文搜尋功能（MyISAM 專屬）

```sql
-- 插入資料
INSERT INTO blog_posts VALUES (1, 'MySQL 儲存引擎', '介紹 InnoDB 和 MyISAM 的區別');
INSERT INTO blog_posts VALUES (2, 'Vue 教學', '從前端到後端開發的整合方式');

-- 使用全文搜尋查詢關鍵字 "MyISAM"
SELECT * FROM blog_posts
WHERE MATCH(title, content) AGAINST('MyISAM');
```

只有 MyISAM（或 InnoDB 支援 FULLTEXT 的版本）支援這種 `MATCH ... AGAINST` 語法。

---

#### ✅ 3. 測試 COUNT(*) 效率（維護行數）

```sql
SELECT COUNT(*) FROM blog_posts;
```

MyISAM 引擎中這個語句會**直接讀出已記錄的行數統計**，速度非常快，特別適合報表與統計。

---

#### ✅ 4. 模擬當機場景（不建議於正式環境）

由於 MyISAM 不支援交易，以下操作無法回滾：

```sql
-- 插入資料
INSERT INTO blog_posts VALUES (3, '當機測試', '這段資料若系統掛掉就會損壞');

-- 忘了 commit？=> 無效
ROLLBACK;

-- 仍然會看到資料存在
SELECT * FROM blog_posts WHERE id = 3;
```

📌 這就是 MyISAM 的風險：**操作無回滾，一旦掛機或異常重啟，資料可能會遺失或破壞**。

---

### 📌 四、MyISAM 適合的應用場景

| 適用場景 | 說明 |
|----------|------|
| 📖 文章搜尋系統 | 利用 FULLTEXT 做全文檢索 |
| 📊 只讀報表統計 | 僅查詢、不寫入的報表系統 |
| 📂 備份檔案系統 | 可直接拷貝 `.MYD` / `.MYI` 做備份還原 |
| ❌ 不建議用於銀行/商店等交易系統 | 因為沒有交易安全與回滾機制 |

---

### ✅ 小結

| 功能 | InnoDB | MyISAM |
|------|--------|--------|
| 交易支援 | ✅ | ❌ |
| 表鎖 vs 行鎖 | 行鎖 | 表鎖 |
| FULLTEXT | ✅（5.6 起）| ✅ |
| 當機後恢復 | 安全恢復 | ❌ |
| 查詢速度 | 快（依記憶體）| 非常快（內建統計） |
| 記憶體需求 | 高 | 低 |
| 備份彈性 | 較差（需備份工具）| 可直接拷貝檔案 |

---

## 5.3 Archive 引擎：用于数据存档 
### 🧠 一、什麼是 ARCHIVE 儲存引擎？

| 特性 | 說明 |
|------|------|
| ✅ 只支援 `INSERT` 和 `SELECT` | **不能做 `UPDATE`、`DELETE`** |
| ✅ 支援壓縮儲存 | 使用 `zlib` 做即時壓縮，儲存空間超省（最多可省 83%） |
| ✅ 支援行級鎖 | 在併發插入上比 MyISAM 更安全 |
| ✅ 支援 `AUTO_INCREMENT` 欄位 | 可設主鍵或非主鍵自動編號欄位 |
| ✅ 支援簡單索引（5.5 起） | 只能針對 `AUTO_INCREMENT` 欄位建立索引 |
| ❌ 不支援修改與刪除資料 | 一但插入就無法改動，資料變成「唯讀」 |
| ❌ 查詢效率低、功能有限 | 適合只讀應用，如日誌、歸檔資料 |
| 📂 檔案格式 | `.frm`（表結構）+ `.ARZ`（壓縮後資料） |

---

### 📦 二、適用場景

| 場景 | 原因 |
|------|------|
| 🧾 日誌系統 | 資料只寫入，不修改 |
| 📈 歷史交易記錄 | 資料存檔查詢，空間壓縮需求高 |
| 📊 數據倉儲（只讀） | 資料不會更新，需保留大量紀錄 |
| ❌ 即時查詢、分析系統 | 不適用，因為查詢效能較差，功能受限 |

---

### 🧪 三、實戰範例

#### ✅ 1. 建立 ARCHIVE 表

```sql
CREATE TABLE user_logs (
  id INT AUTO_INCREMENT PRIMARY KEY,
  log_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  message TEXT
) ENGINE = ARCHIVE;
```

#### ✅ 2. 插入資料（支援高速寫入）

```sql
INSERT INTO user_logs (message) VALUES 
('使用者登入成功'),
('使用者修改密碼'),
('使用者登出');
```

✅ 可以像一般表一樣插入資料，只是資料會被壓縮儲存。

---

#### ❌ 3. 嘗試修改或刪除（會報錯）

```sql
-- 嘗試更新
UPDATE user_logs SET message = '錯誤' WHERE id = 1;
-- ❌ 錯誤：The storage engine for the table doesn't support update

-- 嘗試刪除
DELETE FROM user_logs WHERE id = 1;
-- ❌ 錯誤：The storage engine for the table doesn't support delete
```

---

#### ✅ 4. 查詢資料（支援基本 SELECT）

```sql
SELECT * FROM user_logs;
```

🔍 注意：查詢速度相較 InnoDB 或 MyISAM 慢，但適用於不常查詢、偶爾統計的場景。

---

### 📁 四、檔案儲存結構

在資料庫目錄中（如 `/var/lib/mysql/資料庫名/`），會看到類似這些檔案：

| 檔案 | 說明 |
|------|------|
| `user_logs.frm` | 儲存表結構（8.0前） |
| `user_logs.ARZ` | 儲存壓縮後的表資料（主體） |

---

### 🆚 五、與其他引擎比較

| 功能項目 | InnoDB | MyISAM | ARCHIVE |
|----------|--------|--------|---------|
| 支援交易 | ✅ | ❌ | ❌ |
| 支援修改與刪除 | ✅ | ✅ | ❌ |
| 儲存空間效率 | 中 | 普通 | ✅ 最省 |
| 查詢效能 | 高 | 高 | ❌ 低 |
| 插入效能 | 中 | 高 | ✅ 非常高 |
| 適用場景 | 一般應用、交易系統 | 報表查詢、全文搜尋 | 歷史日誌、冷資料歸檔 |

---

### ✅ 小結重點

| 核心特性 | 說明 |
|----------|------|
| 📥 只能插入與查詢 | 不可 UPDATE / DELETE |
| 🗜️ 壓縮儲存 | 省空間，適合大量歷史資料 |
| ⚡ 插入效能高 | 適合高頻寫入、不需即時查詢 |
| ❗ 查詢功能弱 | 避免頻繁查詢、複雜分析 |

---

如果你有一個 **網站操作紀錄系統** 或 **交易備份資料庫**，我可以幫你規劃怎麼用 ARCHIVE + InnoDB 組合設計資料表，主資料用 InnoDB，歷史存進 ARCHIVE。要試試看嗎？🙂

## 5.4 Blackhole 引擎：丢弃写操作，读操作会返回空内容 
## 5.5 CSV 引擎：存储数据时，以逗号分隔各个数据项 
## 5.6 Memory 引擎：置于内存的表
## 5.7 Federated 引擎：访问远程表
## 5.8 Merge引擎：管理多个MyISAM表构成的表集合
## 5.9 NDB引擎：MySQL集群专用存储引擎
## 5.10 引擎对比

# 6. MyISAM和InnoDB

# 7. 阿里巴巴、淘宝用哪个

# 8. 课外补充：