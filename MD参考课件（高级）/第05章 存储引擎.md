# 1. 概述 
> 为了管理方便，人们把连接管理、查询缓存、语法解析、查询优化这些并不涉及真实数据存储的功能划分为MySQL server 的功能，把真实存取数据的功能划分为存储引擎的功能。所以在MySQL server完成了查询优化后，只需按照生成的执行计划调用底层存储引擎提供的API，获取到数据后返回给客户端就好了。

> MySQL中提到了存储引擎的概念。简而言之，存储引擎就是指表的类型。其实存储引擎以前叫做表处理器，后来改名为存储引擎，它的功能就是接收上层传下来的指令，然后对表中的数据进行提取或写入操作。

## 🔧 一、MySQL 架構的分層概念

MySQL 其實是**分層架構設計**的，主要分成兩層：

| 層級 | 功能 |
|------|------|
| **MySQL Server 層** | 負責處理與資料儲存**無關**的事，如：連線管理、查詢語法解析、查詢優化、快取、權限控制等 |
| **儲存引擎層（Storage Engine）** | 負責實際**存取數據**的動作，像是讀取/寫入磁碟、索引處理等 |

🔸 **簡單理解**：  
你可以把 MySQL Server 想像成一位主管，他接收指令、擬定執行計畫後，會把工作交給實際處理數據的工人──「存儲引擎」來執行。

---

## 🗃️ 二、什麼是「存儲引擎」？

### ✔ 定義：
「存儲引擎」就像是資料表的「內部處理方式」，決定了該表的資料**如何儲存、索引如何建立、是否支援交易（transaction）、鎖機制是什麼、是否支援全文搜尋等等功能**。

### ✔ 常見引擎：

| 引擎名稱 | 特點 |
|----------|------|
| **InnoDB** | 支援交易（ACID）、行鎖、外鍵，現代MySQL預設引擎 |
| **MyISAM** | 不支援交易，查詢速度快，適合讀多寫少的應用 |
| **Memory** | 資料儲存在記憶體中，速度超快，但重啟資料就會消失 |
| **CSV** | 將表資料儲存為CSV格式，方便匯出與交換資料 |

---

## 🧪 三、範例說明

### 🎯 1. 建立不同儲存引擎的表

```sql
-- 建立 InnoDB 表（支援交易）
CREATE TABLE users_innodb (
  id INT PRIMARY KEY,
  name VARCHAR(50)
) ENGINE = InnoDB;

-- 建立 MyISAM 表（不支援交易）
CREATE TABLE users_myisam (
  id INT PRIMARY KEY,
  name VARCHAR(50)
) ENGINE = MyISAM;
```

### 🧪 2. 測試交易支持

```sql
-- 開始交易（僅 InnoDB 有效）
START TRANSACTION;
INSERT INTO users_innodb VALUES (1, '小明');
ROLLBACK;  -- 回滾後，資料不會寫入

SELECT * FROM users_innodb;  -- 結果為空

-- 如果你這麼做在 MyISAM 表：
START TRANSACTION;
INSERT INTO users_myisam VALUES (1, '小明');
ROLLBACK;

SELECT * FROM users_myisam;  -- 還是會看到「小明」 => 因為 MyISAM 不支援交易
```

---

## 🧠 小結

| 分類 | 說明 |
|------|------|
| MySQL Server | 負責處理邏輯操作與查詢計畫（像是「要查什麼資料」） |
| 儲存引擎 | 實際執行對磁碟中表的操作（像是「去哪裡拿資料」） |
| 儲存引擎 = 表類型 | 每個表可以指定不同儲存引擎，選擇會影響效能、功能、可靠性等 |

---

# 2.查看存储引擎
## 🧾 一、指令說明：查看所有可用的存儲引擎

```sql
SHOW ENGINES;
-- 或者使用更漂亮的格式：
SHOW ENGINES\G
```

這個指令會列出當前 MySQL 版本支援的所有存儲引擎。

---

## 📊 二、查詢結果的欄位解釋

| 欄位 | 說明 |
|------|------|
| **Engine** | 存儲引擎名稱（例如 InnoDB、MyISAM） |
| **Support** | `DEFAULT` 表示預設引擎，`YES` 表示支援，`NO` 表示不支援 |
| **Comment** | 關於該引擎用途的簡單描述 |
| **Transactions** | 是否支援「交易處理（Transaction）」功能 |
| **XA** | 是否支援 **XA 分布式交易協議**（跨多資料來源的交易） |
| **Savepoints** | 是否支援 **SAVEPOINT 部分回滾** |

---

## 📚 三、常見存儲引擎簡介（MySQL 8.x）

| 引擎名稱 | Support | Comment | Transactions | XA | Savepoints |
|----------|---------|---------|--------------|----|------------|
| **InnoDB** | DEFAULT | 支援交易、行鎖、外鍵 | YES | YES | YES |
| **MyISAM** | YES | 不支援交易，速度快 | NO | NO | NO |
| **MEMORY** | YES | 儲存在記憶體中，重啟會消失 | NO | NO | NO |
| **CSV** | YES | 以 CSV 格式儲存，適合匯出匯入 | NO | NO | NO |
| **ARCHIVE** | YES | 用於壓縮存儲大量歷史資料，只能插入和查詢 | NO | NO | NO |
| **BLACKHOLE** | YES | 接收資料但不儲存（測試用） | NO | NO | NO |
| **PERFORMANCE_SCHEMA** | YES | 儲存效能監控資料 | NO | NO | NO |
| **FEDERATED** | NO（需手動啟用） | 可連結其他 MySQL 資料庫伺服器 | NO | NO | NO |
| **MRG_MYISAM** | YES | 將多個 MyISAM 表合併成一張虛擬表 | NO | NO | NO |

---

## 🧪 四、範例操作

### 1️⃣ 查看支援的儲存引擎：

```sql
SHOW ENGINES\G
```

📌 **範例結果部分內容**（格式化後）：

![](./images/2402456-20220611162625370-165221704.png "")

### 2️⃣ 建立使用特定儲存引擎的資料表

```sql
-- 建立使用 InnoDB 的表（預設）
CREATE TABLE products_innodb (
  id INT PRIMARY KEY,
  name VARCHAR(50)
) ENGINE = InnoDB;

-- 建立使用 MEMORY 引擎的表（資料存在 RAM 中）
CREATE TABLE cache_data (
  id INT PRIMARY KEY,
  value VARCHAR(100)
) ENGINE = MEMORY;

-- 建立使用 BLACKHOLE 引擎的表（寫入資料後不儲存）
CREATE TABLE test_sink (
  id INT PRIMARY KEY,
  message VARCHAR(255)
) ENGINE = BLACKHOLE;
```

---

## 🔍 五、應用場合建議

| 引擎 | 適合情境 |
|------|-----------|
| **InnoDB** | 幾乎所有正式專案，支援交易與併發控制 |
| **MyISAM** | 查詢遠多於寫入的舊專案或只讀報表 |
| **MEMORY** | 暫存資料、快取表 |
| **BLACKHOLE** | 日誌測試、不想儲存資料但需觸發 log 或 replication |
| **ARCHIVE** | 歷史資料歸檔、壓縮存儲 |
| **CSV** | 和外部工具（如 Excel）交換資料 |
| **FEDERATED** | 跨伺服器查詢遠端 MySQL（需手動安裝） |

---

# 3. 设置系统默认的存储引擎
## 🔍 一、什麼是「預設存儲引擎」？

MySQL 支援多種儲存引擎，例如 `InnoDB`、`MyISAM`、`MEMORY` 等。  
當你**在建表時沒有指定引擎時**，MySQL 就會使用「預設儲存引擎」。

例如這段建表語句：

```sql
CREATE TABLE users (
  id INT PRIMARY KEY,
  name VARCHAR(50)
);
```

若你**沒有指定 `ENGINE = ???`**，那這張表會使用預設的引擎，通常是 `InnoDB`。

---

## 🔎 二、如何查詢目前的預設存儲引擎？

### ✅ 方法一：用 `SHOW VARIABLES`
```sql
SHOW VARIABLES LIKE '%storage_engine%';
```

你會看到類似結果：
```
+------------------------+--------+
| Variable_name          | Value  |
+------------------------+--------+
| default_storage_engine | InnoDB |
+------------------------+--------+
```

### ✅ 方法二：用變數查詢
```sql
SELECT @@default_storage_engine;
```

結果會是：
```
InnoDB
```

---

## ✏️ 三、如何修改預設存儲引擎？

### ✅ 方法一：臨時修改（只對當前連線有效）
```sql
SET DEFAULT_STORAGE_ENGINE = MyISAM;
```

> ⚠️ **此設定只在當前 MySQL session 有效**，斷線就會失效。

你可以這樣測試：

```sql
SET DEFAULT_STORAGE_ENGINE = MyISAM;

CREATE TABLE test1 (
  id INT PRIMARY KEY
);  -- 這張表會使用 MyISAM 引擎

SHOW TABLE STATUS LIKE 'test1'\G;
-- 查看 Engine 欄位確認是否為 MyISAM
```

---

### ✅ 方法二：永久修改（修改設定檔）

要讓改動永久生效，需修改設定檔 `my.cnf`（Linux）或 `my.ini`（Windows）：

```ini
[mysqld]
default-storage-engine = MyISAM
```

然後重啟 MySQL 服務：

```bash
sudo systemctl restart mysqld.service
```

或：

```bash
sudo service mysql restart
```

---

## 🧪 四、範例：驗證預設引擎是否生效

### 1️⃣ 修改為 MyISAM（臨時或永久）

```sql
SET DEFAULT_STORAGE_ENGINE = MyISAM;
```

### 2️⃣ 建立測試資料表（不指定 ENGINE）

```sql
CREATE TABLE test_engine (
  id INT PRIMARY KEY,
  msg VARCHAR(100)
);
```

### 3️⃣ 查看實際使用的引擎

```sql
SHOW TABLE STATUS LIKE 'test_engine'\G
```

查詢結果中會看到：
```
Engine: MyISAM
```

---

## 📌 小結

| 操作 | 說明 |
|------|------|
| 查詢預設引擎 | `SHOW VARIABLES LIKE '%storage_engine%'` 或 `SELECT @@default_storage_engine;` |
| 臨時修改預設引擎 | `SET DEFAULT_STORAGE_ENGINE = xxx;`（只對當前連線有效） |
| 永久修改預設引擎 | 編輯 `my.cnf` 的 `[mysqld]` 區塊，加上 `default-storage-engine = xxx` 並重啟服務 |
| 建表未指定引擎時 | 會使用當前預設的儲存引擎 |

---

如果你想，我也可以幫你寫一段**完整腳本**，一步步測試並比較不同引擎的行為（例如：支援交易、查詢速度差異等）。是否需要呢？

# 4. 设置表的存储引擎
## 🔧 一、什麼是「儲存引擎」？

- 儲存引擎（Storage Engine）是資料表背後「負責實際操作磁碟資料」的元件。
- 不同儲存引擎 = 不同的資料存儲與查詢邏輯。
- **一個 MySQL 資料庫可以同時使用多種儲存引擎**，每張表各自選擇最合適的。

---

## ✨ 二、建立表時指定儲存引擎

### 📌 語法格式：
```sql
CREATE TABLE 表名 (
    欄位1 資料型別,
    欄位2 資料型別
) ENGINE = 儲存引擎名稱;
```

### 🧪 範例：
```sql
-- 建立一張使用 MyISAM 的表
CREATE TABLE users_myisam (
  id INT PRIMARY KEY,
  name VARCHAR(50)
) ENGINE = MyISAM;

-- 建立一張使用 InnoDB（預設引擎）的表
CREATE TABLE users_innodb (
  id INT PRIMARY KEY,
  name VARCHAR(50)
) ENGINE = InnoDB;
```

---

## 🔄 三、修改表的儲存引擎

有時表已經建好，但你後來發現需要用不同的引擎（例如從不支援交易的 MyISAM 改為 InnoDB），可以用以下語法：

### 📌 語法格式：
```sql
ALTER TABLE 表名 ENGINE = 新的儲存引擎;
```

### 🧪 範例操作：
```sql
-- 將 users_myisam 表轉換為 InnoDB 引擎
ALTER TABLE users_myisam ENGINE = InnoDB;
```

✅ 修改成功後，可以用這個語句來驗證引擎是否正確更新：

```sql
SHOW CREATE TABLE users_myisam\G
```

輸出內容會顯示這行：

```
ENGINE=InnoDB DEFAULT CHARSET=utf8
```

---

## 🔍 四、常見應用場景對比

| 儲存引擎 | 是否支援交易 | 支援外鍵 | 鎖機制 | 適合用途 |
|----------|---------------|-----------|---------|-----------|
| InnoDB   | ✅ 是          | ✅ 是      | 行鎖     | 大多數應用系統、寫入多的系統 |
| MyISAM   | ❌ 否          | ❌ 否      | 表鎖     | 查詢為主、報表分析 |
| MEMORY   | ❌ 否          | ❌ 否      | 表鎖     | 暫存資料、速度要求高但可容忍資料丟失 |
| ARCHIVE  | ❌ 否          | ❌ 否      | 行鎖     | 歷史資料壓縮存放，只讀不更新 |
| BLACKHOLE| ❌ 否          | ❌ 否      | 無       | 測試 replication、不保存資料 |

---

## ✅ 小結整理

| 操作目標 | 語法或步驟 |
|----------|-------------|
| 建表時設定引擎 | `CREATE TABLE ... ENGINE = xxx;` |
| 查詢某表使用哪個引擎 | `SHOW CREATE TABLE 表名\G` |
| 修改表的儲存引擎 | `ALTER TABLE 表名 ENGINE = xxx;` |

---

# 5. 引擎介绍
## 5.1 InnoDB 引擎：具备外键支持功能的事务存储引擎
### 🧠 一、InnoDB 儲存引擎重點整理

| 特性 | 說明 |
|------|------|
| ✅ 支援交易 | 提供 **ACID** 保證，可 `COMMIT`、`ROLLBACK`、`SAVEPOINT` |
| ✅ 支援外鍵 | 可定義外鍵，建立表與表之間的「參照完整性」 |
| ✅ 行級鎖定 | 避免整張表鎖住，提高併發效能 |
| ✅ 支援資料與索引快取 | 同時快取資料與索引，效能佳但佔用記憶體大 |
| ✅ 適合 CRUD 都頻繁的應用 | 包含查詢、插入、更新、刪除 |
| ✅ MySQL 5.5 起預設引擎 | MySQL 8.0 完整整合為 `*.ibd` 檔案 |

---

### 🆚 二、與 MyISAM 差異比較

| 特性 | InnoDB | MyISAM |
|------|--------|--------|
| 交易支援 | ✅ 有 | ❌ 無 |
| 鎖機制 | 行鎖 | 表鎖 |
| 外鍵支援 | ✅ 有 | ❌ 無 |
| 快取策略 | 同時快取資料與索引 | 只快取索引 |
| 效能特性 | 寫入較慢但穩定性高 | 查詢快但不安全 |
| 檔案格式 | `.ibd` 檔案（資料+索引） | `.MYD` 資料 + `.MYI` 索引 |

---

### 🧪 三、InnoDB 儲存引擎範例操作

#### ✅ 1. 建立兩張具有外鍵關聯的 InnoDB 表

```sql
-- 主表：部門表
CREATE TABLE departments (
  dept_id INT PRIMARY KEY,
  dept_name VARCHAR(50)
) ENGINE=InnoDB;

-- 子表：員工表（引用部門ID）
CREATE TABLE employees (
  emp_id INT PRIMARY KEY,
  emp_name VARCHAR(50),
  dept_id INT,
  FOREIGN KEY (dept_id) REFERENCES departments(dept_id)
) ENGINE=InnoDB;
```

✅ 外鍵限制會保證：
- 不能插入一個不存在部門的員工。
- 當部門被刪除時，如果有員工對應該部門，會阻止刪除或自動連動（看你設定的 ON DELETE 行為）。

---

#### ✅ 2. 測試交易（Transaction）能力

```sql
-- 開始交易
START TRANSACTION;

-- 插入資料
INSERT INTO departments VALUES (10, 'IT');
INSERT INTO employees VALUES (1, '小明', 10);

-- 發現錯誤，回滾所有操作
ROLLBACK;

-- 查詢表，會發現資料沒寫入
SELECT * FROM departments;
SELECT * FROM employees;
```

---

#### ✅ 3. 檢查表使用的儲存引擎

```sql
SHOW TABLE STATUS LIKE 'employees'
```

結果中會看到：
```
Engine: InnoDB
```

---

### 📁 四、InnoDB 的檔案結構（MySQL 8.0）

- **以前版本（5.x）**：
  - `.frm`：儲存表結構（已棄用）
  - `.ibd`：資料 + 索引
- **MySQL 8.0 起：**
  - 所有內容整合到 `.ibd` 檔案中（使用獨立表空間 innodb_file_per_table）

你可以在資料目錄中看到：
```
/var/lib/mysql/你的資料庫/
  └── employees.ibd
```

---

### 📌 小結

| InnoDB 優勢 | 適用場景 |
|-------------|-----------|
| ✅ 交易支援、行鎖、外鍵 | 線上購物系統、銀行系統、ERP、CRM |
| ✅ 避免資料不一致風險 | 高併發、資料一致性要求高 |
| ✅ 可持久化快取（索引+資料） | 記憶體夠大效能好 |

---

是否需要我設計一個實作任務：例如「用 InnoDB 實作一個帶外鍵、交易回滾的訂單系統」幫你練習？只要你說一聲，我可以直接幫你出題設計 😊

## 5.2 MyISAM 引擎：主要的非事务处理存储引擎 
### 🔍 一、MyISAM 儲存引擎特色

| 特性 | 說明 |
|------|------|
| ❌ 不支援交易 | 沒有 COMMIT / ROLLBACK |
| ❌ 不支援行鎖 | 只有 **表級鎖**，多使用者寫入容易阻塞 |
| ❌ 不支援外鍵 | 表與表之間無參照完整性限制 |
| ✅ 支援全文索引（FULLTEXT） | 適合文章搜尋、部落格等應用 |
| ✅ 查詢速度快 | 特別是 `COUNT(*)` 查詢非常快（維護有資料行數統計） |
| ❌ 當機後無法安全恢復 | 資料容易損壞，不建議用於重要交易系統 |
| ✅ 空間函數（GIS）支援 | 適合簡單地理位置查詢 |
| 📂 檔案格式 | `.frm` 結構、`.MYD` 資料、`.MYI` 索引（可備份拷貝） |

---

### 📁 二、MyISAM 的檔案結構

如果你建立一張 `user` 表，MySQL 會生成以下 3 個檔案（前提是使用 MyISAM 引擎）：

| 檔名        | 說明           |
|-------------|----------------|
| `user.frm`  | 表結構         |
| `user.MYD`  | 表數據         |
| `user.MYI`  | 表索引         |

這種「**分檔存儲**」的方式可以直接備份資料檔，不需要導出 SQL。

---

### 🧪 三、MyISAM 範例操作

#### ✅ 1. 建立一張 MyISAM 表

```sql
CREATE TABLE blog_posts (
  id INT PRIMARY KEY,
  title VARCHAR(100),
  content TEXT,
  FULLTEXT(title, content)
) ENGINE = MyISAM;
```

這張表的特點：
- 使用 MyISAM 引擎
- 建立了全文索引 `FULLTEXT(title, content)`，可進行關鍵字搜尋

---

#### ✅ 2. 測試 FULLTEXT 全文搜尋功能（MyISAM 專屬）

```sql
-- 插入資料
INSERT INTO blog_posts VALUES (1, 'MySQL 儲存引擎', '介紹 InnoDB 和 MyISAM 的區別');
INSERT INTO blog_posts VALUES (2, 'Vue 教學', '從前端到後端開發的整合方式');

-- 使用全文搜尋查詢關鍵字 "MyISAM"
SELECT * FROM blog_posts
WHERE MATCH(title, content) AGAINST('MyISAM');
```

只有 MyISAM（或 InnoDB 支援 FULLTEXT 的版本）支援這種 `MATCH ... AGAINST` 語法。

---

#### ✅ 3. 測試 COUNT(*) 效率（維護行數）

```sql
SELECT COUNT(*) FROM blog_posts;
```

MyISAM 引擎中這個語句會**直接讀出已記錄的行數統計**，速度非常快，特別適合報表與統計。

---

#### ✅ 4. 模擬當機場景（不建議於正式環境）

由於 MyISAM 不支援交易，以下操作無法回滾：

```sql
-- 插入資料
INSERT INTO blog_posts VALUES (3, '當機測試', '這段資料若系統掛掉就會損壞');

-- 忘了 commit？=> 無效
ROLLBACK;

-- 仍然會看到資料存在
SELECT * FROM blog_posts WHERE id = 3;
```

📌 這就是 MyISAM 的風險：**操作無回滾，一旦掛機或異常重啟，資料可能會遺失或破壞**。

---

### 📌 四、MyISAM 適合的應用場景

| 適用場景 | 說明 |
|----------|------|
| 📖 文章搜尋系統 | 利用 FULLTEXT 做全文檢索 |
| 📊 只讀報表統計 | 僅查詢、不寫入的報表系統 |
| 📂 備份檔案系統 | 可直接拷貝 `.MYD` / `.MYI` 做備份還原 |
| ❌ 不建議用於銀行/商店等交易系統 | 因為沒有交易安全與回滾機制 |

---

### ✅ 小結

| 功能 | InnoDB | MyISAM |
|------|--------|--------|
| 交易支援 | ✅ | ❌ |
| 表鎖 vs 行鎖 | 行鎖 | 表鎖 |
| FULLTEXT | ✅（5.6 起）| ✅ |
| 當機後恢復 | 安全恢復 | ❌ |
| 查詢速度 | 快（依記憶體）| 非常快（內建統計） |
| 記憶體需求 | 高 | 低 |
| 備份彈性 | 較差（需備份工具）| 可直接拷貝檔案 |

---

## 5.3 Archive 引擎：用于数据存档 
### 🧠 一、什麼是 ARCHIVE 儲存引擎？

| 特性 | 說明 |
|------|------|
| ✅ 只支援 `INSERT` 和 `SELECT` | **不能做 `UPDATE`、`DELETE`** |
| ✅ 支援壓縮儲存 | 使用 `zlib` 做即時壓縮，儲存空間超省（最多可省 83%） |
| ✅ 支援行級鎖 | 在併發插入上比 MyISAM 更安全 |
| ✅ 支援 `AUTO_INCREMENT` 欄位 | 可設主鍵或非主鍵自動編號欄位 |
| ✅ 支援簡單索引（5.5 起） | 只能針對 `AUTO_INCREMENT` 欄位建立索引 |
| ❌ 不支援修改與刪除資料 | 一但插入就無法改動，資料變成「唯讀」 |
| ❌ 查詢效率低、功能有限 | 適合只讀應用，如日誌、歸檔資料 |
| 📂 檔案格式 | `.frm`（表結構）+ `.ARZ`（壓縮後資料） |

---

### 📦 二、適用場景

| 場景 | 原因 |
|------|------|
| 🧾 日誌系統 | 資料只寫入，不修改 |
| 📈 歷史交易記錄 | 資料存檔查詢，空間壓縮需求高 |
| 📊 數據倉儲（只讀） | 資料不會更新，需保留大量紀錄 |
| ❌ 即時查詢、分析系統 | 不適用，因為查詢效能較差，功能受限 |

---

### 🧪 三、實戰範例

#### ✅ 1. 建立 ARCHIVE 表

```sql
CREATE TABLE user_logs (
  id INT AUTO_INCREMENT PRIMARY KEY,
  log_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  message TEXT
) ENGINE = ARCHIVE;
```

#### ✅ 2. 插入資料（支援高速寫入）

```sql
INSERT INTO user_logs (message) VALUES 
('使用者登入成功'),
('使用者修改密碼'),
('使用者登出');
```

✅ 可以像一般表一樣插入資料，只是資料會被壓縮儲存。

---

#### ❌ 3. 嘗試修改或刪除（會報錯）

```sql
-- 嘗試更新
UPDATE user_logs SET message = '錯誤' WHERE id = 1;
-- ❌ 錯誤：The storage engine for the table doesn't support update

-- 嘗試刪除
DELETE FROM user_logs WHERE id = 1;
-- ❌ 錯誤：The storage engine for the table doesn't support delete
```

---

#### ✅ 4. 查詢資料（支援基本 SELECT）

```sql
SELECT * FROM user_logs;
```

🔍 注意：查詢速度相較 InnoDB 或 MyISAM 慢，但適用於不常查詢、偶爾統計的場景。

---

### 📁 四、檔案儲存結構

在資料庫目錄中（如 `/var/lib/mysql/資料庫名/`），會看到類似這些檔案：

| 檔案 | 說明 |
|------|------|
| `user_logs.frm` | 儲存表結構（8.0前） |
| `user_logs.ARZ` | 儲存壓縮後的表資料（主體） |

---

### 🆚 五、與其他引擎比較

| 功能項目 | InnoDB | MyISAM | ARCHIVE |
|----------|--------|--------|---------|
| 支援交易 | ✅ | ❌ | ❌ |
| 支援修改與刪除 | ✅ | ✅ | ❌ |
| 儲存空間效率 | 中 | 普通 | ✅ 最省 |
| 查詢效能 | 高 | 高 | ❌ 低 |
| 插入效能 | 中 | 高 | ✅ 非常高 |
| 適用場景 | 一般應用、交易系統 | 報表查詢、全文搜尋 | 歷史日誌、冷資料歸檔 |

---

### ✅ 小結重點

| 核心特性 | 說明 |
|----------|------|
| 📥 只能插入與查詢 | 不可 UPDATE / DELETE |
| 🗜️ 壓縮儲存 | 省空間，適合大量歷史資料 |
| ⚡ 插入效能高 | 適合高頻寫入、不需即時查詢 |
| ❗ 查詢功能弱 | 避免頻繁查詢、複雜分析 |

---

如果你有一個 **網站操作紀錄系統** 或 **交易備份資料庫**，我可以幫你規劃怎麼用 ARCHIVE + InnoDB 組合設計資料表，主資料用 InnoDB，歷史存進 ARCHIVE。要試試看嗎？🙂

## 5.4 Blackhole 引擎：丢弃写操作，读操作会返回空内容 
### 🧠 一、什麼是 Blackhole 儲存引擎？

| 特性 | 說明 |
|------|------|
| ❌ 不儲存任何資料 | **插入的資料會直接被丟棄** |
| ✅ 可以寫操作 | 可以執行 `INSERT`、`UPDATE`、`DELETE`，但實際上資料不會保存 |
| ✅ 支援日誌記錄 | 插入等操作會被寫入 MySQL 的 binary log（主從複製可以用） |
| ✅ SELECT 查詢會永遠是空的 | 因為資料根本沒儲存，所以查詢永遠沒有結果 |
| 📜 主要用途 | 測試、特殊複製同步（透過 binlog 同步到其他真實存儲的備庫） |

---

### 📚 二、常見用途

| 用途 | 說明 |
|------|------|
| 測試 SQL 語法 | 測試指令是否正確執行，而不實際儲存資料 |
| 主從複製中作為中繼 | 在主庫上寫入，但透過 binlog 複製到從庫，由從庫儲存資料 |
| 特殊日誌記錄需求 | 只需要記錄寫入行為，不需要保留資料 |

> ⚠️ 但由於容易造成資料同步問題，**不推薦正式使用在商業環境**。

---

### 🧪 三、實戰範例操作

#### ✅ 1. 建立一個 Blackhole 表

```sql
CREATE TABLE test_blackhole (
  id INT PRIMARY KEY,
  msg VARCHAR(100)
) ENGINE = BLACKHOLE;
```

✅ 成功建立表，但注意：這張表**本身不儲存任何資料**。

---

#### ✅ 2. 插入資料（會被丟棄）

```sql
INSERT INTO test_blackhole (id, msg) VALUES (1, 'Hello World');
INSERT INTO test_blackhole (id, msg) VALUES (2, 'Blackhole Example');
```

✅ 插入語法執行成功，但這些資料實際上「**沒有被寫到磁碟**」，只會記錄到 binary log。

---

#### ✅ 3. 查詢資料（結果為空）

```sql
SELECT * FROM test_blackhole;
```

查詢結果永遠是：

```
Empty set (0.00 sec)
```

因為 Blackhole 引擎根本沒有存任何資料。

---

### 🔥 四、Blackhole 如何搭配主從複製？

一個特別用途是這樣：

- 主伺服器 A（使用 Blackhole 表） → 只產生 binary log
- 從伺服器 B（使用正常 InnoDB 表） → 從 binlog 把資料寫進表格

✅ 好處：
- 主伺服器負載輕（因為不用儲存資料）
- 從伺服器儲存真實資料

⚠️ 缺點：
- 容易因網路或設定問題導致資料不一致
- 如果 binlog 或同步出錯，資料無法復原

因此現代大多數情況會直接用 **InnoDB + 主從複製**，而不是 Blackhole。

---

### 📌 小結重點

| 特性 | 說明 |
|------|------|
| INSERT / UPDATE / DELETE | ✅ 可以執行但不保存 |
| SELECT 查詢結果 | ❌ 永遠是空的 |
| 用途 | 測試、記錄 binlog、主從複製 |
| 不適合 | 真正需要保存資料的業務系統 |

---

### 🧩 補充小技巧
如果你想臨時測試「**大量寫入效能**」但又不想真的塞滿硬碟，可以用 Blackhole 表來測試 SQL 執行時間，非常適合效能測試場景！

例如：

```sql
-- 測試單次插入一萬筆資料的效能
INSERT INTO test_blackhole (id, msg)
SELECT seq, CONCAT('Message ', seq)
FROM seq_1_to_10000;  -- 這是自訂產生1到10000序號的表
```

這樣可以快速測試 SQL 效能，而不佔用磁碟空間。

---

要不要我順便幫你設計一個簡單的**Blackhole 主從同步範例架構**給你練習？只要一點點設定，可以讓你理解「binlog 傳資料但本地不存」的完整流程！要的話跟我說！【舉手】

## 5.5 CSV 引擎：存储数据时，以逗号分隔各个数据项 
### 🧠 一、什麼是 CSV 儲存引擎？

CSV（Comma-Separated Values）引擎的本質是：  
> ✅ 每一筆資料都存成一行文字，以 **逗號分隔欄位值**（即 .csv 格式）

| 特性 | 說明 |
|------|------|
| ✅ 資料以純文字 .csv 檔案存放 | 可以用 Excel / 記事本 / Notepad++ 開啟 |
| ✅ 可用 SQL 查詢與插入 | 可用 `SELECT`、`INSERT` |
| ❌ 不支援索引 | 不能建立 `PRIMARY KEY`、`INDEX` |
| ✅ 適合資料交換 | 資料夾拷貝即完成匯出 / 匯入 |
| ❌ 查詢效能差 | 因為沒有索引，每次查詢會讀整個檔案 |

---

### 📦 二、檔案結構與說明

建立一張 `CSV` 表之後，MySQL 會在資料庫目錄中建立以下 3 種檔案：

| 檔案 | 功能 |
|------|------|
| `test.frm` | 儲存表格結構（MySQL 5.x 以前用） |
| `test.CSV` | 實際儲存資料（文字檔，每行一筆） |
| `test.CSM` | 儲存表狀態與行數等中繼資訊 |

> ✅ 可以直接用 Excel 開啟 `.CSV` 來查看內容，也可以直接寫入再讓 MySQL 查詢！

---

### 🧪 三、實戰範例操作

#### ✅ 1. 建立 CSV 表

```sql
CREATE TABLE test_csv (
  id INT NOT NULL,
  name VARCHAR(50) NOT NULL
) ENGINE = CSV;
```

執行完後，在你的 MySQL 資料庫目錄中會產生：
```
test_csv.frm
test_csv.CSV
test_csv.CSM
```

---

#### ✅ 2. 插入資料

```sql
INSERT INTO test_csv VALUES 
(1, 'Alice'),
(2, 'Bob');
```

✅ 插入成功後，你用記事本或 Notepad++ 打開 `test_csv.CSV` 檔案，會看到如下格式：

```csv
"1","Alice"
"2","Bob"
```

📌 注意：每個值都被雙引號包起來，且以逗號分隔。

---

#### ✅ 3. 查詢資料

```sql
SELECT * FROM test_csv;
```

結果輸出：

```
+----+-------+
| id | name  |
+----+-------+
|  1 | Alice |
|  2 | Bob   |
+----+-------+
```

> ✅ 完全可以用 SQL 操作 `.CSV`，就像一般資料表一樣查詢。

---

### 🚫 四、限制與注意事項

| 限制項目 | 說明 |
|----------|------|
| ❌ 不支援索引 | 不能加主鍵或索引，查詢慢 |
| ❌ 不支援 `UPDATE`、`DELETE` | 這些操作理論上可用，但不建議頻繁使用 |
| ❌ 無交易支援 | 不可用 `ROLLBACK` / `COMMIT` |
| ❌ 不支援 NULL | CSV 表不能有 `NULL` 欄位值，會報錯 |
| ❌ 同步讀寫有限制 | 多人併發存取容易出錯，不適合高併發環境 |

---

### 📊 五、CSV 引擎使用情境整理

| 使用場景 | 原因 |
|----------|------|
| ✅ 快速導入 / 匯出 | 可直接將 `.CSV` 傳給其他人或軟體 |
| ✅ 系統間資料交換 | 不同平台之間用 `.csv` 格式最通用 |
| ✅ 臨時報表生成 | 用 SQL 建立簡表後用 Excel 開啟查看 |
| ❌ 正式業務系統資料儲存 | 因為無索引 / 效能低，僅適合過渡資料表 |

---

### 🔧 補充技巧：直接拷貝 CSV 文件來匯入資料

假設你有一個外部 `.csv` 檔（用 Excel 建的）如下：

```
"3","Carol"
"4","David"
```

你可以手動貼到 `test_csv.CSV` 檔尾部，儲存後用 MySQL 查詢就會讀出來！  
📌 這也是為什麼 CSV 引擎特別適合資料交換與整合！

---

### ✅ 小結

| 特性 | 說明 |
|------|------|
| ✅ 支援 SQL 操作 `.csv` 檔案 | 用 SQL 當作文字檔資料管理方式 |
| ✅ 支援快速導出/導入 | 結合 Excel / 文字工具效率高 |
| ❌ 不支援索引、交易 | 效能差、僅適用暫存或交換資料 |

---

## 5.6 Memory 引擎：置于内存的表
> MySQL 中的 **`MEMORY`（記憶體）儲存引擎**，它是一種專門將資料**儲存在 RAM（記憶體）中**的引擎，用來極大提升存取速度。不過它有個致命缺點：**資料不會永久保存，MySQL 服務重啟後資料就會消失**。

---

### 🧠 一、Memory 引擎特性總覽

| 特性 | 說明 |
|------|------|
| 📌 資料存在記憶體中 | 超快查詢與寫入速度 |
| ❌ 資料不持久化 | mysqld 重啟 → 資料消失 |
| ❌ 不支援 TEXT / BLOB | 因為長度不固定 |
| ✅ 支援 HASH / BTREE 索引 | 預設為 `HASH`，可手動指定 `BTREE` |
| 📦 限制表大小 | 受限於 `max_heap_table_size`（預設 16MB）與 `max_rows` |

---

### 📂 二、實際檔案結構

當你建立一個 `MEMORY` 表時：

- MySQL 只會產生 `.frm`（表結構檔案）
- **資料本體存在於記憶體中**，不寫入磁碟
- 所以 mysqld 一旦重啟，記憶體清空，資料就沒了！

---

### ⚙️ 三、範例操作

#### ✅ 1. 建立 `MEMORY` 表

```sql
CREATE TABLE memory_demo (
  id INT PRIMARY KEY,
  name CHAR(20)
) ENGINE = MEMORY;
```

這張表現在會存在於 **記憶體中**，而非磁碟。

---

#### ✅ 2. 插入與查詢資料

```sql
INSERT INTO memory_demo VALUES (1, 'Alice'), (2, 'Bob');

SELECT * FROM memory_demo;
```

查詢結果會正常顯示：

```
+----+-------+
| id | name  |
+----+-------+
|  1 | Alice |
|  2 | Bob   |
+----+-------+
```

---

#### ❌ 3. 重啟 mysqld 測試資料是否存在

若你執行以下動作：

```bash
sudo systemctl restart mysqld
```

接著重新查詢資料表：

```sql
SELECT * FROM memory_demo;
```

結果會是：

```
Empty set (0.00 sec)
```

📌 因為 **資料已丟失！**

---

#### ⚠️ 4. 建立含 TEXT/BLOB 欄位會報錯

```sql
CREATE TABLE invalid_mem (
  id INT,
  content TEXT
) ENGINE = MEMORY;
```

❌ MySQL 會報錯：

```
BLOB/TEXT column 'content' can't be used in MEMORY table
```

---

#### 🧪 5. 使用 BTREE 索引範例（範圍查詢適用）

```sql
CREATE TABLE btree_test (
  id INT,
  name VARCHAR(50),
  INDEX (name) USING BTREE
) ENGINE = MEMORY;
```

> 預設是 `HASH` 索引（只適合「相等比較」），如果要做 `BETWEEN`、`LIKE 'A%'`，就需要 `BTREE` 索引。

---

### 📊 四、使用場景推薦

| 適合情境 | 原因 |
|----------|------|
| ✅ 快速查詢的臨時資料 | 存在 RAM，查詢超快 |
| ✅ 儲存中間計算結果 | 例如彙總後再轉存 InnoDB 表 |
| ✅ Session/快取資料表 | 登入緩存、頻繁存取但資料不重要 |
| ❌ 永久資料儲存 | 資料重啟會消失，不適合用於正式業務資料表 |

---

### ⚙️ 五、控制表大小參數

你可以透過下列變數限制 `MEMORY` 表的最大大小：

```sql
SHOW VARIABLES LIKE 'max_heap_table_size';
```

預設值通常是 **16MB**，可以透過設定檔 `my.cnf` 或 SQL 調整：

```sql
SET GLOBAL max_heap_table_size = 1024 * 1024 * 64;  -- 64MB
```

---

### ✅ 小結整理

| 項目 | 說明 |
|------|------|
| 儲存位置 | RAM（記憶體） |
| 持久性 | ❌ 不持久，重啟資料消失 |
| 適合資料型別 | 固定長度（如 CHAR、INT） |
| 不支援型別 | BLOB、TEXT |
| 預設索引類型 | HASH（可改為 BTREE） |
| 表大小限制 | `max_heap_table_size`、`max_rows` |

---

### 🎯 延伸應用建議

你可以設計如下流程應用 `MEMORY` 表：

```text
資料來源 → 匯入 MEMORY 表（快速操作） → 資料處理 / 篩選 → 匯出或轉存至 InnoDB
```

例如：大量使用者上傳 CSV，你先寫入 MEMORY 表處理格式 → 最後再存回正式表。

---

如果你需要，我可以幫你設計一個「MEMORY + InnoDB 結合的快取應用案例」或「排行榜臨時快取設計」。想練習看看嗎？🙂

## 5.7 Federated 引擎：访问远程表
> MySQL 的 **`FEDERATED` 儲存引擎**，這是個很特別的引擎，它不儲存任何本地資料，而是當作「**遠端 MySQL 伺服器表格的代理**」來用。簡單來說，它就像是在本地創了一個表，但背後其實是連到另一台 MySQL 的資料表。

---

### 🧠 一、什麼是 Federated 引擎？

| 特性 | 說明 |
|------|------|
| ✅ **跨伺服器存取 MySQL 資料表** | 在 A 資料庫操作其實是遠端連到 B 資料庫 |
| ❌ 不儲存資料 | 本地沒有任何資料檔，只存表結構（`.frm`） |
| ✅ 支援 SELECT、INSERT、UPDATE、DELETE | 就像操作本地表一樣使用 SQL |
| ⚠️ 預設是 **禁用** 的 | 需要開啟 `federated` 支援 |
| ❗ 無快取、性能依賴網路 | 效能遠遠不如本地表 |

---

### 📦 二、使用限制與注意

- ✅ 適合：**簡單資料整合、測試跨伺服器通訊**
- ❌ 不適合：高併發、實時查詢、需要 JOIN 的情境
- ❌ 不支援外鍵、索引同步等複雜功能

---

### 🧰 三、開啟 Federated 引擎

Federated 是 MySQL 的「插件式引擎」，預設 **未啟用**。啟用方式如下：

#### ✅ 方法一：啟動時加參數

```bash
mysqld --federated
```

#### ✅ 方法二：編輯設定檔

在 `my.cnf` 中加入：

```ini
[mysqld]
federated
```

然後重啟 MySQL：

```bash
sudo systemctl restart mysqld
```

確認是否啟用：

```sql
SHOW ENGINES;
```

出現這行表示已開啟：

```
| FEDERATED | YES | Support for federated tables |
```

---

### 🧪 四、實際範例操作（兩台 MySQL）

#### 🧵 假設環境：

| 項目 | 值 |
|------|----|
| 遠端 MySQL | IP: `192.168.1.100`，port: `3306` |
| 資料庫 | `remote_db` |
| 表格 | `users` |
| 使用者 | `federated_user`，密碼 `pass1234` |

---

#### ✅ Step 1：遠端伺服器建立實際表

```sql
-- 在 192.168.1.100 上建立真實的表
CREATE DATABASE remote_db;
USE remote_db;

CREATE TABLE users (
  id INT PRIMARY KEY,
  name VARCHAR(100)
);
```

---

#### ✅ Step 2：本地端建立 FEDERATED 表

```sql
CREATE TABLE users_proxy (
  id INT,
  name VARCHAR(100)
) ENGINE=FEDERATED
CONNECTION='mysql://federated_user:pass1234@192.168.1.100:3306/remote_db/users';
```

> 📌 `CONNECTION` 語法格式如下：
```
mysql://[使用者]:[密碼]@[host]:[port]/[資料庫名]/[表名]
```

---

#### ✅ Step 3：在本地端查詢遠端資料

```sql
SELECT * FROM users_proxy;
```

📌 這條查詢實際會去 **192.168.1.100 的 remote_db.users 表** 抓資料。

---

#### ✅ Step 4：也可以插入、更新、刪除

```sql
INSERT INTO users_proxy VALUES (1, 'Alice');

UPDATE users_proxy SET name = 'Bob' WHERE id = 1;

DELETE FROM users_proxy WHERE id = 1;
```

這些操作都會在遠端資料表發生效果。

---

### 🧩 五、使用情境建議

| 適合使用場景 | 不適合使用場景 |
|--------------|----------------|
| 資料整合與同步（只需簡單表） | 複雜報表查詢、大量 join |
| 跨伺服器維運工具或備份 | 高效能交易系統 |
| 當成暫時資料通道 | 有高查詢需求的即時系統 |

---

### ✅ 小結

| 特性 | 說明 |
|------|------|
| 🔌 跨伺服器代理表 | 僅存表結構，本地資料實際在遠端 |
| ⚙️ 須手動開啟 | 預設為禁用，需設定開啟 federated 引擎 |
| ✅ 可 SELECT / INSERT / UPDATE / DELETE | 支援基本 CRUD 操作 |
| ❗ 無快取、依賴網路效能 | 不建議大量查詢或 JOIN 操作 |

---

如果你想，我可以幫你設計一個「**主伺服器使用 FEDERATED 同步部分資料到備伺服器**」的架構，讓你練習建構資料同步機制。需要的話跟我說，我可以提供指令與流程圖 👍

## 5.8 Merge引擎：管理多个MyISAM表构成的表集合
> **MySQL 的 Merge 儲存引擎**（又名 `MRG_MYISAM`），你講的是一種可以**把多個 MyISAM 表「合併」成一個虛擬表** 來查詢或操作的機制。這個功能可以讓你像使用一張大表一樣操作多張結構相同的表，非常適合用在 **分區、分表查詢** 的場景。

---

### 🧠 一、什麼是 Merge（MRG_MYISAM）儲存引擎？

| 特性 | 說明 |
|------|------|
| 🔗 把多個 **MyISAM 表合併成虛擬表** | 多張表邏輯上變成一張表 |
| 🧱 所有子表的**表結構必須完全相同** | 欄位數、名稱、順序、類型都要一致 |
| 🔍 可在 Merge 表上使用 `SELECT`、`INSERT` | 寫入會寫入某一個子表（可指定） |
| ❌ 不支援 `UPDATE`、`DELETE` | 要對個別子表執行 |
| 📂 僅支援 MyISAM 表 | InnoDB、Memory、CSV 都不支援合併 |

---

### 🔍 二、Merge 儲存引擎的應用場景

| 場景 | 適用理由 |
|------|----------|
| 📆 分月儲存交易資料 | 每個月一張 MyISAM 表，合併查詢 |
| 📂 歷史資料分表管理 | 獨立表易於備份與維護，查詢時合併 |
| 🧪 分批寫入資料測試 | 各子表分別寫入，查詢統一管理 |

---

### 🧪 三、實戰範例

#### ✅ 1. 建立兩張結構相同的 MyISAM 表

```sql
CREATE TABLE orders_jan (
  id INT,
  product VARCHAR(100),
  amount INT
) ENGINE = MyISAM;

CREATE TABLE orders_feb LIKE orders_jan; -- 複製結構
```

✅ 這兩張表的結構一模一樣。

---

#### ✅ 2. 插入一些資料

```sql
INSERT INTO orders_jan VALUES (1, 'Apple', 10);
INSERT INTO orders_feb VALUES (2, 'Banana', 5);
```

---

#### ✅ 3. 建立 Merge 表合併兩張子表

```sql
CREATE TABLE orders_merge (
  id INT,
  product VARCHAR(100),
  amount INT
) ENGINE = MRG_MYISAM
UNION=(orders_jan, orders_feb)
INSERT_METHOD=LAST;
```

| 參數 | 說明 |
|------|------|
| `UNION=(...)` | 指定要合併的子表 |
| `INSERT_METHOD=LAST` | 寫入操作會寫到哪一張子表（可設 `FIRST`、`LAST` 或 `NO`） |

---

#### ✅ 4. 查詢 Merge 表（相當於 UNION ALL）

```sql
SELECT * FROM orders_merge;
```

結果：
```
+----+---------+--------+
| id | product | amount |
+----+---------+--------+
|  1 | Apple   |     10 |
|  2 | Banana  |      5 |
+----+---------+--------+
```

就像你查詢一張整合的大表。

---

#### ✅ 5. 寫入資料

```sql
INSERT INTO orders_merge VALUES (3, 'Orange', 8);
```

會寫入到 `orders_feb`（因為你指定了 `INSERT_METHOD=LAST`）。

---

### ⚠️ 四、限制與注意事項

| 限制 | 說明 |
|------|------|
| ❌ 不支援 `UPDATE`、`DELETE` | 無法直接在 Merge 表中修改或刪除 |
| ❌ 只能合併 MyISAM 表 | 不支援 InnoDB、MEMORY 等引擎 |
| ⚠ 子表結構要完全一致 | 否則無法建立 Merge 表 |
| ⚠ 資料一致性需自行維護 | Merge 表只是查詢代理，不會同步更新結構 |

---

### ✅ 小結整理

| 功能 | 說明 |
|------|------|
| 合併多張 MyISAM 表 | 做成邏輯上的一張大表 |
| 適用查詢場景 | 快速整合歷史資料表（如分月分區表） |
| INSERT 可用 | 指定 `INSERT_METHOD` 寫入第一張或最後一張子表 |
| UPDATE/DELETE 禁用 | 需直接針對子表操作 |
| 子表必須是 MyISAM 且結構一致 | 否則 Merge 表無法運作 |

---

### 🧩 延伸應用

你可以把 Merge 表當作簡易分區功能的替代方案，例如：

- `orders_2024_01`、`orders_2024_02`、... 每月一表  
- 建立 `orders_merge` 合併所有分表查詢  
- 根據時間查特定表，整體查合併表

---

## 5.9 NDB引擎：MySQL集群专用存储引擎
> **NDB 引擎**，指的是 **MySQL Cluster 專用的儲存引擎**，也叫做 **NDB Cluster Storage Engine**。這個引擎是 MySQL 的分散式解決方案，用來建構高可用、可擴展的叢集型資料庫，非常類似於 Oracle 的 RAC（Real Application Clusters）架構。

---

### 🧠 一、什麼是 NDB (MySQL Cluster) 引擎？

| 特性 | 說明 |
|------|------|
| 📦 分散式儲存 | 資料存在多個**數據節點（Data Nodes）**中，而非單一 MySQL Server |
| 💾 記憶體 + 磁碟混合存儲 | 預設在 RAM 中儲存資料，也可設定使用磁碟擴充 |
| 🔗 高可用性 | 節點之間有備援（replica），一台掛掉不會中斷服務 |
| 🚀 高吞吐量 | 適合大量讀寫操作，支援即時應用（如電信系統） |
| ❗ 只能在 MySQL Cluster 架構中使用 | 一般的 MySQL Server 無法直接使用 `NDB` 引擎 |
| 🔁 自動分片（Sharding） | 大表自動切成多個分片分佈到各節點 |

---

### 🏗️ 二、MySQL Cluster 架構圖

```text
     +-------------------+
     | SQL Node (MySQLD) |   ← 使用者操作的入口
     +--------+----------+
              |
       +------+------+
       |  NDB API    |
       +------+------+
              |
      +-------+--------+
      |                |
+-----+-----+    +-----+-----+
| Data Node |    | Data Node |   ← NDB 引擎真正儲存資料的地方（記憶體+磁碟）
+-----------+    +-----------+
```

- 🧑‍💻 **SQL Node**：標準 MySQL Server，提供 SQL 操作
- 📶 **NDB API**：底層與分布式資料節點的溝通通道
- 🧱 **Data Node**：存放資料與索引，可有多台，做資料分散與備援

---

### ⚙️ 三、基本使用前提

要使用 `NDB` 引擎，你必須：
1. 安裝 **MySQL Cluster 套件**（與一般 MySQL 不同）
2. 配置並啟動至少：
   - 1 個 **管理節點**
   - 2 個 **資料節點**
   - 1 個或多個 **SQL 節點**
3. 啟動 `ndbd` 或 `ndbmtd` 程序（即 Data Node）

---

### 🧪 四、使用 NDB 儲存引擎的範例

> 假設你已經安裝好 MySQL Cluster 並啟動了各節點，以下為使用 NDB 引擎的語法：

#### ✅ 建立一張使用 NDB 引擎的表

```sql
CREATE TABLE customers (
  id INT PRIMARY KEY,
  name VARCHAR(100),
  phone VARCHAR(20)
) ENGINE = NDB;
```

📌 若你在 SQL Node 上執行這個語句：
- 表格實體資料會儲存在後端的 **Data Node** 中
- SQL Node 只會記錄 metadata
- 資料自動分片、同步備援

---

#### ✅ 插入與查詢資料

```sql
INSERT INTO customers VALUES (1, 'Alice', '0900-111-222');
INSERT INTO customers VALUES (2, 'Bob', '0911-222-333');

SELECT * FROM customers;
```

✅ 執行效果就跟 InnoDB 表一樣，但背後是透過 NDB 分散處理

---

#### ✅ 設定副本與分片（透過 config.ini）

MySQL Cluster 中的分片與副本是自動化的，但可以在設定檔中自定義：

```ini
[NDBD DEFAULT]
NoOfReplicas=2
DataMemory=80M
IndexMemory=18M
```

表示：
- 每筆資料會有 **2 個副本**
- 每個資料節點會用 80MB 存資料、18MB 存索引

---

### 📊 五、適合使用 NDB 引擎的情境

| 適用場景 | 原因 |
|----------|------|
| 📱 電信/即時計費系統 | 大量寫入、高可用性要求 |
| 🌐 線上遊戲即時資料儲存 | 計數器、事件、在線人數 |
| 🧮 分析型系統前端 | 數據倉儲快取 |
| ❌ 小型應用、網站後台 | 成本高、維護複雜，不建議使用

---

### ⚠️ 六、使用限制與注意

| 限制 | 說明 |
|------|------|
| ❌ 不支援外鍵 | NDB 引擎不支援 FOREIGN KEY 約束 |
| ❗ 每筆資料預設需保存在記憶體中 | 雖支援磁碟擴展，但設計核心還是基於記憶體 |
| 🛠 維運難度高 | 部署需多台伺服器 + cluster 配置技能 |
| ❌ 不支援部分 MySQL 特性 | 如全文索引、GIS 索引等

---

### ✅ 小結

| 特性 | 說明 |
|------|------|
| ✨ 分布式、高可用 | 自動同步、容錯 |
| 🚀 高速寫入、即時查詢 | 記憶體儲存，節點並行 |
| 🧱 需要 MySQL Cluster 架構 | 一般 MySQL 無法使用 NDB 引擎 |
| 🔧 複雜度高 | 適合企業級應用場景（如電信、IoT） |

---

如果你想，我可以幫你畫出 **MySQL NDB Cluster 架構圖** 或提供一份完整的 `config.ini` 範本與啟動步驟，幫你搭建本地測試環境。是否需要？我們可以一步一步來 😊

## 5.10 引擎对比
- 其实这些东西大家没必要立即就给记住，列出来的目的就是想让大家明白不同的存储引擎支持不同的功能。
- 其实我们最常用的就是 InnoDB 和 MyISAM ，有时会提一下 Memory 。其中 InnoDB 是 MySQL 默认的存储引擎。

# 6. MyISAM和InnoDB
### 一、簡要解釋：什麼是存儲引擎？

MySQL 存儲引擎是一種**管理資料表資料的底層程式模組**，每種引擎處理資料的方式不同，例如是否支援事務、是否支援行鎖、是否支援外鍵等。

就像在同一間工廠中可以使用不同機器來包裝商品，每台機器（存儲引擎）各有不同功能和效率。

---

### 二、MyISAM 與 InnoDB 對比說明

| 功能/特性         | **MyISAM**（舊預設）         | **InnoDB**（現行預設）             |
|------------------|-----------------------------|-----------------------------------|
| 是否支援事務     | ❌ 不支援                    | ✅ 支援 ACID 事務                    |
| 是否支援外鍵     | ❌ 不支援                    | ✅ 支援外鍵關聯                     |
| 鎖機制            | 表鎖（一次鎖整張表）         | 行鎖（只鎖影響的行）                |
| 崩潰恢復能力     | 較差，容易資料損毀           | 較佳，內建 redo log + undo log      |
| 讀寫效率         | 快速（尤其在讀多寫少時）      | 相對慢些（但支援高併發處理）        |
| 資料和索引快取   | 只快取索引                  | 索引與資料都可快取於記憶體         |
| 應用場景         | 靜態資料查詢、報表查詢系統   | 交易系統、財務系統、會員登入系統等 |
| 支援全文索引     | ✅（內建）                    | ✅（5.6+ 支援）                     |

---

### 三、實際範例

#### 1. 建立 MyISAM 資料表的語法：

```sql
CREATE TABLE articles (
  id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  title VARCHAR(100),
  content TEXT
) ENGINE=MyISAM;
```

特點：這個表不支援事務，也不能設定外鍵。但查詢大量文章時可能會比較快。

---

#### 2. 建立 InnoDB 資料表的語法（支援外鍵）：

```sql
CREATE TABLE users (
  id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  name VARCHAR(50)
) ENGINE=InnoDB;

CREATE TABLE orders (
  id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  user_id INT UNSIGNED,
  amount DECIMAL(10, 2),
  FOREIGN KEY (user_id) REFERENCES users(id)
) ENGINE=InnoDB;
```

特點：`orders.user_id` 外鍵會參照 `users.id`，若刪除一筆使用者資料，若有相關訂單會被限制不能刪除（除非有 ON DELETE 設定）。

---

### 四、什麼時候選哪一種？

| 場景                            | 推薦存儲引擎 |
|---------------------------------|--------------|
| 電子商務網站、金融系統、交易紀錄 | ✅ InnoDB     |
| 報表分析系統、文章查詢為主系統  | ✅ MyISAM（但 InnoDB 也可） |
| 小型部落格、留言板（讀多寫少）   | ✅ MyISAM     |
| 高並發的會員系統或資料修改頻繁系統 | ✅ InnoDB     |

---

# 7. 阿里巴巴、淘宝用哪个
> **阿里巴巴、淘寶等大型電商平台使用的是經過優化過的 MySQL**，特別是 **Percona Server** 和其專屬的 **XtraDB 存儲引擎**，而不是直接使用官方預設的 InnoDB 或 MyISAM。

---

### 一、什麼是 Percona Server 和 XtraDB？

#### ✅ Percona Server 是什麼？

Percona Server 是由 Percona 公司開發的一個 **MySQL 的加強版（兼容原版 MySQL）**，它主要針對 **高性能、高併發與大數據量環境** 做了優化。

特色：
- 開源、免費
- 向下完全兼容 MySQL
- 針對 InnoDB 優化，並內建一個強化版引擎：**XtraDB**
- 提供更多監控工具、參數與高可用性支援

---

#### ✅ XtraDB 是什麼？

XtraDB 是 Percona 開發的 **InnoDB 的加強版存儲引擎**，解決了 InnoDB 在大型應用中遇到的一些瓶頸，例如：

| 比較項       | InnoDB（原版）               | XtraDB（Percona）                          |
|--------------|------------------------------|--------------------------------------------|
| 支援 MySQL   | MySQL 官方                   | Percona Server（兼容 MySQL）               |
| 鎖機制       | 行鎖                         | 行鎖（更多鎖相關監控與參數）               |
| I/O 調度     | 固定策略                     | 可自定義更多 I/O 緩存與刷盤策略             |
| 高併發支援   | 較一般                       | 提升 buffer pool 使用效率與 mutex 優化     |
| 性能監控     | 少數變量與狀態               | 多達百項監控變量與詳細診斷工具             |

---

### 二、阿里巴巴為什麼會選用 Percona + XtraDB？

因為阿里這種「**每天數十億筆交易請求**」的規模下：
- 官方 InnoDB 的性能和配置彈性無法滿足需求
- 他們需要更高的**併發處理能力**、**更細緻的緩存控制**、以及**更完善的監控工具**
- 所以選擇 Percona Server 並進一步在其上根據業務場景 **自定義修改 XtraDB**

簡單來說：
> 阿里用的是「經過自己魔改的 Percona + XtraDB」，不是官方 MySQL 原版。

---

### 三、舉個範例讓你理解

#### 1️⃣ 假設你用原版 MySQL + InnoDB：

```sql
CREATE TABLE orders (
  id INT PRIMARY KEY AUTO_INCREMENT,
  user_id INT,
  total DECIMAL(10,2),
  status VARCHAR(20)
) ENGINE=InnoDB;
```

在高併發下，你可能會遇到：
- 鎖等待變長
- Buffer Pool 不夠用但調參受限
- 查不出哪一條查詢造成資源緊張

---

#### 2️⃣ 如果你換成 Percona Server + XtraDB：

```sql
CREATE TABLE orders (
  id INT PRIMARY KEY AUTO_INCREMENT,
  user_id INT,
  total DECIMAL(10,2),
  status VARCHAR(20)
) ENGINE=XtraDB;
```

你就可以：
- 使用更細緻的參數優化 buffer_pool、redo log 刷盤行為
- 查詢 `SHOW ENGINE INNODB STATUS` 得到更豐富的診斷資訊
- 利用 Percona Toolkit 進行無停機調整和複製
- 享受來自阿里、Percona 社群不斷優化的引擎核心

---

### 四、小結：何時該考慮 XtraDB？

| 使用場景                             | 建議使用引擎         |
|--------------------------------------|----------------------|
| 小型應用（例如部落格、留言板）       | InnoDB 就夠用         |
| 中型應用（每日數十萬筆交易）         | Percona Server + InnoDB 或 MariaDB |
| 大型應用（高頻交易、電商、金融）     | Percona Server + XtraDB（可改造）|

---

### 五、補充：阿里自己的 MySQL 發展

阿里後來發展出了自己的資料庫產品：
- **AliSQL**：基於 MySQL 的阿里內部版本（主要基於 Percona Server）
- **OceanBase**：分布式資料庫，用來取代部分 MySQL 使用場景

---

# 8. 课外补充：
## 8.1 InnoDB表的优势
### 一、InnoDB 的核心優勢整理

| 功能/特性 | 說明 |
|----------|------|
| ✅ 事務支持 | 支援 ACID 特性，自動處理崩潰恢復（Redo/Undo Log） |
| ✅ 緩衝池機制 | 資料和索引皆可緩存在記憶體，提升存取效率 |
| ✅ 外鍵支持 | 保證資料完整性，自動同步父子表變更 |
| ✅ 高併發與行鎖 | 行鎖支援高併發讀寫，減少鎖衝突 |
| ✅ 自適應哈希索引 | 常查詢欄位會自動加速查詢 |
| ✅ 可壓縮表 | 表與索引可壓縮，節省儲存空間 |
| ✅ 大欄位支持 | BLOB 與 TEXT 使用行外儲存（row overflow） |
| ✅ 支援多引擎混用 | 可以與 MyISAM 等表混合查詢 |
| ✅ 崩潰後自動恢復 | 重啟時自動「回滾未提交」+「保留已提交」 |
| ✅ 線上操作支援 | 建立/刪除索引時不中斷服務（Online DDL） |

---

### 二、舉例說明 InnoDB 的幾個特點

#### ✅ 1. 外鍵與資料完整性控制

```sql
CREATE TABLE customers (
  id INT PRIMARY KEY,
  name VARCHAR(50)
) ENGINE=InnoDB;

CREATE TABLE orders (
  id INT PRIMARY KEY,
  customer_id INT,
  amount DECIMAL(10,2),
  FOREIGN KEY (customer_id) REFERENCES customers(id)
    ON DELETE CASCADE
    ON UPDATE CASCADE
) ENGINE=InnoDB;
```

🔎 說明：
- 若刪除一筆 `customers`，對應的 `orders` 會自動刪除（`CASCADE`）
- 若更改 `customers.id`，會自動更新 `orders.customer_id`

---

#### ✅ 2. 緩衝池（Buffer Pool）與快取性能提升

```sql
-- 查看 InnoDB 緩衝池的狀況
SHOW ENGINE INNODB STATUS;

-- 或從 INFORMATION_SCHEMA 查看緩衝池統計
SELECT * FROM information_schema.INNODB_BUFFER_POOL_STATS;
```

🔎 說明：
- InnoDB 會將**熱資料與索引**預先載入記憶體，避免磁碟 IO
- 在伺服器上建議配置記憶體的 60~80% 給 `innodb_buffer_pool_size` 提升效能

---

#### ✅ 3. 自適應哈希索引（Adaptive Hash Index）

這是一種 **InnoDB 自動啟用的優化機制**，當你反覆查詢某一欄位時（例如 email），InnoDB 會動態為該索引建立哈希加速：

```sql
SELECT * FROM users WHERE email = 'user@example.com';
```

若這類查詢頻繁發生，InnoDB 會針對 `email` 的索引建立記憶體中的 **哈希對照表**，加速查詢。

---

#### ✅ 4. 大欄位與動態行格式

```sql
CREATE TABLE blog_posts (
  id INT PRIMARY KEY,
  title VARCHAR(100),
  content LONGTEXT
) ENGINE=InnoDB ROW_FORMAT=DYNAMIC;
```

🔎 說明：
- 使用 `ROW_FORMAT=DYNAMIC`，可讓 `content`（大型欄位）**存放在頁面之外的空間**，減少頁面膨脹，效率更高
- 適合放置 BLOB、TEXT 等大欄位內容

---

#### ✅ 5. 線上建立或刪除索引

```sql
ALTER TABLE orders ADD INDEX idx_amount (amount), ALGORITHM=INPLACE, LOCK=NONE;
```

🔎 說明：
- `ALGORITHM=INPLACE` + `LOCK=NONE` 代表**不鎖表**即可完成索引建立
- 適合大表需要不中斷加索引的場景（如：生產環境）

---

### 三、實務應用場景

| 應用場景 | InnoDB 對應優勢 |
|----------|----------------|
| 電商交易系統 | 高併發 + 外鍵保證訂單與使用者一致性 |
| 銀行或金融資料庫 | 崩潰恢復、自動回滾未提交事務 |
| 大數據查詢平台 | 緩衝池、哈希索引、壓縮表節省資源 |
| 社群平台（文章/留言） | 支援 TEXT/BLOB 儲存，ROW_FORMAT 最佳化儲存格式 |

---

### 四、總結口訣幫助記憶

🧠 **InnoDB 優勢口訣：「崩潰不怕，併發強大；快取資料，不鎖整表；支援外鍵，查詢加速。」**

---

## 8.2 InnoDB和ACID模型
> **MySQL 的 InnoDB 存儲引擎是如何實現 ACID 模型**，用來保證數據的可靠性、正確性與穩定性。這對於電商、銀行、交易等商業關鍵場景非常重要。

---

### 一、什麼是 ACID 模型？

ACID 是關於「**資料庫事務可靠性**」的四個核心特性：

| 縮寫 | 中文         | 目的                          |
|------|--------------|-------------------------------|
| A    | 原子性（Atomicity） | 事務不可分割：成功就全部成功，失敗就全都回滾 |
| C    | 一致性（Consistency） | 事務執行前後，資料必須保持一致 |
| I    | 隔離性（Isolation）   | 多筆事務同時進行，互不干擾                     |
| D    | 耐久性（Durability） | 提交的資料不能因當機或斷電而遺失               |

---

### 二、InnoDB 與 ACID 的對應關係 + MySQL 配置範例

---

#### ✅ A. 原子性（Atomicity）

InnoDB 透過「**事務機制**」來保證操作的原子性。

###### 🔧 實作方式：
- 使用 `BEGIN`, `COMMIT`, `ROLLBACK`
- 預設是 `AUTOCOMMIT=1`，每條語句自成事務
- `ROLLBACK` 可讓操作全部回復

###### 📌 範例：

```sql
-- 關閉自動提交
SET autocommit = 0;

START TRANSACTION;

UPDATE accounts SET balance = balance - 100 WHERE id = 1;
UPDATE accounts SET balance = balance + 100 WHERE id = 2;

-- 模擬錯誤（例如銀行轉帳）
-- ROLLBACK; -- 若發現錯誤就中止全部操作

COMMIT; -- 確認無誤後提交整個事務
```

---

#### ✅ C. 一致性（Consistency）

InnoDB 保證即使崩潰也會還原至**一致狀態**。

###### 🔧 實作方式：
- 使用 **Redo Log / Undo Log** 回復或回滾數據
- **雙寫緩衝（Doublewrite Buffer）**：避免磁碟寫入不完整導致資料損壞

###### 📌 MySQL 配置：

```ini
[mysqld]
innodb_doublewrite = ON  -- 啟用雙寫緩衝
```

---

#### ✅ I. 隔離性（Isolation）

InnoDB 提供多種事務隔離級別，以避免髒讀、不可重複讀與幻讀。

###### 🔧 實作方式：
- 使用 `SET TRANSACTION ISOLATION LEVEL` 設定級別
- 使用行級鎖與多版本併發控制（MVCC）

###### 📌 範例：

```sql
-- 設定當前會話為可重複讀
SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;

START TRANSACTION;

SELECT balance FROM accounts WHERE id = 1;

-- 在事務內多次查詢 balance 結果不變（除非自己修改）
```

---

#### ✅ D. 耐久性（Durability）

InnoDB 保證事務提交後資料會**永久儲存**。

###### 🔧 實作方式：
- 日誌刷盤策略：`innodb_flush_log_at_trx_commit`
- 使用同步寫入策略搭配硬體保護（如 UPS、電池緩存）

###### 📌 配置建議：

```ini
[mysqld]
innodb_flush_log_at_trx_commit = 1  -- 每次提交都寫入磁碟（最安全）
sync_binlog = 1                     -- 保證 binlog 同步寫入
```

> ⚠️ 若想提升效能可設為 `2`（刷寫記憶體）或 `0`（延遲寫入），但會降低耐久性。

---

### 三、範例總結：完整 ACID 事務應用

```sql
-- 開始一筆事務
START TRANSACTION;

-- 修改兩個表，保證資料一致性
INSERT INTO orders (user_id, total) VALUES (101, 200.00);
UPDATE users SET balance = balance - 200 WHERE id = 101;

-- 檢查是否符合業務邏輯，若否則回滾
-- ROLLBACK;

-- 提交事務，資料將被持久保存
COMMIT;
```

---

### 四、什麼情況會「部分放棄 ACID」以換取效能？

| 場景                           | 配置建議                    |
|--------------------------------|-----------------------------|
| 寫入量大但可容忍部分丟失       | `innodb_flush_log_at_trx_commit = 2` |
| 讀多寫少的日誌型系統           | 降低事務隔離等級：`READ COMMITTED` |
| 有高階 UPS、不怕當機           | 可暫時關閉 `doublewrite`             |

---

### 五、總結記憶法：InnoDB 的 ACID 對應四寶

- A → **事務語法三兄弟：BEGIN / COMMIT / ROLLBACK**
- C → **雙寫緩衝 + 崩潰恢復機制**
- I → **隔離級別 + MVCC 行鎖控制**
- D → **Redo 日誌 + log 刷盤策略**

---

## 8.3 InnoDB架构
### 🔧 一、核心緩衝區設計：效能關鍵

#### 1️⃣ **緩衝池（Buffer Pool）**
- 📌 功能：用於快取**表資料頁**與**索引頁**，避免每次查詢都從磁碟讀資料。
- 📦 預設大小由 `innodb_buffer_pool_size` 控制（推薦為總記憶體 60%~80%）。
- 🚀 熱資料留在記憶體中，加快查詢速度。

###### 🧪 範例操作：

```sql
-- 查詢當前的緩衝池使用情況
SHOW ENGINE INNODB STATUS;

-- 調整緩衝池大小（配置檔）
innodb_buffer_pool_size = 1G
```

---

#### 2️⃣ **自適應哈希索引（AHI）**
- 📌 功能：在經常查詢某欄位的 B+Tree 上，自動加一層哈希加速查詢。
- ⚙️ 控制變數：`innodb_adaptive_hash_index`

###### 🧪 範例操作：

```ini
# 開啟（預設為開）
innodb_adaptive_hash_index = ON

# 關閉
--skip-innodb_adaptive_hash_index
```

---

#### 3️⃣ **更改緩存（Change Buffer）**
- 📌 功能：當更新的**索引頁不在緩衝池**中，就先存在更改緩存中，待未來合併。
- 🎯 適用於輔助索引（非主鍵索引）更新。
- ⚙️ 控制變數：`innodb_change_buffering`

```ini
# 開啟全部更改緩存（預設）
innodb_change_buffering = all
```

---

### 🧱 二、磁碟結構與表空間設計

#### 4️⃣ **系統表空間（System Tablespace）**
- 📌 包含：
  - 資料字典
  - 雙寫緩衝
  - 撤銷日誌
  - 預設表資料
- 🗂 預設在 `ibdata1` 檔案中，位於 MySQL 資料目錄。

---

#### 5️⃣ **每表一檔案表空間（File-Per-Table）**
- 📌 每張表獨立 `.ibd` 檔案，易於備份與管理。
- ⚙️ 控制變數：`innodb_file_per_table`

```ini
innodb_file_per_table = ON  -- 預設開啟
```

---

#### 6️⃣ **通用表空間（General Tablespace）**
- 📌 自定義共享表空間，讓多張表共用一個檔案，可設定不同儲存路徑。

###### 🧪 建立範例：

```sql
CREATE TABLESPACE ts1
  ADD DATAFILE '/var/lib/mysql/ts1.ibd'
  ENGINE = InnoDB;

CREATE TABLE my_table (
  id INT PRIMARY KEY,
  name VARCHAR(50)
) TABLESPACE ts1;
```

---

### 🔁 三、日誌系統：確保資料安全與恢復

#### 7️⃣ **重做日誌（Redo Log）+ 緩衝（Log Buffer）**
- 📌 Redo Log：記錄資料修改意圖；崩潰後可重做確保耐久性。
- 📌 Log Buffer：記錄修改意圖緩存在記憶體，定時寫入磁碟。
- ⚙️ 控制變數：
  - `innodb_log_buffer_size`
  - `innodb_flush_log_at_trx_commit`

```ini
innodb_log_buffer_size = 16M
innodb_flush_log_at_trx_commit = 1
```

---

#### 8️⃣ **雙寫緩衝（Doublewrite Buffer）**
- 📌 避免寫入過程資料損壞。
- 流程：
  1. 先寫入雙寫緩衝（共享空間）
  2. 再寫入真實磁碟位置

```ini
innodb_doublewrite = ON
```

---

#### 9️⃣ **撤銷日誌（Undo Log）**
- 📌 用於：
  - 回滾事務
  - 提供舊版本資料（MVCC）
- 📦 儲存在回滾段與撤銷表空間中（可分離設置）。

```ini
innodb_undo_tablespaces = 2
```

---

#### 🔟 **撤銷表空間、臨時表空間**
- 🔄 **撤銷表空間（Undo Tablespace）**：
  - 存放 Undo Log，可以分檔集中管理。
- 🧪 **臨時表空間（Temp Tablespace）**：
  - MySQL 建立臨時表（如排序、大查詢）時使用。
  - 控制變數：`innodb_temp_data_file_path`

---

### 🧩 四、結構關係圖（文字版）

```
                  ┌────────────────────────────┐
                  │          緩衝池             │
                  └────────────┬───────────────┘
                               │
          ┌────────────────────┴───────────────────┐
          │             索引頁 / 資料頁              │
          │             更改緩存（Change Buffer）    │
          │             哈希索引（AHI）              │
          └────────────────────┬───────────────────┘
                               │
                     ┌────────┴─────────┐
                     │   系統表空間       |─── ibdata1（包含 metadata、rollback 等）
                     │   每表一檔案空間   │─── t1.ibd / t2.ibd
                     │   通用表空間       │─── ts1.ibd
                     │   撤銷表空間       │─── undo_001 / undo_002
                     │   臨時表空間       │─── ibtmp1
                     └────────┬─────────┘
                              │
             ┌──────────────────────────────────┐
             │ Redo Log（事務持久性）             │
             │ Undo Log（查詢一致性、事務回滾）     │
             │ Doublewrite Buffer（防止寫損壞）   │
             └──────────────────────────────────┘
```

---

### ✅ 小結：如何「看懂」InnoDB 架構重點

| 組件                | 關鍵字         | 功能說明                       |
|---------------------|----------------|--------------------------------|
| Buffer Pool         | innodb_buffer_pool_size | 查詢快取                       |
| Change Buffer       | innodb_change_buffering | 優化非主鍵索引更新               |
| Adaptive Hash Index | innodb_adaptive_hash_index | 加速重複查詢的欄位             |
| Redo Log            | innodb_log_buffer_size + flush_log | 保證崩潰恢復                 |
| Undo Log            | innodb_undo_tablespaces | 供 MVCC 和事務回滾使用          |
| File-Per-Table      | innodb_file_per_table | 每表一個 `.ibd` 儲存檔案       |
| Doublewrite Buffer  | innodb_doublewrite | 預寫緩衝，防止磁碟寫錯損壞       |
| Temp Tablespace     | innodb_temp_data_file_path | 大查詢或排序時臨時儲存空間     |

---

# 9. 補充資料
## 9.1 雙寫緩衝（Doublewrite Buffer）
### ✅ 一、什麼是雙寫緩衝（Doublewrite Buffer）？

**雙寫緩衝（Doublewrite Buffer）** 是 InnoDB 為了解決**部分寫入損壞（partial page writes）**的問題而設計的一項保護機制。

---

### ✅ 二、為什麼需要雙寫緩衝？

當資料從記憶體寫入磁碟時，如果：
- 系統突然斷電 / 當機 / 磁碟錯誤
- 造成只有一部分資料頁被寫入（Partial Page Write）

就會讓磁碟上的該頁資料**變成錯誤狀態**，下次啟動時無法復原，**導致資料損壞！**

---

### ✅ 三、InnoDB 的雙寫流程

以下是寫入磁碟的簡化流程：

```
                    Buffer Pool (記憶體中的資料頁)
                            │
                     ↓ Flush 資料頁
                            │
        ┌───────────────────┴────────────────────┐
        │ 寫入 Doublewrite Buffer（共享區域）     │
        │   位置在 ibdata1 系統表空間中           │
        └───────────────────┬────────────────────┘
                            ↓
               將資料從 Doublewrite Buffer 寫入：
             → 對應的資料表 .ibd 檔案的正確位置
```

✔️ 如果中途當機：
- ✅ InnoDB 重啟時會先檢查 Doublewrite Buffer 裡的內容
- ✅ 發現損壞 → 從這裡**修復正確資料頁** → 保證資料完整性

---

### ✅ 四、相關參數配置

你可以在 `my.cnf` 或 `my.ini` 中設定是否開啟：

```ini
[mysqld]
innodb_doublewrite = ON  # 預設為 ON，強烈建議保持開啟
```

---

### ✅ 五、範例模擬理解（概念性）

雖然你無法直接「看到」Doublewrite Buffer 的動作，但可以用概念模型 + 崩潰模擬來幫助理解：

#### ✨ 模擬情境：

你有一個交易表 `transactions`：

```sql
CREATE TABLE transactions (
  id INT PRIMARY KEY AUTO_INCREMENT,
  user_id INT,
  amount DECIMAL(10,2)
) ENGINE=InnoDB;
```

你執行了插入操作：

```sql
INSERT INTO transactions (user_id, amount) VALUES (1001, 999.99);
```

InnoDB 實際處理流程：

1. `999.99` 資料被寫入緩衝池（記憶體）
2. 緩衝池中的該資料頁被 flush：
   - 先寫入到 ibdata1 中的 **Doublewrite Buffer**
   - 再寫入到 `transactions.ibd` 的對應頁
3. 若中間斷電、寫入失敗：
   - ✔️ InnoDB 從 Doublewrite Buffer 把正確頁 reload 回來

---

### ✅ 六、如何觀察 Doublewrite Buffer 存在？

雖然不直接可見，但你可以從狀態查看：

```sql
SHOW ENGINE INNODB STATUS;
```

搜尋關鍵字例如：

- `Doublewrite buffer`
- `Pages written`
- `I/O thread`

也可以在資料目錄中看到 `ibdata1` 檔案，這就是包含：
- Data Dictionary
- Undo Log
- **Doublewrite Buffer**

---

### ✅ 七、小結

| 項目 | 說明 |
|------|------|
| 🎯 功能 | 防止斷電或異常導致資料頁只寫一半（Partial Write） |
| 🧠 工作機制 | 寫兩次：先寫 buffer → 再寫實際位置 |
| 🛡 保護對象 | 所有資料頁 |
| 🔧 是否能關？ | 可以，但強烈建議保留開啟（`innodb_doublewrite = ON`） |
| 💡 補充 | 若使用支援原子寫入的現代 SSD，某些版本 MySQL 可考慮關閉（需配合測試） |

---